\documentclass[10pt]{article}
\usepackage[margin=1.45in]{geometry}
\usepackage{graphicx}
\usepackage{noweb}
\usepackage{mflogo}
\usepackage{amsmath}
\usepackage{textcomp}
\noweboptions{smallcode,longchunks}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{pstricks}
\usepackage{subfig}
\usepackage{booktabs}
\usepackage[normalem]{ulem}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{amssymb}
\useunder{\uline}{\ul}{}

\newcommand{\MyHdr}[6]{
\begin{tabularx}{\textwidth}{XXXXXX}
\hline
  \textbf{UVa ID} & \textbf{Popularity} & \textbf{Success Rate} & \textbf{Level} & \textbf{Personal}      & \textbf{Problem} \\ 
  {#1}            & {#2}                & {#3}                  & {#4}           & {#5}                   & \href{{#6}}{Link} \\ \hline
\end{tabularx}
\vspace{1mm}
}


\begin{document}
\pagestyle{myheadings}\markright{Programming Challenges\hfill \today\hfill}

\vskip 1in
\centerline{\bf Programming Challenges}
\centerline{Roman Valiu\v{s}enko}
\centerline{roman.valiusenko@gmail.com}

\begin{abstract}
This is a collection of literate programs. If you are unfamiliar with the idea
of literate programming please refer \cite{Knuth1984}. These programs are my
solutions to the programming tasks from the ``Programming Challenges''
book\cite{PC} which in turn is a collection of problems from the UVa Online
Judge hosted by University of Valladolid\footnote{If you are going to submit
any of these programs to the UVa Online Judge (which you obviously shouldn't)
make sure the class name is Main and that it is not in any package; Note that
for the class names I use problem names}.  \end{abstract}


\tableofcontents

\newpage
\section{Getting Started}

\subsection{The $3n+1$ Problem}

\MyHdr{100}{A}{low}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/1/100.pdf}

This task is not difficult if you notice that all the lengths of the sequences
can easily be calculated up front. Then all that is needed is to lookup
the pre-calculated table to find out the maximum lengths for the given input
numbers. 

(I noticed though that I could have simply calculated the values on the file
without any tricks. The reason why I have done a more sophisticated algorithm
is that at first I though the input number may go up to 1M, but in reality,
according to the problem statement, they won't exceed 10000.  So I solved a more
tricky problem.)

So let's start with the definitions of the array that will hold all the
[[lengths]] and the [[reader]] that will be used to read the input data.

<<3n+1>>=
<<1.1 Imports>>

class Collatz {
    private static int MAX = 1000000;
    private int[] lengths = new int[MAX];
    private static final BufferedReader reader = 
             new BufferedReader(new InputStreamReader(System.in));
    <<1.1 Helpers>>
    <<1.1 Constructor>>
    <<1.1 Input/Output>>
}
@

We need the necessary imports:

<<1.1 Imports>>=
import java.io.BufferedReader;
import java.io.InputStreamReader;
@

The idea is to hold the lengths of the sequences in the [[lengths]], but
because the sequence member can sometimes go over 1M we will need to store
them somewhere temporarily. For that a [[surplus]] hash map will be used. Its
contents will be thrown away once the sequence lengths were computed. 

So we write two helper methods: [[set]] and [[get]]. Both take an [[index]] and
[[surplus]] hash map and depending on the index value either use the array or
the hash map to set or get a value.

<<1.1 Imports>>=
import java.util.HashMap;
@

<<1.1 Helpers>>=
int get(long index, HashMap<Long, Integer> surplus) {
    return (index < MAX) ? lengths[(int) index] : 
        (surplus.containsKey(index) ? surplus.get(index) : 0);
}

void set(long index, int value, HashMap<Long, Integer> surplus) {
    if (index < MAX) {
        lengths[(int) index] = value;
    } else {
        surplus.put(index, value);
    }
}

@

Now we can easily pre-calculate all the lengths using the helper methods [[set]]
and [[get]], but we must not re-calculate the lengths for the indexes that we
have calculated already. 

We calculate a member of the sequence at each step using the definition. Each
time we calculate a new member of the sequence we push it onto the [[stack]].
We stop if we notice that we already have the length calculated for that
specific value or when we reach 1. Now all the values that are on the stack are
potential inputs, that is they are all potential initial [[n]]s. We use this
knowledge to update elements in the [[lengths]]:

<<1.1 Imports>>=
import java.util.ArrayDeque;
import java.util.Deque;
@

<<1.1 Constructor>>=
Collatz() {
    final HashMap<Long, Integer> surplus = new HashMap<Long, Integer>();
    lengths[1] = 1;
    for (long i = 2; i < MAX; ++i) {
        final Deque<Long> stack = new ArrayDeque<Long>();
        long n = i;
        int len = 2;
        while (n != 1) {
            stack.push(n);
            int prev = get(n, surplus);
            if (prev > 0) {
                len = prev;
                break;
            }
            n = n % 2 == 0 ? n / 2 : n * 3 + 1;
        }
        while (!stack.isEmpty()) {
            set(stack.pop(), len++, surplus);
        }
    }
}

@

Processing the input is easy but cumbersome\footnote{It turns out that the UVa
Judge tends to give some extra spaces here and there in the input, so we need
to make sure we account for some sporadic spaces in the input. This was my
first submission and it took me seven attempts before I got past that super
annoying "Runtime Error", because the judge was giving some extra spaces
between the values which my program was not taking into account.}:

<<1.1 Imports>>=
import java.util.stream.IntStream;
@

<<1.1 Input/Output>>=
public static void main(String[] args) {
    Collatz s = new Collatz();
     String input;
     while ((input = reader.readLine()) != null &&
             !input.trim().equalsIgnoreCase("")) {
         List<String> str = Arrays.stream(input.trim().split(" "))
            .filter(x -> !x.equals("")).collect(Collectors.toList());
         int x[] = new int[] { Integer.parseInt(str.get(0)),
                 Integer.parseInt(str.get(1)) };
         System.out.println(x[0] + " " + x[1] + " " +
                 IntStream.rangeClosed(Math.min(x[0], x[1]), Math.max(x[0],
                         x[1])).map(v -> s.lengths[v]).max().getAsInt());
     }
}
@

\subsection{Minesweeper}

\MyHdr{10198}{A}{high}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/101/10189.pdf}

This task is trivial: We simply count the number of mines around each cell.
There are eigth cells around each cell that we need to inspect. If our cell is
$(x, y)$, then we check $(x-1, y-1)$, $(x, y-1)$ and so on, and count the
number of cells that have '*' in them.

Our program structure is simple as usual:

<<Minesweeper>>=
<<1.2 Imports>>

class Minesweeper {
    <<1.2 Constants>>
    <<1.2 Main>>
}
@

Of course, we need a reader, so we define it next. Then we need to define the
constants. We are going to split the lines by spaces, so let's have it as a
constant. We also define an array of the offsets [[p]] to determine the
cells around a given cell.

<<1.2 Imports>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
@

<<1.2 Constants>>=
private static final BufferedReader reader = 
    new BufferedReader(new InputStreamReader(System.in));
private static final String SPACE = " ";
private static final int[][] p = new int[][] {
        { -1, -1 }, { 0, -1 }, { 1, -1 }, { -1, 0 }, 
        { 1, 0 }, { -1, 1 }, { 0, 1 }, { 1, 1 }
};

@

Now let's write the main method. I'll delibirately use one-dimentional array
instead of the two-dimensional, and I will use a couple of helper lambdas. One,
[[count]], to count the mines around a cell, and another, [[mine]], which
returns a cell value for the given coordinates. 

<<1.2 Imports>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.range;
import java.util.List;
import java.util.function.IntBinaryOperator;
import java.util.function.IntUnaryOperator;
@

<<1.2 Main>>=
public static void main(String[] args) throws IOException {
    int lineNum = 0;
    String currentLine = INPUT_END;
    while ((currentLine = reader.readLine()) != null) {
        if (currentLine.equalsIgnoreCase("")) {
            continue;
        }
        List<Integer> nm = stream(currentLine.split(SPACE))
                .filter(x -> !x.equals("")).map(Integer::parseInt).collect(toList());;
        int n = nm.get(0);
        int m = nm.get(1);
        if (n == 0 && m == 0) {
            break;
        }

        final int[] field = reader.lines().limit(n)
            .collect(joining()).chars().map(x -> x == '*' ? -1 : 0).toArray();

        final IntBinaryOperator mine = 
           (x, y) -> (x < 0 || x > (n - 1) || y < 0 || y > (m - 1)) ? 0 : field[x * m + y];

        final IntUnaryOperator count = (i) -> range(0, p.length)
            .map(j -> Math.abs(mine.applyAsInt(i / m + p[j][0], i % m + p[j][1]))).sum();

        int[] result = range(0, field.length)
            .map(x -> field[x] >= 0 ? count.applyAsInt(x) : field[x]).toArray();

        if (lineNum > 0) {
            System.out.println();
        }

        System.out.println("Field #" + (++lineNum) + ":");
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                System.out.print(result[i * m + j] == -1 ? "*" : result[i * m + j]);
            }
            System.out.println();
        }
    }
}
@

\subsection{The Trip}

\MyHdr{10137}{B}{averge}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/101/10137.pdf}

This task is much more fun that the previous two. The important thing that we
should note for ourselves is that we are not going to use the floating point
types to do the calculations.

<<The Trip>>=
<<1.3 Imports>>

class TheTrip {
    <<1.3 Calculation>>
    <<1.3 Input/Output>>
}
@

First thing we need to do is to calculate the average spend, don't we? Because
we know that the input is a list of how much each of [[n]] students spent,
let's define a function that takes this list of values and returns the minimum
amount of money asked in the problem. Of course, the types will be [[long]].
And we can immediately cover the degenerate case of a input consisting of one
element:

<<1.3 Imports>>=
import static java.util.Arrays.stream;
@

<<1.3 Calculation>>=
static long calculate(long[] values) {
    if (values.length == 1)
        return 0;
    long total = stream(values).sum();
    <<1.3 Finding the minimum>>
}

@

Now we need to partition the students into two groups: One group of students
that will be giving money (those that spent less than group average) and the
ones who will be receiving the money (those that spent more than the group
average). But the [[total]] won't always divide without a reminder. So we
divide the [[total]] by the number of students to get the quotient and the
reminder, and we partition only using the quotient; that is group 1 will
contain spends $x$ such that $x - quotient \leq 0$, and group 2 will have the others.

<<1.3 Imports>>=
import static java.lang.Math.abs;
import static java.util.stream.Collectors.partitioningBy;
import java.util.List;
import java.util.Map;
@

<<1.3 Finding the minimum>>=
long quotient = total / values.length;
long reminder = total % values.length;
Map<Boolean, List<Long>> diff = 
    stream(values).map(x -> x - quotient).boxed().collect(partitioningBy(x -> x > 0));
@ 

So what do we do with the [[reminder]]? These are those cents that we need to
finally re-distribute among the members of the two groups. Note that the
[[reminder]] will always be less than [[n]]. We choose the following strategy:
We distribute these cents to the group that spent less than or equal to the
[[quotient]], the remaining cents are finally distributed to group 2. This is
captured in the following code:

<<1.3 Finding the minimum>>=
long sum = abs(diff.get(false).stream().reduce(Long::sum).get());
long len = diff.get(true).size();
reminder = len <= reminder ? reminder - len : 0;
return sum + reminder;
@ 

All we need to do now is to write input reading, which is trivial:

<<1.3 Imports>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
@

<<1.3 Input/Output>>=
public static void main(String[] args) throws IOException {
    BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
    int n = 0;
    while ((n = Integer.parseInt(r.readLine().trim())) > 0) {
        long[] values = r.lines().limit(n).map(x -> x.replaceAll("\\.",
                "").trim()).mapToLong(Long::parseLong).toArray();
        System.out.println("$" + BigDecimal.valueOf(calculate(values), 2));
    }
}
@

\subsection{LC Display}

\MyHdr{706}{A}{average}{1}{$\bigstar\bigstar$}{https://uva.onlinejudge.org/external/7/706.pdf}

This task may seem quite involved at first sight, because you may start
thinking about two-dimensional patterns and scaling functions. But in reality
this task is much easier if you notice that the digits can be constructed not in
a top to bottom (or bottom to up) row-by-row manner, but in a columnar manner;
at the same time scaling becomes very easy. 

<<LC Display>>=
<<1.4 Imports>>

class LCDisplay {
    <<1.4 Constants>>
    <<1.4 Convertion>>
    <<1.4 Input/Output>>
}
@

Each LCD digit has 7 segments: Two in the first and the third columns and
three in the second column. Let's encode our digits as in the table.

\begin{table}
\begin{center}
\begin{tabular}{ l | l | l }
\hline
Digit & Binary & Hex \\
\hline
0 & 11 101 11 & 77 \\
1 & 00 000 11 & 03 \\
2 & 10 111 01 & 5D \\
3 & 00 111 11 & 1F \\
4 & 01 010 11 & 2B \\
5 & 01 111 10 & 3E \\
6 & 11 111 10 & 7E \\
7 & 00 001 11 & 07 \\
8 & 11 111 11 & 7F \\
9 & 01 111 11 & 3F \\
\hline
\end{tabular}
\caption{LCD segments}
\end{center}
\end{table}

Since we know that the input ends in two zeros we define this string constant
plus a couple of other string constants.

<<1.4 Imports>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.stream.Stream;
@

<<1.4 Constants>>=
private static final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
private static final String INPUT_END = "0 0";
private static final String EMPTY = "";
private static final String SPACE = " ";
private static final byte[] pattern = new byte[] {
        0x77, 0x03, 0x5d, 0x1f, 0x2b, 0x3e, 0x7e, 0x07, 0x7f, 0x3f
};

@

The array [[pattern]] for the given digit [[i]] returns bits that correspond to
the segments, so for example [[digits[5]]] would return segments for digit 5.
We will be using masks to discover which bits are set and not set.

But let's write input/output first as this is very easy. At the same time, let's
assume our method that converts a string into LCD style digits is called
[[segments]]. This method takes two arguments, the digits string and [[scale]].
Let's assume it returns list of strings which we can simply output to the console.

<<1.4 Input/Output>>=
public static void main(String[] args) throws IOException {
    String currentLine = INPUT_END;
    while ((currentLine = reader.readLine()) != null && 
            !currentLine.trim().equalsIgnoreCase(INPUT_END)) {
        List<String> input = Arrays.stream(currentLine.trim().split(SPACE))
            .filter(x -> !x.equals("")).collect(Collectors.toList());
        segments(input.get(1), Integer.valueOf(input.get(0))).stream()
            .forEach(System.out::println);
        System.out.println();
    }
}
@

Now all that's left is to implement [[segments]]. 

<<1.4 Convertion>>=
private static List<String> segments(final String digits, final int scale) {
    <<1.4 Helpers>>
    <<1.4 Process>>
    <<1.4 Return>>
}

@

The idea is simple: We check bit 6 and bit 5 of the pattern and construct ASCII
representation of the first column, then we check bit 4, 3, and 2 and construct
the middle column, finally we check bit 1 and 0 to construct the last column.
Of course, we need to take into account the scaling.

So let's have a look at an example. Let's say we need to construct digit 2 with
scale 3. First, we get the pattern value [[pattern[2]]]=5D, or 1011101.
Then, we start with the masks $40$ and $20$ to see which segments are on in the
first column (bit 6 and bit 5); so, [[40 & 5D = 1]] and [[20 & 5D = 0]], which
means that the first segment is on and the second is off, so we output
$\textvisiblespace\vert\textvisiblespace\textvisiblespace\textvisiblespace$.
Because our scale is 3, we output $\vert$ and $\textvisiblespace$ three times,
so we end up with
$\textvisiblespace\vert\vert\vert\textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace$;
Similarly we construct the third column, but we use different masks: $02$ and
$01$.

OK, let's write some helpers already before we get back to producing the
middle column. We will need some function that replicates a specified string
$n$ times. There's a Java function [[nCopies]] that does that, so we will use
it. However, it returns a list of strings, therefore we use [[join]] function
to join that into a single string using [[EMPTY]] as a delimiter. Let's write
that:

<<1.4 Imports>>=
import static java.lang.String.join;
import static java.util.Collections.nCopies;
import java.util.function.Function;
@

<<1.4 Helpers>>=
Function<String, String> g = x -> join(EMPTY, nCopies(scale, x));
@

Note that we use the fact that the [[scale]] is captured in the closure.

OK, we also need a mapping function that checks which bits are on and off in
the given value using the list of masks. Depending on whether bits are on or
off it returns ASCII character $\vert$ or $\textvisiblespace$. It will be a
stream of such characters:

<<1.4 Helpers>>=
BiFunction<Stream<Integer>, Byte, Stream<String>> h = 
    (m, x) -> m.map(mask -> (x & mask) > 0 ? "|" : SPACE);
@

Here [[m]] is a stream of masks, and [[x]] is the value [[pattern[i]]] for some
[[i]]. Note the function returns a stream as well.

Now we can write a function that constructs a column of our LCD digit. Let's
call it [[k]]:

<<1.4 Imports>>=
import static java.util.stream.Collectors.joining;
import java.util.function.BiFunction;
@

<<1.4 Helpers>>=
BiFunction<Stream<Integer>, Byte, String> k = 
    (m, d) -> SPACE + h.apply(m, d).map(x -> g.apply(x)).collect(joining(SPACE)) + SPACE;
@

Note [[SPACE]]s around (as per requirement) and that the segments within a
column are joined by a space.

So far so good. Basically we can now write function [[f]] that takes a digit
pattern [[pattern[i]]] and returns a stream of strings (in fact, the columns of
our LCD digits). 

<<1.4 Imports>>=
import static java.util.stream.Collectors.toList;
import static java.util.stream.Stream.of;
import java.util.Arrays;
@

<<1.4 Helpers>>=
final int digitHeight = scale * 2 + 3;
Function<Byte, Stream<String>> f = x -> Arrays.asList(
  of(k.apply(of(0x40, 0x20), x)),
  <<1.4 Middle Column Construction>>,
  of(k.apply(of(0x02, 0x01), x)),
  of(join(EMPTY, nCopies(digitHeight, SPACE))))
    .stream().reduce(Stream::concat).get();

@

Also note the last line which adds spaces between consecutive digits.

Finally, let's get back to the middle of the digit. To contruct it, we will
re-use exactly the same functions we've already defined. We use [[h]] to obtain
the segments that are on and off. Note though that [[h]] returns $\vert$
symbols, not the dashes, which are used to indicate horizontal LCD segments. So
we will need to replace all occurances of vertical bars with dashes. It's easy
to see that the number of spaces between the horizontal segments will be
exactly [[scale]], which is already captured in the [[g]] function
implementation. Finally, all we need to do, is to replicate the middle column
[[scale]] times. All this can be very easily implemented like so:

<<1.4 Middle Column Construction>>=
nCopies(scale, h.apply(of(0x10, 0x08, 0x04), x)
    .collect(joining(g.apply(SPACE))).replace('|', '-')).stream()
@

Now we can map the string of digits using our [[f]] function:

<<1.4 Imports>>=
import java.util.List;
@

<<1.4 Process>>=
List<String> segments = digits.chars().map(x -> x - '0').boxed()
    .flatMap(x -> f.apply(pattern[x])).collect(toList());

@

But remember, this gives us a list of columns of the LCD digits, not rows, so
before returning it we need a little post-processing: For each column we take
the last characters, concatenate these last characters into a string, and add
to a list; then we take the next to the last characters and do the same, and so
on:

<<1.4 Imports>>=
import static java.util.stream.IntStream.range;
import static java.util.stream.IntStream.rangeClosed;
@

<<1.4 Return>>=
return rangeClosed(1, digitHeight).boxed()
    .map(j -> digitHeight - j).map(j -> range(0, segments.size() - 1).boxed()
    .map(i -> Character.toString(segments.get(i).charAt(j))).collect(joining())).collect(toList());
@

And that completes the program.

\subsection{Graphical Editor}

\MyHdr{10267}{B}{low}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/102/10267.pdf}

Very straightforward task. The only difficult part being the [[fill]]
operation, but I leave it without comments either as the code is
self-explanatory.

<<Graphical Editor>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;

public class GraphicalEditor {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    private int[][] canvas;
    private int m = 0, n = 0;

    private void clear() {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                canvas[j][i] = 'O';
            }
        }
    }

    private void execute(List<String> command) {
        int x, y1, y2, y, x1, x2, c;
        switch (command.get(0)) {
        case "I":
            m = Integer.parseInt(command.get(1));
            n = Integer.parseInt(command.get(2));
            canvas = new int[m][n];
            clear();
            break;
        case "C":
            clear();
            break;
        case "L":
            x = Integer.parseInt(command.get(1)) - 1;
            y = Integer.parseInt(command.get(2)) - 1;
            canvas[x][y] = command.get(3).charAt(0);
            break;
        case "V":
            x = Integer.parseInt(command.get(1)) - 1;
            y1 = Integer.parseInt(command.get(2)) - 1;
            y2 = Integer.parseInt(command.get(3)) - 1;
            c = command.get(4).charAt(0);
            for (y = Math.min(y1, y2); y <= Math.max(y1, y2); ++y) {
                canvas[x][y] = c;
            }
            break;
        case "H":
            x1 = Integer.parseInt(command.get(1)) - 1;
            x2 = Integer.parseInt(command.get(2)) - 1;
            y = Integer.parseInt(command.get(3)) - 1;
            c = command.get(4).charAt(0);
            for (x = Math.min(x1, x2); x <= Math.max(x1, x2); ++x) {
                canvas[x][y] = c;
            }
            break;
        case "K":
            x1 = Integer.parseInt(command.get(1)) - 1;
            y1 = Integer.parseInt(command.get(2)) - 1;
            x2 = Integer.parseInt(command.get(3)) - 1;
            y2 = Integer.parseInt(command.get(4)) - 1;
            c = command.get(5).charAt(0);
            for (x = x1; x <= x2; ++x) {
                for (y = y1; y <= y2; ++y) {
                    canvas[x][y] = c;
                }
            }
            break;
        case "F":
            x = Integer.parseInt(command.get(1)) - 1;
            y = Integer.parseInt(command.get(2)) - 1;
            int newColor = command.get(3).charAt(0);
            int oldColor = canvas[x][y];
            fill(new Point(x, y), oldColor, newColor);
            break;
        case "S":
            String name = command.get(1);
            System.out.println(name);
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < m; ++j) {
                    System.out.print((char) canvas[j][i]);
                }
                System.out.println();
            }
            break;
        default:
            break;
        }
    }

    private static class Point {
        final int x, y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    private void fill(Point pt, int oldColor, int newColor) {
        if (canvas[pt.x][pt.y] != oldColor || oldColor == newColor) {
            return;
        }
        Deque<Point> q = new ArrayDeque<>();
        q.addLast(pt);
        canvas[pt.x][pt.y] = newColor;
        while (!q.isEmpty()) {
            pt = q.pop();
            if (pt.x + 1 < m && canvas[pt.x + 1][pt.y] == oldColor) {
                canvas[pt.x + 1][pt.y] = newColor;
                q.addLast(new Point(pt.x + 1, pt.y));
            }
            if (pt.x - 1 >= 0 && canvas[pt.x - 1][pt.y] == oldColor) {
                canvas[pt.x - 1][pt.y] = newColor;
                q.addLast(new Point(pt.x - 1, pt.y));
            }
            if (pt.y + 1 < n && canvas[pt.x][pt.y + 1] == oldColor) {
                canvas[pt.x][pt.y + 1] = newColor;
                q.addLast(new Point(pt.x, pt.y + 1));
            }
            if (pt.y - 1 >= 0 && canvas[pt.x][pt.y - 1] == oldColor) {
                canvas[pt.x][pt.y - 1] = newColor;
                q.addLast(new Point(pt.x, pt.y - 1));
            }
        }
    }

    public static void main(String[] args) throws IOException {
        GraphicalEditor editor = new GraphicalEditor();
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            List<String> command = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals("")).collect(toList());
            if (command.get(0).equalsIgnoreCase("X")) {
                break;
            }
            editor.execute(command);
        }
    }
}
@

\subsection{Interpreter}

\MyHdr{10033}{B}{low}{2}{$\bigstar$}{https://uva.onlinejudge.org/external/100/10033.pdf}

This task is disappointingly straightforward.

<<Interpreter>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

class Interpreter {
    private static final BufferedReader reader = 
        new BufferedReader(new InputStreamReader(System.in));

    private static int interpret(List<Integer> input) {
        int[] reg = new int[10];
        int[] ram = new int[1000];
        for (int i = 0; i < input.size(); ++i) {
            ram[i] = input.get(i);
        }
        int pc = 0;
        int r = 0;
        while (ram[pc] != 100) {
            int op = ram[pc];
            int c = (op / 100) % 10;
            pc = (pc + 1) % 1000;
            r++;
            switch (c) {
            case 2:
                reg[(op / 10) % 10] = op % 10;
                break;
            case 3:
                reg[(op / 10) % 10] = (reg[(op / 10) % 10] + (op % 10)) % 1000;
                break;
            case 4:
                reg[(op / 10) % 10] = (reg[(op / 10) % 10] * (op % 10)) % 1000;
                break;
            case 5:
                reg[(op / 10) % 10] = reg[op % 10];
                break;
            case 6:
                reg[(op / 10) % 10] = (reg[(op / 10) % 10] + reg[op % 10]) % 1000;
                break;
            case 7:
                reg[(op / 10) % 10] = (reg[(op / 10) % 10] * reg[op % 10]) % 1000;
                break;
            case 8:
                reg[(op / 10) % 10] = ram[reg[op % 10]];
                break;
            case 9:
                ram[reg[op % 10]] = reg[(op / 10) % 10];
                break;
            case 0:
                if (reg[op % 10] != 0) {
                    pc = reg[(op / 10) % 10];
                }
                break;
            }
        }

        return r + 1;
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.valueOf(reader.readLine().trim());
        reader.readLine();
        String currentLine;
        for (int i = 0; i < n; ++i) {
            List<Integer> input = new ArrayList<Integer>();
            while ((currentLine = reader.readLine()) != null &&
                    !currentLine.trim().equalsIgnoreCase("")) {
                input.add(Integer.parseInt(currentLine.trim()));
            }
            System.out.println(interpret(input));
            if (i < n - 1) {
                System.out.println();
            }
        }
    }
}
@

\subsection{Check The Check}

\MyHdr{10196}{B}{average}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/101/10196.pdf}

This task is trivial.

<<Check The Check>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class CheckTheCheck {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    private static final int BOARD_SIZE = 8;

    private static final int[][] king = new int[][] {
            { -1, -1 }, { 0, -1 }, { 1, -1 }, { -1, 0 }, { 1, 0 }, { -1, 1 },
            { 0, 1 }, { 1, 1 }
    };
    private static final int[][] knight = new int[][] {
            { -2, -1 }, { -1, -2 }, { 1, -2 }, { 2, -1 }, { 2, 1 }, { 1, 2 },
            { -1, 2 }, { -2, 1 }
    };
    private static final int[][] bishop = new int[][] {
            { 1, 1 }, { -1, -1 }, { -1, 1 }, { 1, -1 }
    };
    private static final int[][] rook = new int[][] {
            { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 }
    };
    private static final int[][] queen = new int[][] {
            { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 }, { 1, 1 }, { -1, -1 },
            { -1, 1 }, { 1, -1 }
    };
    private static final int[][] white_pawn = new int[][] {
            { -1, -1 }, { -1, 1 }
    };
    private static final int[][] black_pawn = new int[][] {
            { 1, -1 }, { 1, 1 }
    };

    private static boolean isWithinBounds(int d, int v) {
        if (d == 0) {
            return true;
        }
        return d > 0 ? (v < BOARD_SIZE) : (v >= 0);
    }

    private static void check(int di, int dj, int i, int j, int[][] board,
            int[][] attackBoard) {
        int c = j + dj;
        int r = i + di;
        while (isWithinBounds(dj, c) && isWithinBounds(di, r)) {
            attackBoard[r][c] = 1;
            if (board[r][c] != '.')
                break;
            r += di;
            c += dj;
        }
    }

    private static void check(int[][] d, int i, int j, int[][] board,
            int[][] attackBoard) {
        if (d == king || d == knight || d == black_pawn || d == white_pawn) {
            for (int k = 0; k < d.length; ++k) {
                if ((i + d[k][0] >= 0 && i + d[k][0] < BOARD_SIZE) &&
                        (j + d[k][1] >= 0 && j + d[k][1] < BOARD_SIZE)) {
                    attackBoard[i + d[k][0]][j + d[k][1]] = 1;
                }
            }
            return;
        }

        for (int k = 0; k < d.length; ++k) {
            check(d[k][0], d[k][1], i, j, board, attackBoard);
        }
    }

    private static int[] locate(int v, int[][] board) {
        for (int i = 0; i < BOARD_SIZE; ++i) {
            for (int j = 0; j < BOARD_SIZE; ++j) {
                if (board[i][j] == v) {
                    return new int[] { i, j };
                }
            }
        }
        return null;
    }

    private static String checkTheCheck(int[][] board) {
        int[][] attackBoardWhites = new int[BOARD_SIZE][BOARD_SIZE];
        int[][] attackBoardBlacks = new int[BOARD_SIZE][BOARD_SIZE];

        for (int i = 0; i < BOARD_SIZE; ++i) {
            for (int j = 0; j < BOARD_SIZE; ++j) {
                if (board[i][j] == 'R' || board[i][j] == 'r') {
                    check(rook, i, j, board, board[i][j] == 'R'
                            ? attackBoardWhites : attackBoardBlacks);
                }
                if (board[i][j] == 'B' || board[i][j] == 'b') {
                    check(bishop, i, j, board, board[i][j] == 'B'
                            ? attackBoardWhites : attackBoardBlacks);
                }
                if (board[i][j] == 'K' || board[i][j] == 'k') {
                    check(king, i, j, board, board[i][j] == 'K'
                            ? attackBoardWhites : attackBoardBlacks);
                }
                if (board[i][j] == 'N' || board[i][j] == 'n') {
                    check(knight, i, j, board, board[i][j] == 'N'
                            ? attackBoardWhites : attackBoardBlacks);
                }
                if (board[i][j] == 'Q' || board[i][j] == 'q') {
                    check(queen, i, j, board, board[i][j] == 'Q'
                            ? attackBoardWhites : attackBoardBlacks);
                }
                if (board[i][j] == 'P' || board[i][j] == 'p') {
                    boolean isWhite = board[i][j] == 'P';
                    check(isWhite ? white_pawn : black_pawn, i, j, board,
                            isWhite ? attackBoardWhites : attackBoardBlacks);
                }
            }
        }

        int[] wk = locate('K', board);
        int[] bk = locate('k', board);

        boolean bkCheck = (attackBoardWhites[bk[0]][bk[1]] == 1);
        boolean wkCheck = (attackBoardBlacks[wk[0]][wk[1]] == 1);

        if (wkCheck) {
            return "white king is in check.";
        }
        if (bkCheck) {
            return "black king is in check.";
        }

        return "no king is in check.";
    }

    public static void main(String[] args) throws IOException {
        boolean empty = true;
        int game = 1;
        do {
            int[][] board = new int[BOARD_SIZE][BOARD_SIZE];
            empty = true;
            for (int i = 0; i < BOARD_SIZE; ++i) {
                String currentLine = reader.readLine();
                for (int j = 0; j < BOARD_SIZE; ++j) {
                    board[i][j] = currentLine.charAt(j);
                    empty = empty && board[i][j] == '.';
                }
            }
            if (empty) {
                break;
            }
            System.out.println("Game #" + game + ": " + checkTheCheck(board));
            game++;
        } while (reader.readLine().trim().equals(""));
    }
}

@

\subsection{Australian Voting}

\MyHdr{10142}{B}{low}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/101/10142.pdf}

This task is very straightforward. 

Let's sort out input/output first as usual. We will assume our function that
does the election is called [[elect]], and that it takes two arguments, a list
of candidates and a list of ballots, and returns a list of those who win the
election. Note the [[ballots]] is a list of deques, that's because we will be
checking the next candidate in the ranking, and note that we subtract one from
each index in the ballots, this is for easier access to the arrays, as
they are indexed from 0.

<<Australian Voting>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
<<1.8 Imports>>

class AustralianVoting {
    private static final String EMPTY = "";
    private static final BufferedReader reader = 
        new BufferedReader(new InputStreamReader(System.in));

    private static List<String> elect(List<String> candidates, 
            List<Deque<Integer>> ballots) {
        <<1.8 Implementation>>
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.valueOf(reader.readLine().trim());
        reader.readLine();
        for (int i = 0; i < n; ++i) {
            int count = Integer.valueOf(reader.readLine().trim());
            List<String> candidates = reader.lines().limit(count).collect(toList());
            List<Deque<Integer>> ballots = new ArrayList<Deque<Integer>>();
            String currentLine = EMPTY;
            while ((currentLine = reader.readLine()) != null && 
                    !currentLine.equalsIgnoreCase(EMPTY)) {
                ballots.add(new ArrayDeque<Integer>(stream(currentLine.trim().split(" "))
                        .filter(x -> !x.equals(EMPTY))
                        .map(Integer::parseInt).map(x -> x - 1).collect(toList())));
            }
            elect(candidates, ballots).forEach(System.out::println);
            if (i < n - 1) {
                System.out.println();
            }
        }
    }
}
@

Now let's implement [[elect]] function. First we need to figure out the
majority. That's easy as that's simply the half of the ballots plus one.

<<1.8 Implementation>>=
final int majority = ballots.size() / 2 + 1;
@

Because candidates in the ballots are numbered by their indexes in the table,
let's have an array of [[int]]s, which will hold the number of votes.

<<1.8 Implementation>>=
final int[] counter = new int[candidates.size()];
@

Now let's count votes for the candidates specified as first in the ballots:

<<1.8 Implementation>>=
ballots.stream().map(Deque::peek).forEach(x -> counter[x]++);
@

After this point two things may happen: We will have somebody who got the
majority of the votes, in which case we know the winner (or winners), or not,
in which case we repeat the procedure described in the problem statement.

<<1.8 Implementation>>=
while (true) {
    <<1.8 Election loop>>
}
@

OK, because some candidates may get equal number of votes we need to group
them by votes. This is pretty easy:

<<1.8 Imports>>=
import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.IntStream.range;
import java.util.Map;
@

<<1.8 Election loop>>=
Map<Integer, List<Integer>> result = range(0, candidates.size()).boxed()
    .filter(x -> counter[x] >= 0).collect(groupingBy(i -> counter[i], toList()));
@

Pay attention to the candidates who got zeros votes, because those will need to
go through the elimination process too.

Now we need to find out who got the most votes and who got the least:

<<1.8 Election loop>>=
int max = result.keySet().stream().max(Integer::compareTo).get();
int min = result.keySet().stream().min(Integer::compareTo).get();
@

It's easy to see that if $max \geq majority$ or $max = min$, then we know the
winner:

<<1.8 Election loop>>=
if (max >= majority || max == min) {
    return result.get(max).stream().map(x -> candidates.get(x)).collect(toList());
}
@

Otherwise we need to re-distribute the votes. We get the indexes of the
candidates who got the least votes and mark them as having -1 votes in the
[[counter]] array so that we never consider them again in our filters.

<<1.8 Election loop>>=
List<Integer> eliminated = result.get(min);
eliminated.forEach(x -> counter[x] = -1);
@

Now we need to remove the eliminated candidates from the ballots. However it
needs to be done carefully. We make note of who is currently the first in
the ballot. If after the elimination process the first in the rank has changed,
we need to take that into account. This is captured in the following chunk:

<<1.8 Election loop>>=
ballots.forEach(b -> {
    int first = b.peek();
    eliminated.forEach(x -> b.remove(x));
    counter[b.peek()] += (first != b.peek()) ? 1 : 0;
});
@

\section{Data Structures}

\subsection{Jolly Jumpers}

\MyHdr{10038}{A}{average}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/100/10038.pdf}

This task must be a joke.

<<Jolly Jumpers>>=
import static java.lang.Math.abs;
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.range;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;

class JollyJumpers {
    private static final BufferedReader reader = 
        new BufferedReader(new InputStreamReader(System.in));

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            List<Integer> nums = stream(currentLine.trim().split(" ")).filter(x -> !x.equals(""))
                .skip(1).map(Integer::parseInt).collect(toList());
            int[] diffs = range(0, nums.size() - 1)
                .map(i -> abs(nums.get(i) - nums.get(i + 1))).distinct().sorted().toArray();
            boolean isJolly = range(0, diffs.length).boxed()
                .map(i -> diffs[i] == i + 1).reduce(true, (x, y) -> x && y);
            System.out.println(diffs.length == nums.size() - 1 && isJolly ? "Jolly" : "Not jolly");
        }
    }
}
@

\subsection{Poker Hands}

\MyHdr{10315}{C}{average}{2}{$\bigstar$}{https://uva.onlinejudge.org/external/103/10315.pdf}

The task isn't particularly difficult in any way, but requires some lengthy
coding. Anyway, here's the whole program without comments as the code is 
self-explanatory.

<<Poker Hands>>=
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PokerHands {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static class Card {
        final int value;
        final int suit;
        private final static Map<Character, Integer> map = initialize();

        private static Map<Character, Integer> initialize() {
            Map<Character, Integer> map = new HashMap<Character, Integer>();
            for (char c = '2'; c <= '9'; ++c) {
                map.put(c, c - '0');
            }
            map.put('T', 10);
            map.put('J', 11);
            map.put('Q', 12);
            map.put('K', 13);
            map.put('A', 14);
            map.put('C', 1);
            map.put('D', 2);
            map.put('H', 3);
            map.put('S', 4);
            return map;
        }

        public Card(char value, char suit) {
            this.value = map.get(value);
            this.suit = map.get(suit);
        }
    }

    private static class Hand {
        private List<Card> hand;
        private int category = 0;
        private int rank = 0;

        public Hand(List<Card> hand) {
            this.hand = hand;
            Collections.sort(hand, (x, y) -> Integer.compare(x.value, y.value));
            straightFlush();
            fourOfAKind();
            fullHouse();
            flush();
            straight();
            threeOfAKind();
            twoPairs();
            pair();
            highCard();
        }

        private void highCard() {
            if (category != 0) {
                return;
            }

            category = 1;
            for (int i = hand.size() - 1; i >= 0; --i) {
                rank = (rank * 100) + hand.get(i).value;
            }
        }

        private void pair() {
            if (category != 0) {
                return;
            }

            Map<Integer, Integer> count = groups();
            List<Integer> pairs = new ArrayList<Integer>();
            for (Integer c : count.keySet()) {
                if (count.get(c) == 2) {
                    pairs.add(c);
                }
            }

            if (pairs.size() == 1) {
                category = 2;
                rank = pairs.get(0);
                for (int i = hand.size() - 1; i >= 0; --i) {
                    if (hand.get(i).value != pairs.get(0)) {
                        rank = (rank * 100) + hand.get(i).value;
                    }
                }
            }
        }

        private void twoPairs() {
            if (category != 0) {
                return;
            }

            Map<Integer, Integer> count = groups();
            List<Integer> pairs = new ArrayList<Integer>();
            int singleton = 0;
            for (Integer c : count.keySet()) {
                if (count.get(c) == 2) {
                    pairs.add(c);
                } else if (count.get(c) == 1) {
                    singleton = c;
                }
            }

            if (pairs.size() == 2) {
                category = 3;
                Collections.sort(pairs);
                for (int i = pairs.size() - 1; i >= 0; --i) {
                    rank = (rank * 100) + pairs.get(i);
                }
                rank = (rank * 100) + singleton;
            }
        }

        private void threeOfAKind() {
            if (category != 0) {
                return;
            }

            Map<Integer, Integer> count = groups();
            for (Integer c : count.keySet()) {
                if (count.get(c) == 3) {
                    category = 4;
                    rank = c;
                    for (int i = hand.size() - 1; i >= 0; --i) {
                        if (hand.get(i).value != c) {
                            rank = (rank * 100) + hand.get(i).value;
                        }
                    }
                    return;
                }
            }
        }

        private void straight() {
            if (category != 0) {
                return;
            }
            int value = hand.get(0).value;
            for (int i = 1; i < hand.size(); ++i) {
                if (hand.get(i).value - value == 1) {
                    value = hand.get(i).value;
                    continue;
                } else {
                    return;
                }
            }
            category = 5;
            rank = hand.get(hand.size() - 1).value;
        }

        private void flush() {
            if (category != 0) {
                return;
            }

            int suit = hand.get(0).suit;
            for (int i = 1; i < hand.size(); ++i) {
                if (hand.get(i).suit == suit) {
                    continue;
                } else {
                    return;
                }
            }

            category = 6;
            for (int i = hand.size() - 1; i >= 0; --i) {
                rank = (rank * 100) + hand.get(i).value;
            }
        }

        private void fourOfAKind() {
            fourOfAKindFullHouse(4, 8);
        }

        private void fullHouse() {
            fourOfAKindFullHouse(3, 7);
        }

        private void fourOfAKindFullHouse(int n, int cat) {
            if (category != 0) {
                return;
            }

            Map<Integer, Integer> count = groups();
            if (count.size() != 2) {
                return;
            }

            List<Integer> keys = new ArrayList<>(count.keySet());
            if (count.get(keys.get(0)) == n) {
                category = cat;
                rank = keys.get(0);
            } else if (count.get(keys.get(1)) == n) {
                category = cat;
                rank = keys.get(1);
            }
        }

        private void straightFlush() {
            if (category != 0) {
                return;
            }

            int suit = hand.get(0).suit;
            int value = hand.get(0).value;
            for (int i = 1; i < hand.size(); ++i) {
                if (hand.get(i).suit == suit &&
                        hand.get(i).value - value == 1) {
                    value = hand.get(i).value;
                    continue;
                } else {
                    return;
                }
            }

            category = 9;
            rank = hand.get(hand.size() - 1).value;
        }

        private Map<Integer, Integer> groups() {
            Map<Integer, Integer> count = new HashMap<Integer, Integer>();
            for (Card c : hand) {
                count.putIfAbsent(c.value, 0);
                count.put(c.value, count.get(c.value) + 1);
            }
            return count;
        }

    }

    private static int compare(Hand black, Hand white) {
        int compareCategory = Integer.compare(black.category, white.category);
        if (compareCategory == 0) {
            return Integer.compare(black.rank, white.rank);
        }
        return compareCategory;
    }

    private static int compare(String currentLine) {
        List<String> hands = Arrays.stream(currentLine.split(" "))
                .filter(x -> !x.equals("")).collect(toList());
        return compare(getHand(hands.subList(0, 5)),
                getHand(hands.subList(5, 10)));
    }

    private static Hand getHand(List<String> h) {
        return new Hand(h.stream().map(x -> new Card(x.charAt(0), x.charAt(1)))
                .collect(toList()));
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            int cmp = compare(currentLine);
            if (cmp == 0) {
                System.out.println("Tie.");
            } else {
                System.out.println(cmp > 0 ? "Black wins." : "White wins.");
            }
        }
    }

}

@

\subsection{Hartals}

\MyHdr{10050}{B}{high}{2}{$\bigstar$}{https://uva.onlinejudge.org/external/100/10050.pdf}

It seems that for this tasks you'd need to use GCDs and LCMs to figure out the 
overlapping days etc. But in reality this is not needed. If you look at the
input numbers you'll notice that they are very small, so a simulation on top of
a bitmap will be just fine. This results in a much shorter and less
complicated code.

<<Hartals>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.BitSet;

public class Hartals {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static void set(int n, BitSet res, int s, int l, boolean v) {
        while (s <= n) {
            res.set(s, v);
            s += l;
        }
    }

    private static int solve(int n, int[] h) {
        BitSet res = new BitSet(n + 1);
        for (int i = 0; i < h.length; ++i) {
            set(n, res, h[i], h[i], true);
        }
        set(n, res, 6, 7, false);
        set(n, res, 7, 7, false);
        int count = 0;
        for (int i = 0; i < res.size(); ++i) {
            count += res.get(i) ? 1 : 0;
        }
        return count;
    }

    public static void main(String[] args) throws IOException {
        int cases = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < cases; ++i) {
            int n = Integer.parseInt(reader.readLine().trim());
            int p = Integer.parseInt(reader.readLine().trim());
            int[] h = new int[p];
            for (int j = 0; j < p; ++j) {
                h[j] = Integer.parseInt(reader.readLine().trim());
            }
            System.out.println(solve(n, h));
        }
    }

}
@

\subsection{Crypt Kicker}

\MyHdr{843}{B}{low}{2}{$\bigstar$$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/8/843.pdf}

This task is a lot of fun! To solve it we are going to need a very good
bookkeeping discipline.

Let's outline the general strategy. First thing to do is to to group the words
by length. Then we need to come up with a method to compare a dictionary word
and an encrypted word by looking at their patterns. So we somehow need to tell
if the words "abbc" has a similar pattern as "xyyz". But this is very easy: we
scan a word from left to right and output an index of the first occurrence of
the character, or current index if it's the first occurrence. So for example
"abbc" and "xyyz" would both have a pattern 1 2 2 3. Using a pattern and the
word length we can find words from the dictionary that could be the potential
matches for an encrypted word. 

We start with the longest word (if multiple words of the same length, then any
words of such length) and we find all the words from the dictionary that have the
same length, the same pattern, and agree with the mapping found so far. By the
mapping found so far we mean the following: if some previous word has been
matched with a candidate, we note the mapping. So if we matched "abbc" with
"xyyz" we now know that a maps to x, b maps to y, and c maps to z. This means
that if we are now trying to match another word, say "zy", we can eliminate
candidates such as "bc", because we now assume that z maps to c, not b. Once we
filtered all the potential candidates we try to match the first candidate from
the list and move on to the next word. If at any step we fail to find any
candidate word, we return one step back, and try another word in the list, if
the list is exhausted, we move one step back again. If we exhausted all the
lists, then the decryption is impossible. For simplicity of implementation we
will implement it as a recursion.

OK, now we just need to write code.

First input/output. The main class will be initialized by a dictionary and will
have just one method [[decrypt]] that will take a string and return either a
decrypted text or stars, as per problem statement.

<<Crypt Kicker>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

<<2.4 Imports>>

class CryptKicker {
    private static final BufferedReader reader = 
        new BufferedReader(new InputStreamReader(System.in));

    <<2.4 Variables>>

    <<2.4 Constructor>>

    <<2.4 Methods>>

    public static void main(String[] args) throws IOException {
        String currentLine;
        final int size = Integer.parseInt(reader.readLine().trim());
        final List<String> dictionary = reader.lines().limit(size).collect(toList());
        CryptKicker cryptKicker = new CryptKicker(dictionary);
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().equals("")) {
            System.out.println(cryptKicker.decrypt(currentLine));
        }
    }
}
@

Let's write the method that gives us the pattern of a given word. This method
does exactly the thing we've described above.

<<2.4 Imports>>=
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.range;
@

<<2.4 Methods>>=
private static List<Integer> getPattern(String word) {
    return range(0, word.length()).map(i -> word.indexOf(word.charAt(i)))
        .boxed().collect(toList());
}

@

And let's add a helper method that for a given list of words gives a map. (Note
that we take distinct words as the words in the input dictionary aren't
necessarily unique.)

<<2.4 Imports>>=
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.toMap;
import java.util.List;
import java.util.Map;
import java.util.Deque;
@

<<2.4 Methods>>=
private static Map<String, List<Integer>> getPatterns(Deque<String> words) {
    return words.stream().distinct().collect(
        toMap(identity(), CryptKicker::getPattern));
}

@

Now we can do the constructor. In the constructor we will group the words by
length and get their patterns.

<<2.4 Imports>>=
import static java.util.stream.Collectors.groupingBy;
import java.util.ArrayDeque;
@

<<2.4 Variables>>=
private final Map<Integer, List<String>> dictionary;
private final Map<String, List<Integer>> patterns;
@

<<2.4 Constructor>>=
public CryptKicker(List<String> inputDictionary) {
    dictionary = inputDictionary.stream()
        .collect(groupingBy(String::length));
    patterns = getPatterns(new ArrayDeque<>(inputDictionary));
}

@

We will also need a function to compare two given patterns. This is easy:

<<2.4 Imports>>=
import static java.lang.Math.abs;
@

<<2.4 Methods>>=
private static boolean compare(List<Integer> a, List<Integer> b) {
    return a.size() == b.size() && 
        range(0, a.size()).map(i -> abs(a.get(i) - b.get(i))).sum() == 0;
}

@

Let's sort out the variables that we are going to need. We will need a map that
will hold patterns of the encrypted words for the given input string.

<<2.4 Variables>>=
private Map<String, List<Integer>> encryptedPatterns;
@

This variable could have been passed around via argument to the methods,
because this variable's contents depend on each encrypted input line. But I have
chosen to just have this as a private member.

We will also need to keep track of the words that have been mapped.

<<2.4 Imports>>=
import java.util.HashSet;
import java.util.Set;
@

<<2.4 Variables>>=
private final Set<String> mappedWords = new HashSet<>();
@

And we will need the mappings themselves. We will keep both the direct mapping
and the reversed mappings in the arrays, where an index is the ASCII character
code and the value is another ASCII character code. Because ASCII characters
for the lower case letters go from 97 to 122 it should be enough to just create
an array of no more than 128 bytes. We could have created a smaller array, but
in that case we would need to adjust the indexes which would clutter the code
unnecessarily. 

The [[counter]] array will keep track of how many words have used this
character mapping so far. This is needed because we will be mapping and
unmapping the words multiple times during the search. An empty array will
denote unsuccessful mapping.

<<2.4 Variables>>=
private static final int MAX_SIZE = 128;
private static final int[] NOT_FOUND = new int[0];
private final int[] dirMapping = new int[MAX_SIZE];
private final int[] revMapping = new int[MAX_SIZE];
private final int[] counter = new int[MAX_SIZE];
@

Let's implement [[mapWord]] and [[unmapWord]] methods. Note that they keep
track (with help of [[counter]]) of how many words have used a specific
character mapping.

<<2.4 Methods>>=
private void mapWord(String e, String c) {
    mappedWords.add(c);
    for (int i = 0; i < e.length(); ++i) {
        dirMapping[e.charAt(i)] = c.charAt(i);
        counter[e.charAt(i)]++;
        revMapping[c.charAt(i)] = e.charAt(i);
    }
}

private void unmapWord(String e, String c) {
    mappedWords.remove(c);
    for (int i = 0; i < e.length(); ++i) {
        counter[e.charAt(i)]--;
        if (counter[e.charAt(i)] == 0) {
            revMapping[dirMapping[e.charAt(i)]] = 0;
            dirMapping[e.charAt(i)] = 0;
        }
    }
}

@

We need to keep track of these mapping and [[counter]] because of the
filtering. For example, if we mapped the word "abc" to "xyz" and the word "ab"
to "xy", we now know that a maps to x, b maps to y, and c maps to z. So we can
find that the word's "ab" mapping to "xy" is a valid mapping and so we can map
that too. If for some reason we unmap the word "abc", our mapping arrays should
still keep the mapping of a to x, and b to y, because we haven't unmapped the
word "ab".

Now let's implement the filtering. This function take an encrypted word and
does the following filtering. First, it gets all the words from the dictionary
of the same length. Then it filters out the words that have been mapped already
and the words that don't have the same pattern. Next, it checks if this word
agrees with the mapping (may be partial) of the mappings found so far. If the
word passes all this filtering, it is add to the list, which then returned as
the result.

<<2.4 Imports>>=
import java.util.ArrayList;
@

<<2.4 Methods>>=
private List<String> filter(String encrypted) {
    List<String> matchedWords = new ArrayList<String>();
    for (String word : dictionary.get(encrypted.length())) {
        if (mappedWords.contains(word) || 
            !compare(encryptedPatterns.get(encrypted), patterns.get(word))) {
            continue;
        }

        boolean matched = true;
        for (int i = 0; i < word.length() && matched; ++i) {
            boolean unmapped = dirMapping[encrypted.charAt(i)] == 0;
            boolean mapped = dirMapping[encrypted.charAt(i)] == word.charAt(i);
            boolean unused = revMapping[word.charAt(i)] == 0;
            matched = (unmapped && unused) || mapped;
        }
        if (matched) {
            matchedWords.add(word);
        }
    }
    return matchedWords;
}

@

We can now implement the recursive search method. It takes a deque of
encrypted words and then tries to map them to the dictionary. (A deque because
it has convenient methods such as [[pop]] and [[push]].) This method assumes
that the words in the deque are sorted by length in descending order.

<<2.4 Methods>>=
private boolean map(Deque<String> encryptedWords) {
    if (encryptedWords.isEmpty()) {
        return true;
    }
    String encryptedWord = encryptedWords.pop();
    List<String> words = filter(encryptedWord);
    for (String candidate : words) {
        mapWord(encryptedWord, candidate);
        if (map(encryptedWords)) {
            return true;
        }
        unmapWord(encryptedWord, candidate);
    }
    encryptedWords.push(encryptedWord);
    return false;
}

@

Let's add another helper method that will do the clearing up and initialization
of the data structures:

<<2.4 Imports>>=
import java.util.Arrays;
@

<<2.4 Methods>>=
private int[] findMapping(Deque<String> encryptedWords) {
    encryptedPatterns = getPatterns(encryptedWords);
    mappedWords.clear();
    Arrays.fill(dirMapping, 0);
    Arrays.fill(revMapping, 0);
    Arrays.fill(counter, 0);
    return map(encryptedWords) ? dirMapping : NOT_FOUND;
}

@

Finally, we can now implement [[decrypt]] method:

<<2.4 Imports>>=
import static java.util.Comparator.comparing;
@

<<2.4 Methods>>=
public String decrypt(String input) {
    StringBuilder result = new StringBuilder();
    int[] mapping = findMapping(
            new ArrayDeque<>(Arrays.stream(input.trim().split(" "))
                .filter(x -> !x.equals("")).distinct()
                .sorted(comparing(String::length).reversed()).collect(toList())));
    input.chars().map(c -> c != ' ' ? (mapping != NOT_FOUND ? mapping[c] : '*') : c)
        .forEachOrdered(x -> result.append((char) x));
    return result.toString();
}

@

\subsection{Stack 'em Up}

\MyHdr{10205}{B}{average}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/102/10205.pdf}

Easy.

<<Stack em Up>>=


import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

public class StackEmUp {
    private static final int DECK_SIZE = 52;

    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static final Map<Integer, String> map = initialize();

    private static Map<Integer, String> initialize() {
        Map<Integer, String> map = new HashMap<>();
        int k = 0;
        for (String suit : Stream.of("Clubs", "Diamonds", "Hearts", "Spades")
                .collect(toList())) {
            for (int i = 2; i <= 10; ++i) {
                map.put(Integer.valueOf(k++), i + " of " + suit);
            }
            map.put(Integer.valueOf(k++), "Jack of " + suit);
            map.put(Integer.valueOf(k++), "Queen of " + suit);
            map.put(Integer.valueOf(k++), "King of " + suit);
            map.put(Integer.valueOf(k++), "Ace of " + suit);
        }
        return map;
    }

    private static List<Integer> newDeck() {
        return Stream.iterate(0, i -> i + 1).limit(DECK_SIZE)
                .collect(toList());
    }

    private static List<Integer> apply(List<Integer> deck,
            List<Integer> shuffle) {
        List<Integer> output = newDeck();
        for (int j = 0; j < shuffle.size(); ++j) {
            output.set(j, deck.get(shuffle.get(j)));
        }
        return output;
    }

    private static List<Integer> shuffle(List<Integer> shuffleIndexes,
            List<List<Integer>> shuffles) {
        List<Integer> deck = newDeck();
        for (Integer i : shuffleIndexes) {
            deck = apply(deck, shuffles.get(i));
        }
        return deck;
    }

    public static void main(String[] args) throws IOException {
        int cases = Integer.parseInt(reader.readLine().trim());
        reader.readLine();
        for (int i = 0; i < cases; ++i) {
            int n = Integer.parseInt(reader.readLine().trim());
            List<Integer> shuffles = new ArrayList<>();
            String currentLine;
            while (shuffles.size() < n * DECK_SIZE) {
                currentLine = reader.readLine().trim();
                shuffles.addAll(stream(currentLine.split(" "))
                        .filter(x -> !x.equals(""))
                        .map(Integer::parseInt)
                        .map(x -> x - 1)
                        .collect(toList()));
            }
            List<List<Integer>> shuffleList = new ArrayList<List<Integer>>();
            for (int j = 0; j < n; ++j) {
                shuffleList.add(shuffles.subList(j * DECK_SIZE,
                        j * DECK_SIZE + DECK_SIZE));
            }
            List<Integer> shuffleIndexes = new ArrayList<>();
            while ((currentLine = reader.readLine()) != null &&
                    !currentLine.trim().equalsIgnoreCase("")) {
                shuffleIndexes.add(Integer.parseInt(currentLine.trim()) - 1);
            }
            shuffle(shuffleIndexes, shuffleList)
                    .forEach(x -> System.out.println(map.get(x)));
            if (i < cases - 1) {
                System.out.println();
            }
        }

    }

}
@

\subsection{Erd\"os Numbers}

\MyHdr{10044}{B}{low}{2}{$\bigstar$}{https://uva.onlinejudge.org/external/100/10044.pdf}

To solve this task one just needs to apply breadth-first search algorithm.
Very straightforward.

<<Erdos Numbers>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ErdosNumbers {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    private static final Pattern namePattern = Pattern
            .compile("[\\w^.,]+\\s*,\\s*(\\w\\.)+\\s*[,:]");

    private static final String ERDOS = "Erdos, P.";

    private static void add(Map<String, Set<String>> graph,
            List<String> names) {
        for (int i = 0; i < names.size(); ++i) {
            String currName = names.get(i);
            if (!graph.containsKey(names.get(i))) {
                graph.put(currName, new HashSet<String>());
            }
            names.forEach(name -> {
                if (!currName.equalsIgnoreCase(name)) {
                    graph.get(currName).add(name);
                }
            });
        }
    }

    private static List<String> getNames(String input) {
        List<String> names = new ArrayList<>();
        Matcher m = namePattern.matcher(input);
        while (m.find()) {
            names.add(input.substring(m.start(), m.end() - 1).trim());
        }
        return names;
    }

    private static Map<String, Integer> getAnswer(
            Map<String, Set<String>> graph) {
        Deque<String> q = new ArrayDeque<>();
        Set<String> s = new HashSet<String>();
        Map<String, Integer> r = new HashMap<>();
        q.push(ERDOS);
        r.put(ERDOS, Integer.valueOf(0));

        while (!q.isEmpty()) {
            String n = q.pop();
            int depth = r.get(n);
            for (String x : graph.get(n)) {
                if (!s.contains(x)) {
                    s.add(x);
                    q.addLast(x);
                    r.put(x, Integer.valueOf(depth + 1));
                }
            }
        }

        return r;
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            List<Integer> nm = stream(reader.readLine().trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            Map<String, Set<String>> graph = new HashMap<>();
            for (int j = 0; j < nm.get(0); ++j) {
                add(graph, getNames(reader.readLine().trim()));
            }
            Map<String, Integer> r = getAnswer(graph);
            System.out.println("Scenario " + (i + 1));
            for (int j = 0; j < nm.get(1); ++j) {
                String name = reader.readLine().trim();
                System.out.println(name + " " +
                        (r.containsKey(name) ? r.get(name) : "infinity"));
            }
        }
    }
}

@

\subsection{Contest Scoreboard}

\MyHdr{10258}{B}{average}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/102/10258.pdf}

With this task one must be careful not to add penalties to the tasks that some
teams attempted but never solved, that's the only tricky thing that might not
be obvious from the problem statement.

<<Contest Scoreboard>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class ContestScoreboard {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static class Team implements Comparable<Team> {
        private final int num;
        private int totalTime;
        private Set<Integer> solved = new HashSet<>();
        private final int[] penalties = new int[10];

        @Override
        public String toString() {
            return num + " " + solved.size() + " " + getTotalTime();
        }

        public Team(int num) {
            this.num = num;
        }

        public int getTotalTime() {
            int time = totalTime;
            for (Integer problemId : solved) {
                time += penalties[problemId];
            }
            return time;
        }

        public void update(Integer problem, Integer time, String verdict) {
            switch (verdict) {
            case "C":
                if (solved.add(problem)) {
                    totalTime += time;
                }
                break;
            case "I":
                if (!solved.contains(problem)) {
                    penalties[problem] += 20;
                }
                break;
            default:
                break;
            }
        }

        @Override
        public int compareTo(Team o) {
            int solvedCmp = Integer.compare(o.solved.size(),
                    this.solved.size());
            if (solvedCmp == 0) {
                int timeCmp = Integer.compare(getTotalTime(), o.getTotalTime());
                if (timeCmp == 0) {
                    return Integer.compare(this.num, o.num);
                }
                return timeCmp;
            }
            return solvedCmp;
        }
    }

    public static void main(String[] args) throws IOException {
        int cases = Integer.parseInt(reader.readLine().trim());
        reader.readLine();
        String currentLine = null;
        for (int i = 0; i < cases; ++i) {
            Map<Integer, Team> participants = new HashMap<>();
            while ((currentLine = reader.readLine()) != null &&
                    !currentLine.trim().equals("")) {
                List<String> inputLine = stream(currentLine.trim().split(" "))
                        .filter(x -> !x.equals(""))
                        .collect(toList());
                Integer num = Integer.parseInt(inputLine.get(0));
                Integer problem = Integer.parseInt(inputLine.get(1));
                Integer time = Integer.parseInt(inputLine.get(2));
                String verdict = inputLine.get(3);
                if (!participants.containsKey(num)) {
                    participants.put(num, new Team(num));
                }
                participants.get(num).update(problem, time, verdict);
            }
            participants.values().stream().sorted()
                    .forEach(System.out::println);
            if (i < cases - 1) {
                System.out.println();
            }
        }
    }
}

@

\subsection{Yahtzee}

\MyHdr{10149}{C}{average}{3}{$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/101/10149.pdf}

This task's solution is going to be a bit lengthy due to necessary coding. The
solution itself though is not so complicated. Notice that for the five of a
kind category, for example, we simply find the round that has the smallest sum
of all dice. In a similar way we should find rounds to fit into other three
categories: short straight, long straight, and full house. The rest of the
categories should be searched exhaustively.

As usual, let's sort out input/output first. Let's assume there's a constructor
for our [[Yahtzee]] class that takes as input a list of lists of integers.
These interes are going to be our 13 rounds as defined in the task's
description. [[getSolutionString]] method returns the answer in the format
required by the task. Note that dice will be sorted in ascending order. This
will be useful later on.

<<Yahtzee>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class Yahtzee {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    <<2.8 Constants>>

    <<2.8 Helpers>>

    <<2.8 Constructor>>

    <<2.8 Methods>>

    public static void main(String[] args) throws IOException {
        String currentLine = null;
        List<List<Integer>> input = new ArrayList<>();
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().equals("")) {
            List<Integer> inputLine = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals(""))
                    .map(Integer::parseInt).sorted()
                    .collect(toList());
            input.add(inputLine);
            if (input.size() == 13) {
                Yahtzee yahtzee = new Yahtzee(input);
                System.out.println(yahtzee.getSolutionString());
                input.clear();
            }
        }
    }
}
@

Since there are going to be 13 categories, it's convenient to reference them by
indexes in an array of 13 elements. Let's define some constants:

<<2.8 Constants>>=
private final static int fullhouse = 12;
private final static int longstraight = 11;
private final static int shortstraight = 10;
private final static int fiveofakind = 9;
private final static int fourofakind = 8;
private final static int threeofakind = 7;
private final static int chance = 6;

@

And let's define arrays that will hold the best solution and the sum and a
bonus of that solution:

<<2.8 Constants>>=
private final int[] bestSolutionResult = new int[2];
private final int[] bestSolution = new int[13];

@

Before doing any computations we need to categorize our input data. So let's
determine up front whether a given round belongs to a specific category or not.
To represent a round we are going to define a class [[Round]] that will hold
information about which categories this round can be used for and also the sum
of dice (or points) if this round is chosen to be used in a specific category.

So an instance of this class will have the dice values, the sum of these dice,
points depending on categories, and a set of categories this round belongs to.

<<2.8 Helpers>>=
public static class Round {
    private final List<Integer> dice;
    private final int allDiceSum;
    private final int[] points = new int[13];
    private final Set<Integer> category;

    <<2.8 Round Constructor>>

    <<2.8 Round Methods>>
}
@

The constructor assigns [[allDiceSum]] and [[dice]] and determines which
categories this round belongs to by filling out [[points]] and [[category]].

<<2.8 Round Constructor>>=
public Round(List<Integer> dice) {
    this.allDiceSum = dice.stream().reduce(0, Integer::sum);
    this.dice = dice;
    this.category = new HashSet<>();

    <<2.8 Categorize>>
}
@

To determine which categories this specific round belongs to we will need to
write some helper methods.

Let's start with the full house. It's pretty self-explanatory:

<<2.8 Round Methods>>=
private boolean isFullhouse() {
    boolean halfsDifferent = dice.get(0) != dice.get(4);
    boolean twoThree = dice.subList(0, 2).stream().distinct()
            .count() == 1 &&
            dice.subList(2, 5).stream().distinct().count() == 1;
    boolean threeTwo = dice.subList(0, 3).stream().distinct()
            .count() == 1 &&
            dice.subList(3, 5).stream().distinct().count() == 1;
    return halfsDifferent && (twoThree || threeTwo);
}

@

For the long straight and short straights we are going to need to determine the
longest sequence, so let's have a helper for that:

<<2.8 Round Methods>>=
private int getLongestSequence(List<Integer> list) {
    int longest = 1;
    int currLen = 1;
    for (int i = 0; i < list.size(); ++i) {
        if (i > 0 && list.get(i) - list.get(i - 1) == 1) {
            currLen += 1;
        } else if (i > 0 && list.get(i) == list.get(i - 1)) {
            continue;
        } else {
            longest = Math.max(currLen, longest);
            currLen = 1;
        }
    }
    return Math.max(currLen, longest);
}

@

Now we can write our long and short straights:

<<2.8 Round Methods>>=
private boolean isLongStraight() {
    return getLongestSequence(dice) >= 5;
}

private boolean isShortStraight() {
    return getLongestSequence(dice) >= 4;
}

@

Five, four and three of a kind are simple too:

<<2.8 Round Methods>>=
private boolean isFiveOfAKind() {
    return (dice.stream().distinct().count() == 1);
}

private boolean isFourOfAKind() {
    List<Integer> v1 = dice.subList(0, 4);
    List<Integer> v2 = dice.subList(1, 5);
    return (v1.stream().distinct().count() == 1 ||
            v2.stream().distinct().count() == 1);
}

private boolean isThreeOfAKind() {
    List<Integer> v1 = dice.subList(0, 3);
    List<Integer> v2 = dice.subList(1, 4);
    List<Integer> v3 = dice.subList(2, 5);
    return (v1.stream().distinct().count() == 1 ||
            v2.stream().distinct().count() == 1 ||
            v3.stream().distinct().count() == 1);
}
@

OK, now we can assign some points depending on whether this round belong to a category or not:

<<2.8 Categorize>>=
if (isFullhouse()) {
    category.add(fullhouse);
    points[fullhouse] = 40;
}
if (isLongStraight()) {
    category.add(longstraight);
    points[longstraight] = 35;
}
if (isShortStraight()) {
    category.add(shortstraight);
    points[shortstraight] = 25;
}
if (isFiveOfAKind()) {
    category.add(fiveofakind);
    points[fiveofakind] = 50;
}
if (isFourOfAKind()) {
    category.add(fourofakind);
    points[fourofakind] = allDiceSum;
}
if (isThreeOfAKind()) {
    category.add(threeofakind);
    points[threeofakind] = allDiceSum;
}

@

Every round can be used in the chance category:

<<2.8 Categorize>>=
category.add(chance);
points[chance] = allDiceSum;

@

First six categories can be determined by simple check if the dice have a
specific value (1 to 6) or not. Points are assinged accordingly.

<<2.8 Categorize>>=
for (int i = 0; i < 6; ++i) {
    final int v = i + 1;
    if (dice.contains(Integer.valueOf(v))) {
        category.add(i);
        points[i] = (int) (dice.stream().filter(x -> x == v)
                .count() * v);
    }
}
@

An important method that we should implement too is [[equals]], let's do that:

<<2.8 Round Methods>>=
@Override
public boolean equals(Object obj) {
    return dice.equals(((Round) obj).dice);
}
@

That's it for the [[Round]] class. 

Now let's implement [[Yahtzee]] constructor. Let's assume it calls [[solve]]
method with a list of [[Round]]s:

<<2.8 Constructor>>=
Yahtzee(List<List<Integer>> input) {
    solve(input.stream().map(x -> new Round(x)).collect(toList()));
}

@

Now let's write [[solve]]. First we create an array [[candidateSolution]] that
will hold points for the categories and we try to fit in the last four
categories by finding rounds with the smallest sums of the dice:

<<2.8 Methods>>=
private void solve(List<Round> input) {
    int[] candidateSolution = new int[13];
    for (int category = 12; category > 8; --category) {
        Round dice = filter(category, input).stream()
                .min((x, y) -> Integer.compare(x.allDiceSum, y.allDiceSum))
                .orElse(null);
        if (dice != null) {
            input.remove(dice);
            candidateSolution[category] = dice.points[category];
        }
    }
    search(8, input, candidateSolution);
}

@

The [[filter]] method is quite straightforward:

<<2.8 Methods>>=
private static List<Round> filter(final int category, List<Round> input) {
    List<Round> res = new ArrayList<>();
    Integer categoryInteger = Integer.valueOf(category);
    for (Round d : input) {
        if (d.category.contains(categoryInteger)) {
            res.add(d);
        }
    }
    return res;
}

@

Let's add one more method that we will need, the method that calculates the sum
of all points. It'll return an array where the first element is the bonus (if
present) and the second element is the total sum (including the bonus):

<<2.8 Methods>>=
private static int[] total(int[] solution) {
    int[] res = new int[2];
    int sixSum = 0;
    for (int i = 0; i < solution.length; ++i) {
        if (i < 6) {
            sixSum += solution[i];
        }
        res[1] += solution[i];
    }
    if (sixSum >= 63) {
        res[1] += 35;
        res[0] = 35;
    }
    return res;
}

@

OK, now let's get to the [[search]] method. This method is going to be a
classic backtracking method.

The first parameter is the position in the array of categories that we are
trying. We will work out our way in a methodic way down to the first category.
Once we reach that we check what result this categorization gives us, and if
it's better than the one we've found so far, we update our found solution to
the better one. The second argument is a candidate solution.

So first thing we do in this method is to check if [[pos]] is -1, which means
we have a candidate categorization in the [[solution]], and we check if it's any
better than the one we've found so far. Otherwise we get all the candidate
rounds for the given category and start trying them one by one while recursively
calling the [[search]] method. 

<<2.8 Methods>>=
private void search(int pos, List<Round> input, int[] solution) {
    if (pos == -1) {
        int[] solutionResult = total(solution);
        if (bestSolutionResult[1] < solutionResult[1]) {
            System.arraycopy(solution, 0, bestSolution, 0,
                    solution.length);
            System.arraycopy(solutionResult, 0, bestSolutionResult, 0,
                    solutionResult.length);
        }
        return;
    }

    List<Round> candidates = filter(pos, input);
    Set<Round> checked = new HashSet<Round>();
    for (Round round : candidates) {
        if (checked.contains(round)) {
            continue;
        }
        solution[pos] = round.points[pos];
        input.remove(round);
        search(pos - 1, input, solution);
        solution[pos] = 0;
        input.add(round);
        checked.add(round);
    }
    if (pos >= 7 || candidates.size() == 0) {
        solution[pos] = 0;
        search(pos - 1, input, solution);
    }
}

@

Finally, all we need to do now is to output the result:

<<2.8 Methods>>=
private String getSolutionString() {
    return Arrays.stream(getSolution()).mapToObj(String::valueOf)
            .collect(Collectors.joining(" "));
}

public int[] getSolution() {
    int[] solution = new int[bestSolution.length +
            bestSolutionResult.length];
    System.arraycopy(bestSolution, 0, solution, 0, bestSolution.length);
    System.arraycopy(bestSolutionResult, 0, solution,
            bestSolution.length,
            bestSolutionResult.length);
    return solution;
}
@

This concludes this program.

\section{Strings}

\subsection{WERTYU}

\MyHdr{10082}{A}{high}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/100/10082.pdf}

Trivial.

<<WERTYU>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class WERTYU {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private final static String KEYS = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./";
    private final static int[] map = new int[256];

    static {
        for (int i = 0; i < KEYS.length(); ++i) {
            map[KEYS.charAt(i)] = i;
        }
    }

    private static String shift(String currentLine) {
        StringBuilder output = new StringBuilder();
        for (int i = 0; i < currentLine.length(); ++i) {
            output.append(map[currentLine.charAt(i)] != 0
                    ? KEYS.charAt(map[currentLine.charAt(i)] - 1)
                    : currentLine.charAt(i));
        }
        return output.toString();
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            System.out.println(shift(currentLine));
        }
    }

}
@

\subsection{Where's Waldorf}

\MyHdr{10010}{B}{average}{2}{$\bigstar$}{https://uva.onlinejudge.org/external/100/10010.pdf}

Trivial.

<<Where is Waldorf>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class WheresWaldorf {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private final int n;
    private final int m;
    private final char[][] table;

    public WheresWaldorf(int n, int m, char[][] table) {
        this.n = n;
        this.m = m;
        this.table = table;
    }

    private static final int[][] dir = new int[][] {
            { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 }, { 1, 1 }, { -1, -1 },
            { -1, 1 }, { 1, -1 }
    };

    public int[] find(String word) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                for (int k = 0; k < dir.length; ++k) {
                    if (check(dir[k][0], dir[k][1], i, j, word)) {
                        return new int[] { i + 1, j + 1 };
                    }
                }
            }
        }
        return null;
    }

    private boolean check(int di, int dj, int i, int j, String word) {
        if (word.length() == 1) {
            return table[i][j] == word.charAt(0);
        }
        int pos = 0;
        while (i >= 0 && i < n && j >= 0 && j < m && pos < word.length() &&
                table[i][j] == word.charAt(pos)) {
            j += dj;
            i += di;
            pos++;
        }
        return pos == word.length();
    }

    private static String toString(int[] arr) {
        return Arrays.stream(arr).mapToObj(String::valueOf)
                .collect(Collectors.joining(" "));
    }

    public static void main(String[] args) throws IOException {
        int cases = Integer.parseInt(reader.readLine().trim());
        reader.readLine();
        for (int k = 0; k < cases; ++k) {
            List<Integer> nm = stream(reader.readLine().trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            char[][] table = new char[nm.get(0)][nm.get(1)];
            for (int i = 0; i < nm.get(0); ++i) {
                String currentLine = reader.readLine();
                for (int j = 0; j < nm.get(1); ++j) {
                    table[i][j] = currentLine.toLowerCase().charAt(j);
                }
            }
            int wordsCount = Integer.parseInt(reader.readLine().trim());
            List<String> words = new ArrayList<>();
            for (int i = 0; i < wordsCount; ++i) {
                String currentLine = reader.readLine().toLowerCase();
                words.add(currentLine);
            }
            WheresWaldorf ww = new WheresWaldorf(nm.get(0), nm.get(1), table);
            words.forEach(x -> System.out.println(toString(ww.find(x))));
            if (k < cases - 1) {
                System.out.println();
                reader.readLine();
            }
        }
    }
}
@

\subsection{Common Permutation}

\MyHdr{10252}{A}{average}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/102/10252.pdf}

This task is quite simple. First, we sort the input line characters in
ascending order. Then, for each character in the input lines we compute its
run. A run is a string of consecutive characters that are the same, for example
"aaa" is a run of length 3. Next, we take an intersection of distinct characters
between both lines, and start compiling the longest string by simple checking
character by character while taking into account their runs: We just take the
smallest run out of two on each step.

<<Common Permutation>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;

public class CommonPermutation {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static int[] runs(int[] arr) {
        int[] runs = new int[256];
        for (int i = 0; i < arr.length; ++i) {
            runs[arr[i]] += 1;
        }
        return runs;
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            int[] line1 = currentLine.trim().chars().sorted().toArray();
            int[] line2 = reader.readLine().chars().sorted().toArray();
            int[] run1 = runs(line1);
            int[] run2 = runs(line2);
            List<Integer> distinct = stream(line1).distinct().boxed()
                    .collect(toList());
            distinct.retainAll(stream(line2).distinct().boxed()
                    .collect(toList()));

            StringBuilder longest = new StringBuilder();
            for (int i = 0; i < distinct.size(); ++i) {
                int len = Math.min(run1[distinct.get(i)],
                        run2[distinct.get(i)]);
                for (int j = 0; j < len; ++j) {
                    longest.append((char) distinct.get(i).intValue());
                }
            }
            System.out.println(longest);
        }
    }
}
@

\subsection{Crypt Kicker II}

\MyHdr{850}{A}{average}{2}{$\bigstar$}{https://uva.onlinejudge.org/external/8/850.pdf}

This task is much easier than Crypt Kicker. Here we have a very well known
pangram ``the quick brown fox jumps over the lazy dog.'' A pangram is a sentence
that uses every letter of the alphabet at least once. So all we need to do is
to locate the pangram in the input lines. We will use exactly the same technique
as we used while solving the original Crypt Kicker problem.

<<Crypt Kicker II>>=
import static java.lang.Math.abs;
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.range;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class CryptKickerII {
    private static final BufferedReader reader = 
        new BufferedReader(new InputStreamReader(System.in));
    private final int[] mapping = new int[128];
    private static final String pangram = "the quick brown fox jumps over the lazy dog";
    private static final String pangramSpaces = pangram.replaceAll("[^ ]", ".");
    private static final List<Integer> pangramPattern = getPattern(pangram);

    private static List<Integer> getPattern(String word) {
        return range(0, word.length()).map(i -> word.indexOf(word.charAt(i)))
                .boxed().collect(toList());
    }

    private static boolean compare(List<Integer> a, List<Integer> b) {
        return a.size() == b.size() && range(0, a.size())
                .map(i -> abs(a.get(i) - b.get(i))).sum() == 0;
    }

    private boolean isPangram(String input) {
        String line = String.join(" ", Arrays.stream(input.trim()
                .split(" ")).filter(x -> !x.equals("")).collect(toList()));
        return compare(pangramPattern, getPattern(line.toString())) &&
                line.replaceAll("[^ ]", ".").equalsIgnoreCase(pangramSpaces);
    }

    public List<String> decrypt(List<String> input) {
        Arrays.fill(mapping, 0);
        List<String> output = new ArrayList<String>();
        String encryptedPangram = input.stream()
                .filter(x -> isPangram(x)).findFirst().orElse("");
        if (encryptedPangram.equalsIgnoreCase("")) {
            output.add("No solution.");
            return output;
        }

        for (int i = 0; i < encryptedPangram.length(); ++i) {
            mapping[encryptedPangram.charAt(i)] = pangram.charAt(i);
        }

        return input.stream().map(x -> {
            StringBuilder result = new StringBuilder();
            x.chars().map(c -> c != ' ' ? mapping[c] : c)
                    .forEachOrdered(c -> result.append((char) c));
            return result.toString();
        }).collect(toList());
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        final int n = Integer.parseInt(reader.readLine().trim());
        reader.readLine();
        CryptKickerII cryptKicker = new CryptKickerII();
        for (int i = 0; i < n; ++i) {
            List<String> input = new ArrayList<String>();
            while ((currentLine = reader.readLine()) != null &&
                    !currentLine.trim().equalsIgnoreCase("")) {
                input.add(currentLine);
            }
            cryptKicker.decrypt(input).forEach(System.out::println);
            if (i < n - 1) {
                System.out.println();
            }
        }
    }
}
@

\subsection{Automated Judge Script}

\MyHdr{10188}{B}{average}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/101/10188.pdf}

This task looks so trivial, but it took me a few attempts before the online
judge accepted it. The reason was that it was wrong to use the [[readLine()]]
method, because it strips characters; the contract says that ``line is
considered to be terminated by any one of a line feed ('\textbackslash n'), a
carriage return ('\textbackslash r'), or a carriage return followed immediately
by a line feed.'' So the input, when read by [[readLine()]], would apparently
miss some characters. Other than this caveat, the task is trivial.

<<Automated Judge Script>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class AutomatedJudgeScript {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static String read(int n) throws IOException {
        StringBuilder input = new StringBuilder();
        int newlines = 0;
        while (newlines < n) {
            int c = reader.read();
            if (c == '\n') {
                newlines++;
            }
            input.append((char) c);
        }
        return input.toString();
    }

    public static void main(String[] args) throws IOException {
        int i = 0;
        while (true) {
            int n = Integer.parseInt(reader.readLine().trim());
            if (n == 0) {
                break;
            }
            String src = read(n);
            String dst = read(Integer.parseInt(reader.readLine().trim()));

            System.out.print("Run #" + (++i) + ": ");
            if (src.equals(dst)) {
                System.out.println("Accepted");
            } else {
                if (Arrays.equals(
                        src.chars().filter(Character::isDigit).toArray(),
                        dst.chars().filter(Character::isDigit).toArray())) {
                    System.out.println("Presentation Error");
                } else {
                    System.out.println("Wrong Answer");
                }
            }
        }
    }
}

@

\subsection{File Fragmentation}

\MyHdr{10132}{C}{average}{2}{$\bigstar$}{https://uva.onlinejudge.org/external/101/10132.pdf}

Let's sort out input/output assuming that our function [[restore]] takes a
list of strings (i.e. shards) and returns the restored string (i.e. original
file). Input is rather straightforward and, unfortunately, due to the format of
the input data, isn't very concise.

<<File Fragmentation>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
<<3.6 Imports>>

class FileFragmentation {
    private static final BufferedReader reader = 
        new BufferedReader(new InputStreamReader(System.in));

    <<3.6 Helpers>>

    private static String restore(List<String> fragments) {
        <<3.6 Implementation>>
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine());
        reader.readLine();
        for (int i = 0; i < n; ++i) {
            List<String> fragments = new ArrayList<String>();
            do {
                String s = reader.readLine();
                if (s == null || s.equalsIgnoreCase("")) {
                    break;
                }
                fragments.add(s);
            } while (true);
            System.out.println(restore(fragments));
            if (i < n - 1) {
                System.out.println();
            }
        }
    }
}
@

So how do we restore the files? It's easy to see that if we sort the shards by
length and then take the largest shard and the shortest one we will end up with
a potential original file. But there may be numerous smallest shards and
numerous largest shards, so we will need to try them one by one. This is not
that bad as it seems at first sight. This is because we only need to try one
largest shard with $n$ shortest shards in the worst case, having only two
cases: The long shard goes first and the short goes after it or vice versa.
Once we got a candidate original file we simply try to fit the rest of the
shards. This can be done very easily. We simply partition our candidate file at
every point and then check if the list contains these shards, and if it does,
we mark that. Once we found every shard in the list in this way we know that
the original file was the same as our candidate file. Otherwise we try the next
smallest shard. We continue until we fit every shard. This algorithm will
always find the original file because of how the problem is formulated.

OK, so first thing we need to do is to sort the shards by length:

<<3.6 Imports>>=
import static java.util.Comparator.comparing;
@

<<3.6 Implementation>>=
fragments.sort(comparing(String::length));
@

Then we find the largest (any will do) and get the list of the smallest shards:

<<3.6 Imports>>=
import static java.util.stream.Collectors.toList;
@

<<3.6 Implementation>>=
String large = fragments.get(fragments.size() - 1);
List<String> smallest = fragments.stream().filter(
    x -> x.length() == fragments.get(0).length()).collect(toList());
@

Let's write [[fit]] function that takes a list of shards and a candidate and
returns true or false depending on whether those shards could be fit with this
candidate file or not. This is implemented in accordance to the algorithm
described earlier.

<<3.6 Helpers>>=
private static boolean fit(List<String> fragments, String candidate) {
    List<String> temp = new ArrayList<String>(fragments);
    for (int i = 1; i < candidate.length() && !temp.isEmpty(); ++i) {
        final int j = i;
        temp.removeIf(x -> x.equalsIgnoreCase(candidate.substring(0, j)));
        temp.removeIf(x -> x.equalsIgnoreCase(candidate.substring(j)));
    }
    return temp.isEmpty();
}
@

For the largest and every smallest shard we try to fit the rest of the shards
using [[fit]] function trying both cases: large + small, and small + large. 

<<3.6 Implementation>>=
for (String small : smallest) {
    if (fit(fragments, large + small)) {
        return large + small;
    } else if (fit(fragments, small + large)) {
        return small + large;
    }
}
return "Impossible";
@

In accordance to the problem statement "Impossible" should never be returned,
unless the input is malformed for any reason.

\subsection{Doublets}

\MyHdr{10150}{C}{average}{3}{$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/101/10150.pdf}

It's a simple task of the shortest path search in a graph. But because this
graph is not directed and each edge has length 1, we can use deaph-first search
algorithm to find the shortest path.

Very straightforward.

<<Doublets>>=


import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class Doublets {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static List<String> find(Map<String, Set<String>> graph,
            String from,
            String to) {

        if (from.equalsIgnoreCase(to)) {
            List<String> output = new ArrayList<>();
            output.add(from);
            output.add(to);
            return output;
        }

        Deque<String> q = new ArrayDeque<>();
        Set<String> s = new HashSet<String>();
        Map<String, String> r = new HashMap<>();
        q.push(from);
        r.put(from, from);

        while (!q.isEmpty()) {
            String currWord = q.pop();
            for (String adjacentWord : graph.get(currWord)) {
                if (!s.contains(adjacentWord)) {
                    s.add(adjacentWord);
                    q.addLast(adjacentWord);
                    if (!r.containsKey(adjacentWord)) {
                        r.put(adjacentWord, currWord);
                    }
                }
            }
            if (r.containsKey(to)) {
                List<String> output = new ArrayList<>();
                String curr = to;
                while (!curr.equalsIgnoreCase(from)) {
                    output.add(0, curr);
                    curr = r.get(curr);
                }
                output.add(0, from);
                return output;
            }
        }

        return null;
    }

    private static boolean adjacent(String a, String b) {
        if (a.length() != b.length()) {
            return false;
        }
        int diffCount = 0;
        for (int i = 0; i < a.length(); ++i) {
            if (a.charAt(i) != b.charAt(i)) {
                diffCount++;
            }
        }
        return diffCount == 1;
    }

    private static Map<String, Set<String>> getGraph(List<String> dict) {
        Map<String, Set<String>> graph = new HashMap<>();
        dict = dict.stream().distinct()
                .sorted(Comparator.comparing(String::length)).collect(toList());
        Map<Integer, List<String>> grouped = dict.stream()
                .collect(Collectors.groupingBy(String::length));
        for (String word : dict) {
            if (!graph.containsKey(word)) {
                graph.put(word, new HashSet<>());
            }
            List<String> adjacent = grouped.get(word.length()).stream()
                    .filter(x -> adjacent(word, x)).collect(toList());
            graph.get(word).addAll(adjacent);
        }
        return graph;
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        List<String> dict = new ArrayList<>();
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().equalsIgnoreCase("")) {
            dict.add(currentLine.trim());
        }
        Map<String, Set<String>> graph = getGraph(dict);
        int line = 0;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().equalsIgnoreCase("")) {
            if (line > 0) {
                System.out.println();
            }
            List<String> input = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals(""))
                    .collect(toList());
            List<String> result = find(graph, input.get(0), input.get(1));
            if (result == null) {
                System.out.println("No solution.");
            } else {
                result.forEach(System.out::println);
            }
            line++;
        }
    }
}

@

\subsection{Fmt}

\MyHdr{848}{C}{low}{2}{$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/8/848.pdf}

This task may look simple to do at first sight, but actually it's quite
involved.  The task becomes much easier if the whole text is read before
trying to format it. We will read the whole text and break it into three type
of tokens: words, new line breaks and spaces. Continuous spaces would be
represented as one token in this list of tokens. Then, we read this list of
tokens and simply follow the rules of formatting outlines in the problem
statement.

<<Fmt>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class Fmt {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    private static final int LINE_WIDTH = 72;

    private static List<String> tokenize(String input) {
        List<String> output = new ArrayList<>();
        StringBuilder block = new StringBuilder();
        int pos = 0;
        while (pos < input.length()) {
            if (input.charAt(pos) == ' ') {
                while (pos < input.length() && input.charAt(pos) == ' ') {
                    block.append(input.charAt(pos));
                    pos++;
                }
                output.add(block.toString());
                block = new StringBuilder();
            } else if (input.charAt(pos) == '\n') {
                output.add(new String("\n"));
                pos++;
            } else {
                while (pos < input.length() && input.charAt(pos) != ' ' &&
                        input.charAt(pos) != '\n') {
                    block.append(input.charAt(pos));
                    pos++;
                }
                output.add(block.toString());
                block = new StringBuilder();
            }
        }
        if (block.length() > 0) {
            output.add(block.toString());
        }
        return output;
    }

    private static void flush(List<String> line, StringBuilder output,
            boolean newline) {
        if (line.size() > 1 && line.get(line.size() - 1).startsWith(" ")) {
            line.remove(line.size() - 1);
        }

        StringBuilder lineStr = new StringBuilder();
        for (String x : line) {
            lineStr.append(x);
        }

        output.append(lineStr).append(newline ? "\n" : "");
        line.clear();
    }

    private static String format(List<String> tokens) {
        StringBuilder output = new StringBuilder();
        List<String> line = new ArrayList<>();

        int i = 0;
        while (i < tokens.size()) {
            int currLength = line.stream().map(String::length)
                    .reduce(0, Integer::sum).intValue();
            String token = tokens.get(i);

            if (token.startsWith(" ")) {
                line.add(token);
            } else if (token.equals("\n")) {
                if (i + 1 < tokens.size()) {
                    String next = tokens.get(i + 1);
                    if (next.equals("\n") || next.startsWith(" ") ||
                            line.size() == 0 || (line.size() == 1 &&
                                    line.get(0).startsWith(" "))) {
                        flush(line, output, true);
                    } else if (currLength + next.length() <= LINE_WIDTH) {
                        line.add(" ");
                        line.add(next);
                        ++i;
                    } else {
                        flush(line, output, true);
                    }
                } else {
                    line.add(token);
                }
            } else if (currLength == 0 && token.length() > LINE_WIDTH) {
                line.add(token);
                if (i + 1 < tokens.size()) {
                    flush(line, output, true);
                    i++;
                }
            } else {
                if (currLength + token.length() > LINE_WIDTH) {
                    flush(line, output, true);
                }
                line.add(token);
            }
            ++i;
        }

        if (line.size() > 0) {
            flush(line, output, false);
        }

        return output.toString();
    }

    public static void main(String[] args) throws IOException {
        StringBuilder input = new StringBuilder();
        while (true) {
            int c = reader.read();
            if (c == -1) {
                break;
            }
            input.append((char) c);
        }
        System.out.print(format(tokenize(input.toString())));
    }
}

@

\section{Sorting}

\subsection{Vito's Family}

\MyHdr{10041}{A}{high}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/100/10041.pdf}

All we need to do is to find the median and then sum the distances.

<<Vitos Family>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.List;

public class VitosFamily {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static int solve(List<Integer> input) {
        Collections.sort(input);
        int median = 0;

        if (input.size() % 2 == 0) {
            int p = input.size() / 2 - 1;
            median = (input.get(p) + input.get(p + 1)) / 2;
        } else {
            int p = input.size() / 2;
            median = (input.get(p));
        }

        int sum = 0;
        for (Integer v : input) {
            sum += Math.abs(v - median);
        }
        return sum;
    }

    public static void main(String[] args) throws IOException {
        int cases = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < cases; ++i) {
            List<Integer> input = stream(reader.readLine().trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            System.out.println(solve(input.subList(1, input.size())));
        }
    }

}

@

\subsection{Stacks of Flapjacks}

\MyHdr{120}{B}{high}{2}{$\bigstar$}{https://uva.onlinejudge.org/external/1/120.pdf}

To solve this task all we have to do is the following: Find the next largest
value in the array that is not already in its correct position and flip it so
that it appears at the top of the stack, then do another flip so that it
appears next to the previous largest value; continue until the array
is sorted.

<<Stacks of Flapjacks>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class StacksOfFlapjacks {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static int max(List<Integer> input, int skip) {
        int index = -1;
        int max = Integer.MIN_VALUE;
        for (int i = skip; i < input.size(); ++i) {
            if (max < input.get(i)) {
                index = i;
                max = input.get(i);
            }
        }
        return index;
    }

    private static List<Integer> solve(List<Integer> input) {
        List<Integer> inputCopy = new ArrayList<>(input);
        Collections.reverse(inputCopy);
        List<Integer> flips = new ArrayList<>();
        int sorted = 0;

        while (sorted < inputCopy.size()) {
            int index = max(inputCopy, sorted);
            if (index != sorted) {
                flips.add(index + 1);
                flips.add(sorted + 1);
                Collections.reverse(inputCopy.subList(index, inputCopy.size()));
                Collections
                        .reverse(inputCopy.subList(sorted, inputCopy.size()));
            }
            sorted++;
        }
        flips.add(0);
        return flips;
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            List<Integer> input = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            System.out.println(currentLine);
            System.out.println(solve(input).stream().map(x -> x.toString())
                    .collect(Collectors.joining(" ")));
        }
    }
}

@

\subsection{Bridge}

\MyHdr{10037}{B}{low}{3}{$\bigstar$$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/100/10037.pdf}

This task is quite tricky. But before trying to solve it, let's just sort out
input/output to get it out of the way. 

We will assume that the we have a method [[getStrategy]] that takes a list of
integers (crossing times) and returns two lists. The first list holds crossing
times going from left to right, and the second list holds crossing times from
right to left. (We assume the group of people starts on the left side of the
bridge.) Let's assume there's a [[printResult]] method that takes that output
of [[getStrategy]] and prints it out in the format specified in the problem
statement.

<<Bridge>>=
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.range;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;
import java.util.function.BiConsumer;
import java.util.stream.Stream;


class Bridge {
    private static final BufferedReader reader = 
        new BufferedReader(new InputStreamReader(System.in));
    private static final int LEFT_RIGHT = 0;
    private static final int RIGHT_LEFT = 1;

    private static void printResult(final List<List<Integer>> result) {
        <<4.3 Print Result>>
    }

    private static List<List<Integer>> getStrategy(List<Integer> input) {
        <<4.3 Get Strategy>>
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.valueOf(reader.readLine().trim());
        reader.readLine();
        for (int i = 0; i < n; ++i) {
            int count = Integer.valueOf(reader.readLine().trim());
            List<Integer> input = reader.lines().map(String::trim)
                .limit(count).map(Integer::parseInt).collect(toList());
            printResult(getStrategy(input));
            if (i < n - 1) {
                reader.readLine();
                System.out.println();
            }
        }
    }
}
@

Let's implement the [[printResult]] method. Like we said, the [[result]] list
contains two lists of integers, one list denoting crossing times from left to
right, and the other from right to left. The first list will always contain
pairs, as people are crossing from left to right (as we agreed).

The simplest case of all is when there's just one person. In that case we
simply print the total time, which will equal to the crossing time of this person,
and then the same number again, denoting that person crossing the bridge.

<<4.3 Print Result>>=
List<Integer> lr = result.get(LEFT_RIGHT);
List<Integer> rl = result.get(RIGHT_LEFT);
if (lr.size() == 1) {
    System.out.println(lr.get(0));
    System.out.println(lr.get(0));
    return;
}

@

Otherwise, we need to sum the crossing times. For the list that holds crossing
times from right to left is easy, we just sum those numbers. For the list that
holds crossing times from left to right we need to sum the second number in
each pair (i.e. the slowest person).

<<4.3 Print Result>>=
int totalTime = range(0, lr.size()).filter(x -> (x + 1) % 2 == 0)
        .map(x -> lr.get(x)).sum() +
        rl.stream().mapToInt(Integer::intValue).sum();
@

Finally, we just output the [[totalTime]] and print the strategy.

<<4.3 Print Result>>=
System.out.println(totalTime);
Stream.iterate(0, i -> i + 2).limit(lr.size() / 2).forEachOrdered(i -> {
    System.out.println(lr.get(i) + " " + lr.get(i + 1));
    if (i / 2 < rl.size()) {
        System.out.println(rl.get(i / 2));
    }
});
@

OK, now let's figure out the strategy. If there's just one person that's easy:

<<4.3 Get Strategy>>=
final List<List<Integer>> output = Arrays
                .asList(new ArrayList<Integer>(), new ArrayList<Integer>());

if (input.size() == 1) {
    output.get(LEFT_RIGHT).add(input.get(0));
    return output;
}

@

Obviously the time of crossing the bridge equals to the slowest in a pair.
Let's assume we have four people and their crossing speeds are $x_1 <= x_2 <=
x_3 <= x_4$. One way to transfer them is this: $x_1$ and $x_2$ cross, $x_1$
returns, then $x_3$ and $x_4$ cross, and $x_2$ returns, finally $x_1$ and $x_2$
cross. This amounts to total time $x_1 + 3x_2 + x_4$. Another way to transfer
is $x_1$ and $x_2$ cross, $x_1$ returns, then $x_1$ and $x_3$ cross, and $x_1$
returns, finally $x_1$ and $x_4$ cross. This amounts to total time $2x_1 + x_2
+ x_3 + x_4$. This essentially solves the task, because we simply choose the
strategy that leads to the smallest time. That is we simply check if $x_1 + 3x_2 +
x_4 \leq  2x_1 + x_2 + x_3 + x_4$, or, equivalently, $2x_2 \leq x_1 + x_3$.

These two strategies still work event if there are more than four people. We
assign to $x_1$ the fastest and to $x_4$ the slowest, to $x_2$ the second
fastest, and to $x_3$ the second slowest.

We will be dealing with the fastest and the slowest so having priority queues
will be convenient, so let's have them:

<<4.3 Get Strategy>>=
final PriorityQueue<Integer> left = new PriorityQueue<>();
final PriorityQueue<Integer> right = new PriorityQueue<>();
@

And we are going to move data from left to right quite a lot, so let's have a 
helper:

<<4.3 Get Strategy>>=
final BiConsumer<PriorityQueue<Integer>, PriorityQueue<Integer>> move = (
        from, to) -> {
    if (!from.isEmpty()) {
        Integer v = from.remove();
        to.add(v);
        output.get(from == left ? LEFT_RIGHT : RIGHT_LEFT).add(v);
    }
};

@

Note that this helper also puts the corresponding values to the [[output]].

Now let's implement the main loop. Note that whenever returning from right to
left, always the fastest from the group on the right should go. Who goes from
left to right will depend on the inequality that we discussed above.

<<4.3 Get Strategy>>=
left.addAll(input);

while (!left.isEmpty()) {
    move.accept(right, left);
    move.andThen(move).accept(left, right);
    if (left.isEmpty()) {
        break;
    }

    move.accept(right, left);
    if (left.size() == 2) {
        move.andThen(move).accept(left, right);
        break;
    }

    Integer x1 = left.remove();
    Integer x2 = right.peek();
    Integer x4 = left.stream().max(Integer::compareTo).get();
    left.remove(x4);
    Integer x3 = left.stream().max(Integer::compareTo).get();
    left.remove(x3);
    int[] x = (2 * x2 <= x1 + x3) ? new int[] { x1, x3, x4 }
            : new int[] { x4, x1, x3 };

    left.add(x[0]);
    output.get(LEFT_RIGHT).add(x[1]);
    output.get(LEFT_RIGHT).add(x[2]);
    right.add(x[1]);
    right.add(x[2]);
}

return output;
@

This concludes the program.

\subsection{Longest Nap}

\MyHdr{10191}{B}{average}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/101/10191.pdf}

Here we simply need to read time intervals, then combine the overlapping or
connecting intervals into the large ones, finally find the longest gap between
these combined intervals.

The program is self-explanatory.

<<Longest Nap>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LongestNap {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    private static final int START = 0;
    private static final int END = 1;

    private final static Pattern pattern = Pattern
            .compile("(\\d\\d:\\d\\d)\\s+(\\d\\d:\\d\\d)");

    private final static DateTimeFormatter formatter = DateTimeFormatter
            .ofPattern("HH:mm");

    private static final LocalTime[] parseTime(String line) {
        Matcher matcher = pattern.matcher(line);
        matcher.find();
        return new LocalTime[] {
                LocalTime.parse(matcher.group(1), formatter),
                LocalTime.parse(matcher.group(2), formatter)
        };
    }

    private static final List<LocalTime[]> combine(
            List<LocalTime[]> intervals) {
        List<LocalTime[]> intr = new ArrayList<>(intervals);
        intr.sort((x, y) -> x[START].compareTo(y[START]));
        List<LocalTime[]> res = new ArrayList<>();

        while (!intr.isEmpty()) {
            LocalTime[] curr = intr.remove(0);
            while (!intr.isEmpty()) {
                if (intr.get(0)[START].isBefore(curr[END]) ||
                        intr.get(0)[START].equals(curr[END])) {
                    LocalTime[] next = intr.remove(0);
                    if (curr[END].isAfter(next[START]) ||
                            curr[END].equals(next[START])) {
                        if (curr[END].isBefore(next[END])) {
                            curr[END] = next[END];
                        }
                    }
                } else {
                    break;
                }
            }
            res.add(curr);
        }

        return res;
    }

    private static LocalTime[] findLongest(List<LocalTime[]> intervals) {
        if (intervals.size() == 0) {
            return new LocalTime[] { LocalTime.of(10, 0),
                    LocalTime.of(8, 0) };
        }

        LocalTime earliest = intervals.get(0)[START];
        LocalTime latest = intervals.get(intervals.size() - 1)[END];

        long i1 = earliest.toSecondOfDay() -
                LocalTime.of(10, 0).toSecondOfDay();
        long i2 = LocalTime.of(18, 0).toSecondOfDay() - latest.toSecondOfDay();

        LocalTime[] result = (i1 < i2)
                ? new LocalTime[] { latest, LocalTime.ofSecondOfDay(i2) }
                : new LocalTime[] { LocalTime.of(10, 0),
                        LocalTime.ofSecondOfDay(i1) };

        for (int i = 0; i < intervals.size() - 1; ++i) {
            long interval = intervals.get(i + 1)[START].toSecondOfDay() -
                    intervals.get(i)[END].toSecondOfDay();
            if (interval >= result[1].toSecondOfDay()) {
                boolean same = interval == result[1].toSecondOfDay();
                result[1] = LocalTime.ofSecondOfDay(interval);
                if (same && result[0].isAfter(intervals.get(i)[END]) || !same) {
                    result[0] = intervals.get(i)[END];
                }
            }
        }

        return result;
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        int d = 1;
        while ((currentLine = reader.readLine()) != null) {
            int appointments = Integer.parseInt(currentLine.trim());
            List<LocalTime[]> intervals = new ArrayList<>();
            for (int i = 0; i < appointments; ++i) {
                intervals.add(parseTime(reader.readLine()));
            }
            LocalTime[] result = findLongest(combine(intervals));
            System.out.println("Day #" + d + ": the longest nap starts at " +
                    formatter.format(result[START]) + " and will last for " +
                    ((result[1].getHour() > 0)
                            ? result[1].getHour() + " hours and " : "") +
                    result[1].getMinute() + " minutes.");
            d++;
        }
    }
}

@

\subsection{Shoemaker's Problem}

\MyHdr{10026}{C}{average}{2}{$\bigstar$$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/100/10026.pdf}

Let's assume we have four jobs that take $d_1, d_2, d_3, d_4$ days and have
corresponding fines $f_1, f_2, f_3, f_4$. Let's also assume they are in the
optimal order, that is $S = 0 \cdot f_1 + (d_1) \cdot f_2 + (d_1 + d_2) \cdot
f_3 + (d_1 + d_2 + d_3)\cdot f_4$ and $S$ value is minimal. Let's now suppose
we swap job three and four, so we get another value $\hat{S}=0 \cdot f_1 +
(d_1) \cdot f_2 + (d_1 + d_2) \cdot f_4 + (d_1 + d_2 + d_3)\cdot f_3$, but
since $S$ is optimal it means that $S \leq \hat{S}$, or

$$ 0 \cdot f_1 + (d_1) \cdot f_2 + (d_1 + d_2) \cdot f_4 + (d_1 + d_2 +
d_3)\cdot f_3 - (0 \cdot f_1 + (d_1) \cdot f_2 + (d_1 + d_2) \cdot f_3 + (d_1 +
d_2 + d_3)\cdot f_4) \geq 0 $$

and so

$$ f_3d_4 - f_4d_3 \geq 0 $$ 
$$ f_3d_4 \geq f_4d_3 $$

This in turn means that in the optimal order $d_3$ will go before $d_4$ if
$f_3/d_3 \geq f_4/d_4$. So, generally, $d_i$ will go before $d_j$ if
$f_i/d_i \geq f_j/d_j$.

<<Shoemakers Problem>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class ShoemakersProblem {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static class Job implements Comparable<Job> {
        int start;
        int fine;
        int index;

        public Job(int index, int start, int fine) {
            this.index = index;
            this.start = start;
            this.fine = fine;
        }

        @Override
        public int compareTo(Job o) {
            return Integer.compare(o.fine * start, fine * o.start);
        }
    }

    public static void main(String[] args)
            throws NumberFormatException, IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            reader.readLine();
            int count = Integer.parseInt(reader.readLine().trim());
            Job[] jobs = new Job[count];
            for (int j = 0; j < count; ++j) {
                List<Integer> input = stream(
                        reader.readLine().trim().split(" "))
                                .filter(x -> !x.equals(""))
                                .map(Integer::parseInt)
                                .collect(toList());
                jobs[j] = new Job(j, input.get(0), input.get(1));
            }
            Arrays.sort(jobs);
            System.out.println(Arrays.stream(jobs).map(x -> x.index + 1)
                    .map(String::valueOf)
                    .collect(Collectors.joining(" ")));
            if (i < n - 1) {
                System.out.println();
            }
        }
    }
}

@

\subsection{CDVII}

\MyHdr{10138}{C}{low}{2}{$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/101/10138.pdf}

The problem statement is a bit vague. When I first read it I thought I'd need
to figure out the speed of each car and then using that figure out how many
kilometers each car went in specific hours. But then I looked at the sample
input and realized that it only takes into account the rate at the moment of
entry. So the task becomes much easier.

What's the difficulty then? Well, there is not much difficulty in this task. We
just need to carefully pair enter and exit times and prepare bills based on
these pairs.

Let's code input/output first. We are going to have a helper class [[Event]]
that will encapsulate event information: License number, time of entrance or
exit, and location. For parsing the input lines we are going to use a regex.
Notice that for [[getBills]] the return type is [[Entry<String, AtomicInteger>]]. 
The key of [[Entry]] will be a license plate, and the value
will be the bill in cents. We are using [[AtomicInteger]] because it has
convenient update semantics.

<<CDVII>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class CDVII {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static Pattern pattern = Pattern.compile(
            "([\\d\\w]+)\\s+(\\d\\d):(\\d\\d):(\\d\\d):(\\d\\d)\\s+(\\w+)\\s+(\\d+)");

    private static class Event {
        private final String license;
        private final LocalDateTime timestamp;
        private final String action;
        private final int location;

        public LocalDateTime getTimestamp() {
            return timestamp;
        }

        public String getAction() {
            return action;
        }

        public String getLicense() {
            return license;
        }

        public Event(String line) {
            Matcher matcher = pattern.matcher(line);
            matcher.find();
            license = matcher.group(1);
            timestamp = LocalDateTime.of(LocalDate.now().getYear(),
                    Integer.parseInt(matcher.group(2)),
                    Integer.parseInt(matcher.group(3)),
                    Integer.parseInt(matcher.group(4)),
                    Integer.parseInt(matcher.group(5)));
            action = matcher.group(6).toLowerCase();
            location = Integer.parseInt(matcher.group(7));
        }
    }

    private static List<Entry<String, AtomicInteger>> getBills(
            List<Integer> rate,
            List<Event> events) {
        <<4.6 Get Bills>>
    }

    private static Event[] findInterval(List<Event> enters, List<Event> exits) {
        <<4.6 Find Interval>>
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine());
        reader.readLine();
        for (int i = 0; i < n; ++i) {
            List<Integer> rate = stream(reader.readLine().trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            String currentLine;
            List<Event> events = new ArrayList<>();
            while ((currentLine = reader.readLine()) != null &&
                    !currentLine.trim().equals("")) {
                events.add(new Event(currentLine));
            }
            for (Entry<String, AtomicInteger> e : getBills(rate, events)) {
                System.out.println(e.getKey() + " $" +
                        BigDecimal.valueOf(e.getValue().intValue(), 2));
            }
            if (i < n - 1) {
                System.out.println();
            }
        }

    }
}

@

OK, now let's have a look at [[findInterval]]. Obviously the intervals can't
overlap. If intervals overlap it means there are two or more cars with the same
license plate. So we assume there aren't. This suggests an idea on how to find
intervals given the lists of enter and exit times for a license plate. 

We assume the lists [[enters]] and [[exits]] are sorted in chronological
order. We repeat the search loop until any of [[enters]] or [[exits]] becomes
empty. We get the first entry [[enter]] from [[enters]] and try to find an
event from the [[exits]] list such that its timestamp is after the [[start]]
timestamp. If there's not such an entry, we remove [[enter]] from [[enters]]
and get another one. If there's a candidate in the [[exits]], then we must
check if there aren't any other events in [[starts]] that lie in between
[[start]] and [[exit]]. If there are, we can't use this [[start]], because it
would mean overlapping. So we skip such [[start]]. If, however, there is no
overlapping, then we've found a candidate interval and we return it.  When we
can't find an interval, we return [[null]].

<<4.6 Find Interval>>=
while (!enters.isEmpty() && !exits.isEmpty()) {
    final Event enter = enters.remove(0);
    final Event exit = exits.stream()
            .filter(x -> x.timestamp.isAfter(enter.timestamp))
            .findFirst()
            .orElse(null);

    if (exit == null) {
        continue;
    }

    boolean overlap = enters.stream()
            .anyMatch(x -> x.timestamp.isAfter(enter.timestamp) &&
                    x.timestamp.isBefore(exit.timestamp));

    if (!overlap) {
        exits.remove(exit);
        return new Event[] { enter, exit };
    }
}
return null;
@

Now let's implement [[getBills]]. We will keep our billing in a map, with the
key being license plate, and the value being the bill. The [[group]] will group
events per license plate. Then for each entry in this group we will prepare a
bill. Finally, we return the entries sorted by license plates in alphabetical
order.

<<4.6 Get Bills>>=
Map<String, AtomicInteger> bills = new HashMap<>();
Map<String, List<Event>> groups = events.stream().collect(
        Collectors.groupingBy(Event::getLicense, Collectors.toList()));

for (Entry<String, List<Event>> entry : groups.entrySet()) {
    <<4.6 Billing>>
}

return bills.entrySet().stream()
        .sorted((x, y) -> x.getKey().compareTo(y.getKey()))
        .collect(toList());

@

Bill preparation will be done using these steps: First, we partition the events
into to groups, [[enters]] and [[exits]]. If either of these arrays is empty,
we skip and move onto another license plate.

<<4.6 Billing>>=
String license = entry.getKey();
Map<String, List<Event>> actions = entry.getValue().stream()
        .collect(Collectors.groupingBy(Event::getAction,
                Collectors.toList()));
List<Event> enters = actions.get("enter");
List<Event> exits = actions.get("exit");
if (enters == null || exits == null) {
    continue;
}
@

Now, let's sort them, because our [[findInterval]] method expects them in
sorted order.

<<4.6 Billing>>=
exits.sort(Comparator.comparing(Event::getTimestamp));
enters.sort(Comparator.comparing(Event::getTimestamp));
@

Then, in a loop, we call [[findInterval]] and calculate the amount to be added
to the bill. This is achieved by getting the [[enter]]'s timestamp and getting
the hour value. That will be the index into [[rate]] array, which holds rates
for specific hours. Then we multiply it by the distance to get the total price
plus 100, price for each trip.

<<4.6 Billing>>=
Event[] interval = findInterval(enters, exits);
while (interval != null) {
    Event enter = interval[0];
    Event exit = interval[1];
    bills.putIfAbsent(license, new AtomicInteger(200));
    int distance = Math.abs(exit.location - enter.location);
    bills.get(license).addAndGet(
            rate.get(enter.timestamp.getHour()) * distance + 100);
    interval = findInterval(enters, exits);
}
@

This concludes the program.

\subsection{ShellSort}

\MyHdr{10152}{B}{average}{2}{$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/101/10152.pdf}

The key to this problem answer is to note that all the items in the stack
above the one that is about to be moved will move down. Therefore we just need
to find all such elements, and everything else will need to be moved using the
operation described in the problem statement.

Let's start with the input/output assuming that we have [[getStrategy]] method
which takes [[input]] array and the [[target]] array and returns an answer,
i.e. a list of items that need to be moved to the top:

<<ShellSort>>=
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.List;

class ShellSort {
    private static final BufferedReader reader = 
        new BufferedReader(new InputStreamReader(System.in));

    private static List<String> getStrategy(List<String> input, List<String> target) {
        <<4.7 Implementation>>
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.valueOf(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            int count = Integer.valueOf(reader.readLine().trim());
            List<String> input = reader.lines().limit(count).collect(toList());
            List<String> target = reader.lines().limit(count).collect(toList());
            getStrategy(input, target).forEach(System.out::println);
            System.out.println();
        }
    }
}
@

OK, let's get to the implementation of the method that finds the optimal
strategy. We start from the bottom of the lists and work towards the top,
comparing the items. The idea is that we move sequentially in the [[target]]
array and move towards the top in the [[input]] array potentially skipping some
elemnts until we hit the start of the array. The index in the [[target]] array,
at which we broke the loop, will be the point that will divide the [[target]]
array into two parts: Elements above it are the elements that will need to be
moved, eleemnts below do not need to be moved.

<<4.7 Implementation>>=
int i = input.size() - 1;
int j = target.size() - 1;
while (i >= 0 && j >= 0) {
    while (j >= 0 && !target.get(i).equals(input.get(j))) {
        j--;
    }
    if (j < 0) {
        break;
    }
    i--;
    j--;
}
List<String> output = target.subList(0, i + 1);
Collections.reverse(output);
return output;
@

\subsection{Football (aka Soccer)}

\MyHdr{10194}{B}{average}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/101/10194.pdf}

It took me so many attempts before the online judge accepted my solution (15
times!) so that at some point I thought I'd give up. It turned out that my
solution was absolutely correct (of course it was, it's a trivial task!). The
only incorrect thing was around input/output encoding. Ludicrous!

In the code below probably Java String's built-in [[split]] method could have
been sufficient, but because I was desperate in figuring out why the online
judge didn't like my solution I ended up writing my custom made method. I've
left it as is as I don't want to spend any more time on this task.

<<Football aka Soccer>>=
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class FootballAkaSoccer {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in, Charset.forName("ISO-8859-1")));
    private static final PrintWriter output = new PrintWriter(
            new BufferedWriter(
                    new OutputStreamWriter(System.out,
                            Charset.forName("ISO-8859-1"))));

    private static class TeamRank implements Comparable<TeamRank> {
        private final String name;
        private int points;
        private int goalsScored;
        private int goalsAgainst;
        private int gamesPlayed;
        private int wins;
        private int ties;
        private int losses;

        public TeamRank(String name) {
            this.name = name;
        }

        @Override
        public String toString() {
            return name + " " + points + "p, " + gamesPlayed + "g (" + wins +
                    "-" + ties + "-" + losses + "), " +
                    (goalsScored - goalsAgainst) + "gd (" + goalsScored + "-" +
                    goalsAgainst + ")";
        }

        @Override
        public int compareTo(TeamRank o) {
            int pointsCmp = o.points - points;
            if (pointsCmp != 0) {
                return pointsCmp;
            }

            int winsCmp = o.wins - wins;
            if (winsCmp != 0) {
                return winsCmp;
            }

            int gdCmp = (o.goalsScored - o.goalsAgainst) -
                    (goalsScored - goalsAgainst);
            if (gdCmp != 0) {
                return gdCmp;
            }

            int goalsCmp = o.goalsScored - goalsScored;
            if (goalsCmp != 0) {
                return goalsCmp;
            }

            int gamesPlayedCmp = gamesPlayed - o.gamesPlayed;
            if (gamesPlayedCmp != 0) {
                return gamesPlayedCmp;
            }

            return name.toLowerCase().compareTo(o.name.toLowerCase());
        }
    }

    private static class Game {
        private final String[] teams;
        private final int[] goals;

        private String[] split(String input, String ch) {
            return new String[] {
                    input.substring(0, input.indexOf(ch)),
                    input.substring(input.indexOf(ch) + 1, input.length())
            };
        }

        public Game(String game) {
            String[] parts = split(game, "@");
            goals = new int[] {
                    Integer.parseInt(split(parts[0], "#")[1]),
                    Integer.parseInt(split(parts[1], "#")[0])
            };
            teams = new String[] {
                    split(parts[0], "#")[0],
                    split(parts[1], "#")[1]
            };
        }
    }

    private static TeamRank getRank(String teamName, List<Game> games) {
        TeamRank rank = new TeamRank(teamName);
        for (Game g : games) {
            boolean t1 = g.teams[0].equals(teamName);
            boolean t2 = g.teams[1].equals(teamName);
            if (t1 || t2) {
                rank.goalsScored += g.goals[t1 ? 0 : 1];
                rank.goalsAgainst += g.goals[t1 ? 1 : 0];
                rank.gamesPlayed++;
                int cmp = Integer.compare(g.goals[t1 ? 0 : 1],
                        g.goals[t1 ? 1 : 0]);
                if (cmp == 0) {
                    rank.ties++;
                    rank.points++;
                } else if (cmp == -1) {
                    rank.losses++;
                } else {
                    rank.wins++;
                    rank.points += 3;
                }
            }
        }
        return rank;
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine());
        for (int i = 0; i < n; ++i) {
            String tournamentName = reader.readLine();
            int teamCount = Integer.parseInt(reader.readLine().trim());
            Set<String> teamSet = new HashSet<>();
            for (int j = 0; j < teamCount; ++j) {
                teamSet.add(reader.readLine());
            }
            int gamesCount = Integer.parseInt(reader.readLine().trim());
            List<Game> games = new ArrayList<>();
            for (int j = 0; j < gamesCount; ++j) {
                games.add(new Game(reader.readLine()));
            }
            List<String> teams = new ArrayList<>(teamSet);
            List<TeamRank> ranks = new ArrayList<>();
            for (int j = 0; j < teams.size(); ++j) {
                ranks.add(getRank(teams.get(j), games));
            }
            Collections.sort(ranks);
            output.println(tournamentName);
            for (int j = 0; j < ranks.size(); ++j) {
                output.println((j + 1) + ") " + ranks.get(j));
                output.flush();
            }
            if (i < n - 1) {
                output.println();
            }
        }
        output.close();
    }
}

@

\section{Arithmetic and Algebra}

\subsection{Primary Arithmetic}

\MyHdr{10194}{A}{average}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/101/10194.pdf}

This task is trivial.

<<Primary Arithmetic>>=
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class PrimaryArithmetic {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static int[] asArray(String input, int pad) {
        int[] a = new int[input.length() + pad];
        for (int i = 0; i < input.length(); ++i) {
            a[i] = input.charAt(input.length() - i - 1) - '0';
        }
        return a;
    }

    public static int count(List<String> input) {
        int[] a = asArray(input.get(0), 0);
        int[] b = asArray(input.get(1),
                input.get(0).length() - input.get(1).length());
        int carry = 0;
        int count = 0;
        for (int i = 0; i < a.length; ++i) {
            int c = a[i] + b[i] + carry;
            if (c >= 10) {
                carry = 1;
                count++;
            } else {
                carry = 0;
            }
        }
        return count;
    }

    public static String toMessage(int count) {
        if (count == 0) {
            return "No carry operation.";
        } else if (count == 1) {
            return "1 carry operation.";
        } else {
            return count + " carry operations.";
        }
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            List<String> input = Arrays
                    .stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals(" "))
                    .sorted(Comparator.comparing(String::length).reversed())
                    .collect(toList());
            if (input.get(0).equals("0") && input.get(1).equals("0")) {
                break;
            }
            System.out.println(toMessage(count(input)));
        }
    }
}
@


\subsection{Reverse And Add}

\MyHdr{10018}{A}{low}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/100/10018.pdf}

This task is trivial.

<<Reverse And Add>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class ReverseAndAdd {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static long reverse(long value) {
        long reversed = 0;
        while (value > 9) {
            reversed = reversed * 10 + (value % 10);
            value /= 10;
        }
        reversed = reversed * 10 + value;
        return reversed;
    }

    private static boolean isPalindrome(long value) {
        return value == reverse(value);
    }

    public static long[] calculate(long value) {
        int count = 0;
        do {
            value = value + reverse(value);
            count++;
        } while (!isPalindrome(value));
        return new long[] { count, value };
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            long v = Integer.parseInt(reader.readLine().trim());
            long[] res = calculate(v);
            System.out.println(res[0] + " " + res[1]);
        }
    }
}
@

\subsection{The Archeologists' Dilemma}

\MyHdr{701}{A}{low}{1}{$\bigstar$$\bigstar$$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/7/701.pdf}

Unlike the previous two tasks, this tasks is quite challenging. 

Let's paraphrase this task in mathematical terms. For a given number $v$ find
positive integers $m$ and $n$ such that 

$$ v \cdot 10^n \leq 2^m < (v+1) \cdot 10^n $$

where $n \geq l(v) + 1$, and $l(v)$ is the number of digits in $v$.

Let's take common logarithms on that inequality

$$ log(v \cdot 10^n) \leq log(2^m) < log((v+1) \cdot 10^n) $$

which is the same as

$$ log(v) + log(10^n) \leq log(2^m) < log(v+1) + log(10^n) $$

and

$$ log(v) + n \cdot log(10) \leq m \cdot log(2) < log(v+1) + n \cdot log(10) $$

which is the same as

$$ log(v) + n \leq m \cdot log(2) < log(v+1) + n.$$

This solves the task, because all we need to do now is to iterate on $n$
starting with $n=l(v)+1$. For a given $n$ we find an initial $m$ by using the
left part of the inequality, so

$$m = \lfloor{\frac{log(v) + n}{log(2)}}\rfloor$$

Then we increment $m$ while $log(v) + n \geq m \cdot log(2)$. Once this loop
stops, we check if $m \cdot log(2) < log(v+1) + n$, and if so, $m$ is the
answer. Otherwise, we increment $n$ and start everything all over again.

<<The Archeologists Dilemma>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;

public class TheArcheologistsDilemma {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static long calculate(long v) {
        long n = BigDecimal.valueOf(v).precision() + 1;
        final double left = Math.log10(v);
        final double right = Math.log10(v + 1);
        final double log10_2 = Math.log10(2);
        while (true) {
            long m = (long) Math.floor((left / log10_2) + n / log10_2);
            while (left + n > (log10_2 * m)) {
                m++;
            }
            if (right + n > (log10_2 * m)) {
                return m;
            }
            n++;
        }
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            System.out.println(calculate(Long.parseLong(currentLine.trim())));
        }
    }
}
@


\subsection{Ones}

\MyHdr{10127}{A}{high}{2}{$\bigstar$}{https://uva.onlinejudge.org/external/101/10127.pdf}

This is a little nice problem but it may take some time to come up with a proper
solution. Obviously these "minimum multiples" of [[n]] can quickly become too
large, and so we can't use the standard types of the language to do the
calculations. The next natural idea would be to try to use [[BigInteger]] and
repeatedly do $x = x \times 10 + 1$ and then checking [[x % n == 0]] until it
becomes [[true]]. But this is not a solution, it's too slow.

Another idea would be too come up with some clever "divisibility rules" to see
if a given $n$ divides a number that has only 1s in it. But this a dead end
too.

Of course, the general idea is to simply test if [[x % n == 0]] for a given
$n$ where $x$ is a number consisting of 1s only.

To do that we can simply do long division and keep appending 1s to the
reminder until it doesn't divide without a reminder. 

Before we implement the long division, let's write input/output:

<<Ones>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Ones {
    private static final BufferedReader reader = 
        new BufferedReader(new InputStreamReader(System.in));

    private static int calculate(int n) {
        <<5.4 Calculation>>
    }

    public static void main(String[] args) throws IOException {
        reader.lines().map(Integer::parseInt)
                      .map(Ones::calculate)
                      .forEach(System.out::println);
    }
}
@

We implement the case when [[n]] is 1 first:

<<5.4 Calculation>>=
if (n == 1) {
    return 1;
}
@

Any other number can be calculated using the long division.

Let's workout a small example. Let's say we want to find the minimum multiple
for $n=91$. We start with $s=11$ and $r=11$. But clearly because $s < n$ we
need to append one more 1, $s=r \times 10+1$, so now $s=111$, and $r=s-(n *
\lfloor s / n \rfloor)$, so $r=20$; and since $r \neq 0$ we continue by
extending $s=r \times 10+1$ and then repeat the steps until $r=0$. But note
though that $r=s-(n * \lfloor s / n \rfloor)$ is equivalent to [[r = s % n]].

OK, now we can capture that in code:

<<5.4 Calculation>>=
int l = 0;
int r = 0;
do {
    r = (r * 10 + 1) % n;
    l++;
} while (r > 0);
return l;
@

Brilliant.

\subsection{A Multiplication Game}

\MyHdr{847}{A}{high}{3}{$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/8/847.pdf}

Unfortunately I couldn't come up with anything more clever than a recursive
algorithm that tries all the possible multipliers at each step and chooses the
one that leads to the win. Because a direct recursive algorithm without any
optimization would be awfully slow, we need some memoization. This is possible,
because many multipliers would lead to the same value, so we can cache them, we
just need to keep track of whose turn it is at this moment of time. For that we
will have a list of two maps, one for each player, and the map will map a value
to the result.

The program is quite compact:

<<A Multiplication Game>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

class MultiplicationGame {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static int solve(long p, long n, int t,
            List<HashMap<Long, Integer>> memo) {
        if (p >= n) {
            return t - 1;
        }

        int s = t % 2;
        for (int i = 9; i >= 2; --i) {
            int result = 0;
            long next = p * i;
            if (memo.get(s).containsKey(next)) {
                result = memo.get(s).get(next);
            } else {
                result = solve(next, n, t + 1, memo);
                memo.get(s).put(next, result);
            }
            if (result % 2 == t % 2) {
                return result;
            }
        }

        return t + 1;
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            long input = Long.parseLong(currentLine.trim());
            List<HashMap<Long, Integer>> memo = new ArrayList<>();
            memo.add(new HashMap<Long, Integer>());
            memo.add(new HashMap<Long, Integer>());
            System.out.println(
                    solve(1, input, 1, memo) % 2 == 0 ? "Ollie wins."
                            : "Stan wins.");
        }
    }
}
@

\subsection{Polynomial Coefficients}

\MyHdr{10105}{A}{high}{1}{$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/101/10105.pdf}

This task is very straightforward, we just use the Newton's generalized
binomial theorem.

The formula is:

$$\frac{n!}{k_1!k_2! \ldots k_m!}$$

We won't calculate it as is, but first simplify the fraction whenever possible.

<<Polynomial Coefficients>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class PolynomialCoefficients {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static List<Integer> expand(int n) {
        List<Integer> res = new ArrayList<Integer>();
        for (int i = n; i > 0; --i) {
            res.add(i);
        }
        return res;
    }

    private static long calculate(int n, List<Integer> v) {
        List<Integer> numerator = expand(n);
        List<Integer> denominator = new ArrayList<>();
        v.stream().filter(x -> x > 0)
                .forEach(x -> denominator.addAll(expand(x)));
        Iterator<Integer> it = denominator.iterator();
        while (it.hasNext()) {
            if (numerator.remove(it.next())) {
                it.remove();
            }
        }
        return numerator.stream().reduce(1, Math::multiplyExact).intValue() /
                denominator.stream().reduce(1, Math::multiplyExact).intValue();
    }

    private static List<Integer> readList(String input) {
        return stream(input.trim().split(" "))
                .filter(x -> !x.equals("")).map(Integer::parseInt)
                .collect(toList());
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            List<Integer> nk = readList(currentLine);
            List<Integer> v = readList(reader.readLine());
            System.out.println(calculate(nk.get(0), v));
        }
    }
}
@

\subsection{The Stern-Brocot Number System}

\MyHdr{10077}{C}{high}{1}{$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/100/10077.pdf}

This task is just about searching the binary tree, which is trivial.

<<The Stern-Brocot Number System>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;

public class TheSternBrocotNumberSystem {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static int gcd(int a, int b) {
        while (b != 0) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }

    private static String get(int a, int b) {
        int gcd = gcd(a, b);
        a = a / gcd;
        b = b / gcd;

        int[] l = new int[] { 0, 1 };
        int[] m = new int[] { 1, 1 };
        int[] r = new int[] { 1, 0 };

        StringBuilder result = new StringBuilder();
        while (true) {
            int cmp = Integer.compare(a * m[1], b * m[0]);
            if (cmp == -1) {
                r = new int[] { m[0], m[1] };
                m = new int[] { l[0] + m[0], l[1] + m[1] };
                result.append("L");
            } else if (cmp == 1) {
                l = new int[] { m[0], m[1] };
                m = new int[] { r[0] + m[0], r[1] + m[1] };
                result.append("R");
            } else {
                break;
            }
        }
        return result.toString();
    }

    private static List<Integer> readList(String input) {
        return stream(input.trim().split(" "))
                .filter(x -> !x.equals("")).map(Integer::parseInt)
                .collect(toList());
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            List<Integer> ab = readList(currentLine);
            if (ab.get(0) == 1 && ab.get(1) == 1) {
                break;
            }
            System.out.println(get(ab.get(0), ab.get(1)));
        }
    }
}
@

\subsection{Pairsumonious Numbers}

\MyHdr{10202}{B}{high}{4}{$\bigstar$$\bigstar$$\bigstar$$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/102/10202.pdf}

Let's have a look at a small example. Let's suppose our numbers 
$a_1, a_2, a_3, a_4$ are all positive and in ascending order then their sums are
$a_1+a_2, a_1+a_3, a_1+a_4, a_2+a_3,a_2+a_4,a_3+a_4$ and are also in ascending order.
Let's suppose now we only have $b_1, \ldots, b_6$, where one of the possible
assignments for $b_1, \ldots, b_6$ can be, for example, $b_1=a_1+a_2,
b_2=a_1+a_3, b_3=a_1+a_4, b_4=a_2+a_3,b_5=a_2+a_4,b_6=a_3+a_4$.  How can we
restore $a_1, \ldots, a_4$ without knowing which of such assignments was used
initially? 

We can start with some value $x$ by assuming that $a_1=x$ (let's suppose any
number for now). Then $a_2$ is determined by one of the values $b_1, \ldots,
b_6$. Let's choose $b_1$, then the second number is obviously $a_2=b_1
- x$. Similarly, we can work out $a_3$ and $a_4$. Of course, there are multiple
 choices at each step, so we exhaustively try all possible
combinations by using a backtracking technique.

But straightforward backtracking won't work. First, we don't know which
range to select the initial $x$ from. Second, trying all the combinations
without eliminating some dead end combinations will be too slow. So we need to
narrow the range for the $x$, and also not to proceed with some combinations
that don't lead to a solution.

We assumed that the values were all positive, however it's easy to see that 
our backtracking would still work if the number weren't positive.

Let's see how can we eliminate the dead end combinations. Let's suppose we have
$a_1, a_2$ and the other two values are undetermined yet. If $a_1 + a_2$ is a
value that is larger than any of the values $b_1, \ldots, b_6$, then we don't
need to look for the other two undetermined values. This is because values in $a_1,
\ldots, a_4$ and in $b_1, \ldots, b_6$ are in ascending order, and
any other combination will lead to even larger values.

Let's have a look at what is the range for our initial value $x$. Obviously
trying the whole range of the integer type is not practical. The upper bound
for the range is easy to determine though, it's the largest value in the input.
The lower bound can be taken as the minimum of the differences of the pairs
made of the input values.\marginpar{Can you see why?}

<<Pairsumonious Numbers>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.BitSet;
import java.util.List;
import java.util.stream.Collectors;

public class PairsumoniousNumbers {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    private final static int[] IMPOSSIBLE = new int[0];

    private enum Result {
        success, failure, overflow
    };

    private final int n;
    private final int[] v;
    private final BitSet excluded;

    public int[] getSolution() {
        int[] partialResult = new int[n];

        int[] bounds = new int[] { Integer.MAX_VALUE, v[v.length - 1] };
        for (int i = 0; i < v.length; ++i) {
            for (int j = i + 1; j < v.length; j++) {
                bounds[0] = Math.min(bounds[0], v[i] - v[j]);
            }
        }

        if (bounds[0] > bounds[1]) {
            int t = bounds[0];
            bounds[0] = bounds[1];
            bounds[1] = t;
        }

        if (bounds[1] < 0) {
            bounds[1] = 0;
        }

        for (int i = bounds[0]; i < bounds[1]; ++i) {
            partialResult = new int[n];
            partialResult[0] = i;
            int[] result = search(partialResult, 0, 0);
            if (result != IMPOSSIBLE) {
                Arrays.sort(result);
                return result;
            }
        }
        return IMPOSSIBLE;
    }

    PairsumoniousNumbers(List<Integer> input) {
        n = input.get(0);
        v = new int[input.size() - 1];
        for (int i = 1; i < input.size(); ++i) {
            v[i - 1] = input.get(i);
        }
        Arrays.sort(v);
        excluded = new BitSet(n);
    }

    private Result verify(int upTo, int[] solution) {
        excluded.clear();
        for (int i = 0; i < upTo; ++i) {
            for (int j = i + 1; j < upTo; ++j) {
                int currValue = solution[i] + solution[j];
                if (currValue > v[v.length - 1]) {
                    return Result.overflow;
                }

                int p = Arrays.binarySearch(v, currValue);
                if (p < 0) {
                    return Result.failure;
                }
                while (p > 0 && v[p] == v[p - 1]) {
                    p--;
                }
                while (p < v.length - 1 && excluded.get(p) &&
                        v[p] == v[p + 1]) {
                    p++;
                }
                if (p == v.length || excluded.get(p)) {
                    return Result.failure;
                }
                excluded.set(p);
            }
        }

        for (int i = 0; i < upTo - 1; ++i) {
            if (!excluded.get(i)) {
                return Result.failure;
            }
        }

        return Result.success;
    }

    private int[] search(int[] partialSolution, int last, int pos) {
        for (int i = pos; i < v.length; ++i) {
            partialSolution[last + 1] = v[i] - partialSolution[0];
            Result verificationResult = verify(last + 2, partialSolution);
            if (verificationResult == Result.success) {
                if (last + 1 < n - 1) {
                    int[] solution = search(partialSolution, last + 1, i + 1);
                    if (solution != IMPOSSIBLE) {
                        return solution;
                    }
                } else {
                    return partialSolution;
                }
            } else if (verificationResult == Result.overflow) {
                break;
            }
        }
        return IMPOSSIBLE;
    }

    private static String toString(int[] arr) {
        return Arrays.stream(arr).mapToObj(String::valueOf)
                .collect(Collectors.joining(" "));
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            List<Integer> input = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            int[] solution = new PairsumoniousNumbers(input).getSolution();
            System.out
                    .println(solution == IMPOSSIBLE ? "Impossible"
                            : toString(solution));
        }
    }

}

@

\section{Combinatorics}

\subsection{How Many Fibs?}

\MyHdr{10183}{B}{average}{1}{$\bigstar$}{https://uva.onlinejudge.org/external/101/10183.pdf}

This task is particularly easy in Java because of [[BigInteger]] class.

<<How Many Fibs>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.List;

public class HowManyFibs {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            List<BigInteger> range = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals("")).map(BigInteger::new)
                    .collect(toList());
            if (range.get(0).equals(BigInteger.ZERO) &&
                    range.get(1).equals(BigInteger.ZERO)) {
                break;
            }
            BigInteger fn2 = BigInteger.ZERO;
            BigInteger fn1 = BigInteger.ONE;
            BigInteger fn = fn2.add(fn1);
            long counter = 0;
            while (fn.compareTo(range.get(1)) <= 0) {
                if (fn.compareTo(range.get(0)) >= 0) {
                    counter++;
                }
                fn2 = fn1;
                fn1 = fn;
                fn = fn1.add(fn2);
            }
            System.out.println(counter);
        }
    }
}

@

\subsection{How Many Pieces of Land?}

\MyHdr{10213}{B}{average}{2}{$\bigstar$$\bigstar$$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/102/10213.pdf}

Unlike the previous task this one is much more entertaining.

Let's see if we can consider this task a graph task? Actually yes we
can\footnote{There's a brilliant video that explains exactly the same solution:
\url{https://youtu.be/K8P8uFahAgc}}. We can consider points on an ellipse and
diagonal intersections as vertices of a graph, and edges being the connecting
segments. We are asked to find the number of regions of this graph. Note that
the task asks for the maximum number of regions, which basically means no more
than two segments should cross the same point.

There's an important characteristic in the graph theory called Euler's Formula:

$$ V - E + F = 2 $$

$V$ is the number of vertices, $E$ is the number of edges, and $F$ is the
number of regions bound by the edges (this includes the outer region). This
characteristic holds for any finite connected planar graph without 
intersecting edges.

Using the Euler's Formula we can find the number of faces once we know $V$ and
$E$. That is 

$$ F = 2 - V + E $$

Let's count.  We have $n$ points on the ellipse. How many different
chords can we have? Well we can have ${n \choose 2}$ different chords.  Now we
need to find at how many points do these chords intersect. Every intersection
point is uniquely determined by two lines and every two lines are determined by
four different points on the ellipse. Simply put, this means that every
intersection point is uniquely determined by four points on the ellipse.  How
many such different intersection points are there? It's precisely ${n \choose
4}$. Because we have additional $n$ points on the ellipse the total number of
vertices of the graph is $V = n + {n \choose 4}$.

Now we have two quantities: the number of chords and the number of points at
which they intersect. This allows us to calculate the number of edges in our
graph. Notice that every intersection point breaks the segment into two peaces.
So if we take two lines and they intersect, we have four segments. If we
take three lines that intersect at three points, we get nine different
segments. Generally, if we have $m$ segments intersecting at $p$ points, then
we end up with $m + 2p$ segments. (Note that this is only true if no more than
two lines intersect at each point.) This in turn means that our graph will have
$E = {n \choose 2} + 2{n \choose 4} + n$ edges; additional $n$ because of the
ellipse's segments are part of the graph too.

Now we just plug these value into the formula:

$$ F = 2 - n - {n \choose 4} + {n \choose 2} + 2{n \choose 4} + n $$

which is the same as:

$$ F = 2 + {n \choose 2} + {n \choose 4} $$

This formula counts in the outer region too, but in our tasks it's not counted,
so we just reduce it by one. The final formula is:

$$ F = 1 + {n \choose 2} + {n \choose 4} $$

This translates into Java code extremely easily:

<<How Many Pieces of Land>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;

public class HowManyPiecesOfLand {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static BigInteger calculate(BigInteger v) {
        BigInteger t1 = v.multiply(v.subtract(BigInteger.ONE))
                .divide(BigInteger.valueOf(2));
        BigInteger t2 = v.multiply(v.subtract(BigInteger.ONE))
                .multiply(v.subtract(BigInteger.valueOf(2)))
                .multiply(v.subtract(BigInteger.valueOf(3)))
                .divide(BigInteger.valueOf(4 * 3 * 2));
        return BigInteger.ONE.add(t2).add(t1);
    }

    public static void main(String[] args)
            throws NumberFormatException, IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            System.out.println(
                    calculate(new BigInteger(reader.readLine().trim())));
        }
    }
}

@

\subsection{Counting}

\MyHdr{10198}{B}{high}{2}{$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/101/10198.pdf}

There's always one easy case: that's when the number of $1$s matches $n$, so
their sum matches $n$. But now we can start constructing other cases. If we
remove three 1s from it and replace by $3$ they would still add up to $n$.
Similarly, if we remove two $1$s and replace by $2$ they would still add up to
$n$. Now, once we removed two or three $1$s we end up with strings of ones of
length $n-2$ or $n-3$ to which we can do the same operation recursively. This
suggests a recursive formula:

$$ T(n) = T(n-2) + T(n-3) $$

But $4$ and $1$ should be counted as $1$ according to the problem statement. We
can think about this in a similar manner, if we have $n$ 1s we can take out one
and replace by 4, so it's an additional $T(n-1)$ term in into the recursive
formula above. But since $1$ and $4$ are the same we also must take into
account a symmetric case where the first $n-1$ ones are replaced by $n-1$
fours, so that's a yet additional $T(n-1)$ term. The final formula is:

$$ T(n) = T(n-2) + T(n-3) + 2T(n-1)$$

This value grows very quickly, so we will be using [[BigInteger]] class. We
will also implement it in a iterative manner rather than recursive function
calls.

<<Counting>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;

public class Counting {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static BigInteger count(int n) {
        final BigInteger two = BigInteger.valueOf(2);
        if (n == 1) {
            return two;
        } else if (n == 0) {
            return BigInteger.ONE;
        } else if (n < 0) {
            return BigInteger.ZERO;
        }

        BigInteger[] prev = new BigInteger[] { BigInteger.ZERO, BigInteger.ONE,
                two };

        for (int i = 1; i < n; ++i) {
            BigInteger next = prev[2].multiply(two).add(prev[1]).add(prev[0]);
            prev[0] = prev[1];
            prev[1] = prev[2];
            prev[2] = next;
        }

        return prev[2];
    }

    public static void main(String[] args)
            throws NumberFormatException, IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            System.out.println(count(Integer.parseInt(currentLine.trim())));
        }
    }
}

@

\subsection{Expressions}

\MyHdr{10157}{C}{average}{2}{$\bigstar$$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/101/10157.pdf}

It's an interesting task! To solve it let's have a look at the recurrence
formula of the Catalan numbers. As the textbook explains it's constructed in
this way: The proper string of parentheses starts with a single left
parenthesis and is matched by some right parenthesis. This divides the word
into two parts both of which are properly constructed. In other words any
properly balanced string of parentheses can always be represented as
$w=(w_1)w_2$ where both $w_1$ and $w_2$ are proper strings of parentheses,
possibly of zero length; hence the recursive formula. 

Notice that $w_1$ is in the parenthesis in $w=(w_1)w_2$, so the depth of
$(w_1)$ is at least 1. We can keep track of the depth of recursion and stop as
long as we reach the required depth:

$$ C[n,d]=\sum _{i=0}^{n-1}C[i,d-1]C[n-1-i,d] $$ 

and

$$ C[n,d]=1 \quad \textnormal{if}\ n=0\ \textnormal{or}\ d=1 $$

Here $n$ is the number of pairs of parentheses, $d$ is the required depth.

The formula above returns all the strings with the depths of up to $d$. To get
all the proper strings of parentheses of depth $d$ we simply need to subtract
all the strings of depth up to $d-1$. So the final formula is 

$$ F[m,d] = C[m/2,d]-C[m/2,d-1] $$

Here $m$ is the length of a string as specified in the problem statement. We
divide by two as the length should always be an even number because each opening
parenthesis must have a closing parenthesis. If the number is odd, 
we will return 0.

Of course we need memoization in the implementation which is trivial in this
case.

<<Expressions>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.List;

public class Expressions {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    private static final BigInteger[][] memo = new BigInteger[151][151];

    public static BigInteger c(int n, int d) {
        if (d == 1 || n == 0) {
            return BigInteger.ONE;
        }

        if (memo[n][d] != null) {
            return memo[n][d];
        }

        BigInteger v = BigInteger.ZERO;
        for (int i = 0; i <= n - 1; ++i) {
            BigInteger v1 = c(i, d - 1);
            BigInteger v2 = c(n - i - 1, d);
            v = v1.multiply(v2).add(v);
        }

        memo[n][d] = v;
        return v;
    }

    public static BigInteger solve(int n, int d) {
        if (n % 2 != 0) {
            return BigInteger.ZERO;
        }
        for (int i = 0; i < memo.length; ++i) {
            Arrays.fill(memo[i], null);
        }
        return c(n / 2, d).subtract(c(n / 2, d - 1));
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().isEmpty()) {
            List<Integer> input = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            System.out.println(solve(input.get(0), input.get(1)));
        }
    }
}

@

\subsection{Complete Tree Labeling}

\MyHdr{10247}{C}{average}{2}{$\bigstar$$\bigstar$$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/102/10247.pdf}

Let's look at a simple case, a tree of degree $k$ of depth 1. In this case there
are $k+1$ nodes: the root and $k$ children. We have a list of labels in
ascending order. To preserve the heap structure we need to take the minimum
element from the list of labels as the root. Then we have $k!$ ways to
arrange the children using the remaining labels. This is going to be our base
case for the recursion.

Let's define $f(b, s, k, h)$ as a function that returns the number of ways a
$k$-ary tree can be labeled. Here $b$ is the base value (that is $k!$), $s$ is
the number of nodes in the $k$-ary tree, $k$ is, obviously, the degree of the
tree, and $h$ is the height of the tree.

The total number of nodes in a $k$-ary tree of height $h$ is $$n(k, h) =
\frac{k^{h+1}-1}{k-1}$$ Let's say we are at depth $1$ in the $k$-ary tree. At
this level there are $k$ subtrees each having $n(k, h-1) = (n(k, h)-1)/ k$
nodes. In how many ways can we choose the labels from the list of labels for
this subtree? For the first subtree we can choose labels in $$n(k, h)-1-1
\choose n(k, h-1)-1$$ ways. One -1 is because of the parent node, and another -1
is because of the root of the subtree. For the second subtree we can now choose
labels in $$n(k, h)-1-1-n(k, h-1) \choose n(k, h-1)-1$$ ways, and so on for the
other subtrees. Remember that all this can be rearranged in $k!$ ways and that
each subtree can be labeled in $f(b, n(k, h-1), k, h-1)$ ways. Multiplying all
these together gives us the answer.

<<Complete Tree Labeling>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

class CompleteTreeLabeling {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static List<BigInteger> expand(int n, int upto) {
        List<BigInteger> res = new ArrayList<BigInteger>();
        for (int i = n; i > upto; --i) {
            res.add(BigInteger.valueOf(i));
        }
        return res;
    }

    private static BigInteger mult(List<BigInteger> l) {
        return l.stream().reduce(BigInteger.ONE, (x, y) -> x.multiply(y));
    }

    private static BigInteger choose(int n, int k) {
        List<BigInteger> numerator = expand(n, (n - k));
        List<BigInteger> denominator = expand(k, 0);
        Iterator<BigInteger> it = denominator.iterator();
        while (it.hasNext()) {
            if (numerator.remove(it.next())) {
                it.remove();
            }
        }
        return mult(numerator).divide(mult(denominator));
    }

    private static BigInteger count(BigInteger base, int treeSize, int k,
            int h) {
        if (h == 1) {
            return base;
        }
        int subtreeSize = (treeSize - 1) / k;
        BigInteger subtreeCount = count(base, subtreeSize, k, h - 1);
        BigInteger count = base;
        for (int i = subtreeSize - 1; i <= treeSize - 2; i += subtreeSize) {
            count = count.multiply(subtreeCount)
                    .multiply(choose(i, subtreeSize - 1));
        }
        return count;
    }

    private static BigInteger solve(int k, int h) {
        if (k == 1) {
            return BigInteger.ONE;
        }
        int pow = 1;
        for (int i = 0; i < h + 1; ++i) {
            pow *= k;
        }
        return count(mult(expand(k, 0)), (pow - 1) / (k - 1), k, h);
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            List<Integer> input = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            System.out.println(solve(input.get(0), input.get(1)));
        }
    }
}

@

\subsection{The Priest Mathematicians}

\MyHdr{10254}{C}{high}{2}{$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/102/10254.pdf}

We know that the answer to the classic Hanoi Towers task is $T(n)=2^n-1$.
However, in this task it's slightly modified where we have an option to use the
four pegs instead of three, as described in the problem statement.

It's really easy to come up with a recursive formula:

$$ A(n) = min \{ 2^{n-k}-1 + 2A(k) : k \in (1, n) \} $$

This is because first we use four pegs to move $k$ discs on to the intermediate
peg, then use the classic algorithm using the three pegs, finally use four pegs
to move $k$ discs again. We try all such $k \in (1, n)$ and find the minimum value.

This formula coded as is would give the right answer, but it will be very slow.
Still, it's very useful to have a look at the first few values: 


\begin{tabular}{ l | l | l }
\hline
k & n & A(n) \\
\hline
1 & 2 & 3 \\ 
1 & 3 & 5 \\
1 & 4 & 9 \\
2 & 5 & 13 \\ 
3 & 6 & 17 \\
3 & 7 & 25 \\
4 & 8 & 33 \\
5 & 9 & 41 \\
\hline
\end{tabular}


The first column is the $k$ that lead to the minimal A(n). As you may have
noticed it grows monotonically. This suggests how to construct the values
iteratively: We simply calculate the value with the current $k$ and $k+1$, and
if $k+1$ gives a better answer we accept it and advance $k$. This way we 
calculate all the values for each $n \in (1, 10000)$. Then we simply look up
the answer in the table.

<<The Priest Mathematician>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;

class ThePriestMathematician {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    private static final BigInteger TWO = BigInteger.valueOf(2);
    private static final BigInteger ONE = BigInteger.ONE;
    private static final BigInteger ZERO = BigInteger.ZERO;

    public static BigInteger[] generate() {
        BigInteger[] hanoi = new BigInteger[10001];
        hanoi[0] = ZERO;
        hanoi[1] = ONE;
        for (int i = 2, k = 1; i <= 10000; ++i) {
            BigInteger n1 = TWO.pow(i - k).subtract(ONE)
                    .add(hanoi[k].multiply(TWO));
            BigInteger n2 = hanoi[k + 1] != null ? TWO.pow(i - (k + 1))
                    .subtract(ONE).add(hanoi[k + 1].multiply(TWO))
                    : null;
            if (n2 != null && n2.compareTo(n1) == -1) {
                k++;
                hanoi[i] = n2;
            } else {
                hanoi[i] = n1;
            }
        }
        return hanoi;
    }

    public static void main(String[] args) throws IOException {
        BigInteger[] hanoi = generate();
        String currentLine = null;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().equals("")) {
            System.out.println(hanoi[Integer.parseInt(currentLine.trim())]);
        }
    }
}

@

\subsection{Self-Describing Sequence}

\MyHdr{10049}{C}{high}{2}{$\bigstar$$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/100/10049.pdf}

To solve this task we don't even need to come up with a recursive formula. We
can simply generate the sequence and then lookup the required value. The trick
however is to make the sequence compact. Instead of writing out each member of
the sequence we just generate a list of ranges. Indexes of the elements in 
this list of ranges are the sequence values. 

For example, instead of having $1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6$
etc we represent it as $(1, 1)_1, (2, 3)_2, (4, 5)_3, (6, 8)_4, (9, 11)_5, (12,
15)_6$ etc. Then, to get the value of $a(n)$, we use binary search to find the
range into which $n$ falls. Once we know the range, we simply return its index.
For instance, $a(5)=3$, because $5 \in (4, 5)_3$, and therefore $a(5)=3$. 

<<Self Describing Sequence>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class SelfDescribingSequence {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private List<Tuple> seq = new ArrayList<>();
    private static final long limit = 2_000_000_000L;

    SelfDescribingSequence() {
        seq.add(new Tuple(1, 1));
        seq.add(new Tuple(2, 3));
        seq.add(new Tuple(4, 5));
        int tupleIndex = 2;
        boolean cont = true;
        do {
            Tuple currTuple = seq.get(tupleIndex);
            for (long i = currTuple.v1; i <= currTuple.v2; ++i) {
                Tuple lastTuple = seq.get(seq.size() - 1);
                if (lastTuple.v1 >= limit) {
                    cont = false;
                    break;
                }
                seq.add(new Tuple(lastTuple.v2 + 1, lastTuple.v2 + tupleIndex + 1));
            }
            tupleIndex++;
        } while (cont);
    }

    static class Tuple {
        private long v1;
        private long v2;

        public Tuple(long v1, long v2) {
            this.v1 = v1;
            this.v2 = v2;
        }
    }

    public long get(long n) {
        int i = Collections.binarySearch(seq, new Tuple(n + 1, 0),
                (x, y) -> Long.compare(x.v1, y.v1));
        if (i < 0) {
            i = Math.abs(i + 1);
        }
        return i;
    }

    public static void main(String[] args) throws IOException {
        SelfDescribingSequence g = new SelfDescribingSequence();
        String currentLine;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().equalsIgnoreCase("")) {
            long n = Long.parseLong(currentLine.trim());
            if (n == 0) {
                break;
            }
            System.out.println(g.get(n));
        }
    }
}

@

\subsection{Steps}

\MyHdr{10049}{A}{high}{2}{$\bigstar$$\bigstar$$\bigstar$}{https://uva.onlinejudge.org/external/100/10049.pdf}

The problem statement says that the length of the next step can be either the
same or by one bigger or by one smaller as the previous one. Since this
sequence always increases by one it's a simple arithmetic series. The sum of
such series is $s(n) = \frac{n(1 + a_n)}{2}$. We need to find $n$ such that $x
+ s(n) \leq y$ and $x + s(n+1) > y$, here $x$ and $y$ as described in the
problem statement. But we know that the first and the last steps must be of
length 1, so we must have another arithmetic series to go down back to step of
length 1. Therefore, we need to find $n$ such that $x + 2s(n) \leq y$, and
$x + 2s(n+1) > y$. Because $a_n = n$, $s(n) = \frac{n(1+n)}{2}$, so we are
looking for an $n$ such that $x + n(1+n) \leq y$ and  $x + (n+1)(n+2) > y$, 
or, equivalently, $n(1+n) \leq y - x$ and $(n+1)(n+2) > y - x$.

Once we found such an $n$, we know that the number of steps is $2n$. But we
need to try two cases to finalize the answer. First, if $n(1+n) < y - x$, that
is strictly less, we need to try to add more steps. We know that at some point
we reach the step of length $n$, so we should try inserting additional $n$ and
checking if we are still less than $y-x$. If not, keep adding. Adding $n$ is
allowed, because a new step can be of the same length as the previous one. If
adding another $n$ gets us above $y-x$, we need to try $n-1$ and so on down to
$1$. This will give us the optimal number of steps.

We also need to check another case: $(n+1)(n+2) > y - x$. In this case we
need to remove steps to get us to $y-x$. We can safely remove steps in pairs.
Let's image our steps are as follows $1, 2, 3, 4, 4, 3, 2, 1$. We can remove 4
without breaking the rules. Then we can remove 4 again. Then 3, and then 3 one
more time and so on. Basically we remove them in pairs. We keep removing until
it gets us at or below $y-x$. Once we are there we are done. If we are below,
we can still apply the procedure from the first case to align with $y-x$. 

Now from those two cases we take the one that gives the smaller number of
steps.

<<Steps>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;

class Steps {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static long getLength(long limit) {
        long n = 1;
        while (n * (1 + n) <= limit) {
            n++;
        }
        if (n * (1 + n) > limit) {
            n--;
        }
        return n;
    }

    public static long getSteps(long n, long limit) {
        long sum = n * (1 + n);
        long steps = n * 2;
        long i = n;
        short j = 0;

        while (sum > limit) {
            sum -= i;
            steps--;
            if (j == 1) {
                j = 0;
                i--;
            }
            j++;
        }

        while (sum < limit) {
            while (sum + i <= limit) {
                sum += i;
                steps++;
            }
            if (i > 1) {
                i--;
            }
        }
        return steps;
    }

    public static long solve(long x, long y) {
        long limit = y - x;
        if (limit <= 1) {
            return limit;
        }
        long len = getLength(limit);
        return Math.min(getSteps(len, limit), getSteps(len + 1, limit));
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            List<Integer> input = stream(reader.readLine().trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            System.out.println(solve(input.get(0), input.get(1)));
        }
    }
}

@

\section{Number Theory}

\subsection{Light, More Light}

With this tasks we are basically asked to find the number of divisors of the
given number. Once we know the number of divisors, we can figure out the last
bulb state by checking if the number of the divisors is even or odd.

Let's sort out the input/output first as usual. We assume that we have
[[calculate]] method that returns the number of divisors for a given number.

<<Light, More Light>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
<<7.1 Imports>>

class LightMoreLight {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    <<7.1 Variables>>

    LightMoreLight() {
        <<7.1 Constructor>>
    }

    public long calculate(long value) {
        <<7.1 Implementation>>
    }

    public static void main(String[] args) throws IOException {
        LightMoreLight l = new LightMoreLight();
        String currentLine;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().equals("0")) {
            long value = Long.parseLong(currentLine.trim());
            System.out.println(l.calculate(value) % 2 == 0 ? "no" : "yes");
        }
    }
}
@

OK, to figure out the number of divisors we will use the fundamental theorem of
arithmetic. This theorem states that: Every integer greater than one either is
prime itself or is the product of prime numbers, and that this product is
unique, up to the order of the factors. To find the prime factorization we can
use a straightforward algorithm: simply by dividing a number by the primes
less that the number itself, trying them one by one.

Since we need to know the prime numbers, let's pre-calculate them first in the
constructor. We won't need primes larger than $\sqrt{2^{32}-1}$, but we'll define
a constant [[MAX_PRIMES]] a bit larger than that. We will use a classic algorithm
for finding prime numbers, the sieve of Eratosthenes algorithm (see \cite{SE}).

<<7.1 Imports>>=
import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;
@

<<7.1 Variables>>=
private final List<Long> primes;
private final static int MAX_PRIMES = 70000;
@

<<7.1 Constructor>>=
BitSet bits = new BitSet(MAX_PRIMES);
for (int i = 2; i < Math.sqrt(MAX_PRIMES); ++i) {
    if (!bits.get(i)) {
        int k = 0;
        int ii = i * i;
        int j = ii + k * i;
        while (j < MAX_PRIMES) {
            bits.set(j);
            k++;
            j = ii + k * i;
        }
    }
}
primes = new ArrayList<Long>();
for (int i = 2; i < bits.length(); ++i) {
    if (!bits.get(i)) {
        primes.add((long) i);
    }
}
@

Now the interesting part: In fact we don't need the prime numbers of the
factorization, we only need their exponents to find out the number of divisors.

To see why, consider a number of the form $v = p_1^n$. The divisors of this
number are $1, p_1, p_1^2, p_1^3, \ldots, p_1^n$; therefore the number of the
divisors is $n+1$.  

\begin{table}
\begin{center}
\begin{tabular}{lllll}
1     & $p_1$     & $p_1^2$      & ... & $p_1^n$  \\
$p_2$ & $p_1p_2$  & $p_1^2p_2$   & ... & $p_1^np_2$   \\
$p_2^2$ & $p_1p_2^2$  & $p_1^2p_2^2$ & ... & $p_1^np_2^2$   \\
...   & ...       &     ...    & ... & ...   \\
$p_2^m$ & $p_1p_2^m$  &     ...      &  ... & $p_1^np_2^m$
\end{tabular}
\caption{Divisors}
\end{center}
\label{table:divisors}
\end{table}

Consider a number of the form $v = p_1^np_2^m$. (See table).

Therefore the number of its divisors is $(n+1)(m+1)$.

Generally the number of the divisors for a number $v = p_1^{n_1}p_2^{n_2} \cdots
p_k^{n_m}$ is $(n_1+1)(n_2+1)\cdots(n_m+1)$.

<<7.1 Implementation>>=
List<Long> factors = new ArrayList<Long>();
for (int i = 0; i < primes.size() && value > 1 &&
        (primes.get(i) * primes.get(i)) <= value; ++i) {
    long p = 0;
    while (value % primes.get(i) == 0) {
        value /= primes.get(i);
        p++;
    }
    if (p > 0) {
        factors.add(p);
    }
}
if (value > 1) {
    factors.add(1L);
}
return factors.stream().map(x -> x + 1).reduce(1L, (a, b) -> a * b);
@

This concludes the program.

\subsection{Carmichael Numbers}

To solve this task we need two algorithms: the sieve of Eratosthenes (see
\cite{SE}) and a fast modular exponentiation (specifically, right-to-left
binary method, see \cite{ME}).  BigInteger's modPow would do too, but it will
be slower than a handcrafted one.  I've tried BigInteger.modPow and the judge
accepted my solution with 2.5s execution time. Handcrafted [[modPow]] though is
considerably faster and the judge accepted my program with 560ms execution
time.

<<Carmichael Numbers>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.BitSet;

class CarmichaelNumbers {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private final int[] primes;
    private final static int MAX_PRIMES = 66000;

    CarmichaelNumbers() {
        BitSet bits = new BitSet(MAX_PRIMES);
        for (int i = 2; i < Math.sqrt(MAX_PRIMES); ++i) {
            if (!bits.get(i)) {
                int k = 0;
                int ii = i * i;
                int j = ii + k * i;
                while (j < MAX_PRIMES) {
                    bits.set(j);
                    k++;
                    j = ii + k * i;
                }
            }
        }

        int size = 0;
        for (int i = 2; i < bits.length(); ++i) {
            if (!bits.get(i)) {
                size++;
            }
        }

        int j = 0;
        primes = new int[size];
        for (int i = 2; i < bits.length(); ++i) {
            if (!bits.get(i)) {
                primes[j++] = i;
            }
        }
    }

    public long modPow(long b, long e, long m) {
        if (m == 1) {
            return 0;
        }

        long result = 1;
        b = b % m;
        while (e > 0) {
            if (e % 2 == 1) {
                result = (result * b) % m;
            }
            e = e >> 1;
            b = (b * b) % m;
        }
        return result;
    }

    public boolean isCarmichael(int n) {
        if (Arrays.binarySearch(primes, n) >= 0) {
            return false;
        }

        for (int i = 2; i < n; ++i) {
            if (modPow(i, n, n) != i) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) throws IOException {
        CarmichaelNumbers n = new CarmichaelNumbers();
        String currentLine = null;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().equals("")) {
            int v = Integer.parseInt(currentLine.trim());
            if (v == 0) {
                break;
            }
            if (n.isCarmichael(v)) {
                System.out.println(
                        "The number " + v + " is a Carmichael number.");
            } else {
                System.out.println(v + " is normal.");
            }
        }
    }
}

@

\subsection{Euclid Problem}

We just need to use the Extended Euclid Algorithm. The algorithm below is a
direct translation of the pseudocode from \cite{EEA}.

<<Euclid Problem>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

class EuclidProblem {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static long[] euclid(long a, long b) {
        long s = 0;
        long old_s = 1;
        long t = 1;
        long old_t = 0;
        long r = b;
        long old_r = a;
        while (r != 0) {
            long quotient = old_r / r;
            long p = r;
            r = old_r - quotient * r;
            old_r = p;
            p = s;
            s = old_s - quotient * s;
            old_s = p;
            p = t;
            t = old_t - quotient * t;
            old_t = p;
        }
        return new long[] { old_s, old_t, old_r };
    }

    public static String toString(long[] arr) {
        return Arrays.stream(arr).mapToObj(String::valueOf)
                .collect(Collectors.joining(" "));
    }

    public static void main(String[] args) throws IOException {
        String currentLine = null;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().equals("")) {
            List<Integer> input = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            System.out.println(toString(euclid(input.get(0), input.get(1))));
        }
    }
}

@

\subsection{Factovisors}

Obviously any number $m \leq n$ divides $n!$. That's an easy case. If $m > n$,
however, we obtain the unique prime factorization of $m=p_1^{k_1}p_2^{k_2} \cdots
p_n^{k_n}$. For each $p_i^{k_i}$ we count how many values $v \in [1, n]$ are there
such that $p_i$ divides $v$. There should be at least $k_i$ such values. We
check that this holds for every $p_i$ from the unique prime factorization. If
it doesn't, then $m$ does not divide $n!$.

<<Factovisors>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;

class Factovisors {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static boolean check(int n, int p, int k) {
        for (int i = p; i <= n && k > 0; i += p) {
            int m = i;
            while (m % p == 0) {
                m /= p;
                k--;
            }
        }
        return k <= 0;
    }

    public static boolean solve(int n, int m) {
        n = (n == 0) ? 1 : n;
        m = (m == 0) ? 1 : m;
        if (n >= m) {
            return true;
        }
        int k = 0;
        while (m % 2 == 0) {
            m /= 2;
            k++;
        }
        if (!check(n, 2, k)) {
            return false;
        }
        for (int i = 3; i <= Math.sqrt(m); i += 2) {
            k = 0;
            while (m % i == 0) {
                m /= i;
                k++;
            }
            if (!check(n, i, k)) {
                return false;
            }
        }
        return m <= n;
    }

    public static void main(String[] args) throws IOException {
        String currentLine = null;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().equals("")) {
            List<Integer> input = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            boolean solution = solve(input.get(0), input.get(1));
            System.out.println(input.get(1) +
                    (solution ? " divides " : " does not divide ") +
                    input.get(0) + "!");
        }
    }
}

@

\subsection{Summation of Four Primes}

It's an easy task. We simply generate all the primes less than 10000000 using
the Sieve of Eratosthenes. Once we have all these primes we can find the
required sums by a simple search.

<<Summation of Four Primes>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

class SummationOfFourPrimes {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    private final List<Integer> primes;
    private final static int MAX_PRIMES = 10_000_000;

    SummationOfFourPrimes() {
        BitSet bits = new BitSet(MAX_PRIMES);
        for (int i = 2; i < Math.sqrt(MAX_PRIMES); ++i) {
            if (!bits.get(i)) {
                int k = 0;
                int ii = i * i;
                int j = ii + k * i;
                while (j < MAX_PRIMES) {
                    bits.set(j);
                    k++;
                    j = ii + k * i;
                }
            }
        }
        primes = new ArrayList<>();
        for (int i = 2; i < bits.length(); ++i) {
            if (!bits.get(i)) {
                primes.add(i);
            }
        }
    }

    public int[] find(int a, int c, int[] current) {
        if (a == 0 && c == -1) {
            return current;
        } else if (a < 0 || c == -1) {
            return null;
        }
        int startIndex = Collections.binarySearch(primes, a);
        startIndex = (startIndex < 0) ? Math.abs(startIndex + 1) : startIndex;
        startIndex = primes.size() - 1 >= startIndex ? startIndex
                : primes.size() - 1;
        for (int i = startIndex; i >= 0; --i) {
            current[c] = primes.get(i);
            int[] result = find(a - primes.get(i), c - 1, current);
            if (result != null) {
                return result;
            }
        }
        return null;
    }

    public static String toString(int[] arr) {
        return Arrays.stream(arr).mapToObj(String::valueOf)
                .collect(Collectors.joining(" "));
    }

    public static void main(String[] args) throws IOException {
        SummationOfFourPrimes n = new SummationOfFourPrimes();
        String currentLine = null;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().equals("")) {
            int[] res = n.find(Integer.parseInt(currentLine.trim()), 3,
                    new int[4]);
            System.out.println(res != null ? toString(res) : "Impossible.");
        }
    }
}

@

\subsection{Smith Numbers}

To solve this task it will suffice to do the checks without doing anything very
complicated.

<<Smith Numbers>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

class SmithNumbers {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static int digitsSum(int value) {
        int sum = 0;
        while (value > 9) {
            sum += (value % 10);
            value /= 10;
        }
        return sum + value;
    }

    public static List<Integer> factor(int m) {
        List<Integer> factors = new ArrayList<>();
        if (m <= 2) {
            factors.add(m);
            return factors;
        }
        while (m % 2 == 0) {
            m /= 2;
            factors.add(2);
        }
        for (int i = 3; i <= Math.sqrt(m); i += 2) {
            while (m % i == 0) {
                m /= i;
                factors.add(i);
            }
        }
        if (m > 1) {
            factors.add(m);
        }
        return factors;
    }

    public static int find(int m) {
        int i = m + 1;
        while (true) {
            List<Integer> factors = factor(i);
            if (factors.size() > 1) {
                if (factors.stream().map(SmithNumbers::digitsSum).reduce(Integer::sum)
                        .get() == digitsSum(i)) {
                    return i;
                }
            }
            ++i;
        }
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            int v = Integer.parseInt(reader.readLine().trim());
            System.out.println(find(v));
        }
    }
}

@

\subsection{Marbles}

This task is a paraphrased linear Diophantine equation. We need to solve $ax +
by = n$, where $n_1=a$, $n_2=b$ and $n$ are as stated in the problem. Solving
such an equation is easy and a thorough explanation on how to do this can be found
in \cite{ENT}. Once we've found the general solution, we limit ourselves to the
positive solutions only by having $x = x_0 + i\frac{b}{d} > 0$ and $y = y_0 -
i\frac{a}{d} > 0$, here $d = gcd(a, b)$; equivalently, $$-\frac{x_0}{b} <
i < \frac{y_0}{a}$$ Then, because we have a requirement to find the solution
that gives the smallest cost, we check the solutions on both ends of
that range and choose the one that is smaller.

<<Marbles>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;

class Marbles {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static long[] euclid(long a, long b) {
        long s = 0;
        long old_s = 1;
        long t = 1;
        long old_t = 0;
        long r = b;
        long old_r = a;
        while (r != 0) {
            long quotient = old_r / r;
            long p = r;
            r = old_r - quotient * r;
            old_r = p;
            p = s;
            s = old_s - quotient * s;
            old_s = p;
            p = t;
            t = old_t - quotient * t;
            old_t = p;
        }
        return new long[] { old_s, old_t, old_r };
    }

    public static long[] diophant(long a, long b, long c) {
        long[] bezouts = euclid(a, b);
        if (c % bezouts[2] != 0) {
            return null;
        }
        long e = c / bezouts[2];
        return new long[] { e * bezouts[0], b / bezouts[2], e * bezouts[1],
                -a / bezouts[2] };
    }

    public static long[] min(long c1, long c2, long[] solution, long start,
            long end) {
        long[] min = new long[] { Long.MAX_VALUE, 0, 0 };
        for (long i = start; i <= end; ++i) {
            long x = solution[0] + i * solution[1];
            long y = solution[2] + i * solution[3];
            if (x < 0 || y < 0) {
                continue;
            }
            long cost = c1 * x + c2 * y;
            if (cost < min[0]) {
                min[0] = cost;
                min[1] = x;
                min[2] = y;
            }
        }
        return min;
    }

    public static long[] solve(long c1, long n1, long c2, long n2, long n) {
        long[] solution = diophant(n1, n2, n);
        if (solution == null) {
            return null;
        }
        long left = -(solution[0] / solution[1]);
        long right = (solution[2] / -solution[3]);
        long[] minLeft = min(c1, c2, solution, left, left + 1);
        long[] minRight = min(c1, c2, solution, right - 1, right);
        long[] min = minLeft[0] < minRight[0] ? minLeft : minRight;
        return min[0] < Long.MAX_VALUE ? min : null;
    }

    public static List<Long> parse(String line) {
        return stream(line.trim().split(" "))
                .filter(x -> !x.equals(""))
                .map(Long::parseLong)
                .collect(toList());
    }

    public static void main(String[] args) throws IOException {
        String currentLine = null;
        while ((currentLine = reader.readLine()) != null) {
            long c = Long.parseLong(currentLine);
            if (c == 0) {
                break;
            }
            List<Long> cn1 = parse(reader.readLine());
            List<Long> cn2 = parse(reader.readLine());
            long[] solution = solve(cn1.get(0), cn1.get(1), cn2.get(0),
                    cn2.get(1), c);
            System.out
                    .println(solution == null ? "failed"
                            : solution[1] + " " + solution[2]);
        }

    }
}

@
\subsection{Repackaging}

TBD.

\section{Backtracking}

\subsection{Little Bishops}

First, there's a caveat with this task. The program below is absolutely correct
and fast. The online judge, however, was rejecting my initial implementation
with a timeout. On my machine (a laptop) it ran all possible test cases in less
than 100 milliseconds, so I was not sure why the judge didn't like it. Because
the variations of the input aren't massive, I decided to make a lookup table
with precomputed results. This time the judge accepted the solution. So,
apparently, the judge runs some test cases multiple times and if we don't cache
the results we will run out of time. Probably it's a good idea to cache the
results wherenever possible on these backtracking tasks.

OK, so how to actually solve this? It's very similar to the eight queens
problem. We should note that once we placed a bishop on a diagonal, no other
bishops should be placed on that diagonal because obviously they will attack
each other. This observation would allow us to write a considerably faster
program than the naive approach but still would be unacceptably slow. We can
speed up things by noting that if a bishop is on a black diagonal it won't
attack any bishop on any white diagonal. We can get the number of placements by
dividing the bishops into two groups: those that are on the black diagonals and
those that are on the white diagonals. 

Let's say we have $k$ bishops and $i$ bishops will be used on the black diagonals
only, and $k-i$ bishops will be used on the white diagonals. Let's say $T_b(i)$
is the number of placements of $i$ bishops on the black diagonals. Similarly,
let's say $T_w(k-i)$ is the number of placements of $k-i$ bishops on the white
diagonals. Then the number of combinations of $k$ bishops where exactly $i$
bishops are on the black diagonals and exactly $k-i$ bishops are on the white
diagonals and none of them attack each other is $T_b(i) \times T_w(k-i)$.
Therefore, to get the number of all possible placements we need to get a sum: 

$$  T(k) = \sum_{i=1}^{k} (T_w(i)T_b(k-i)) + T_w(k) + T_b(k) $$

$T_w(k)$ and $T_b(k)$ are for the cases when all $k$ bishops are on the black
diagonals and all $k$ bishops are on the white diagonals.

In the constructor we will do the calculation as described above. The
[[getCount]] method takes [[s]], the start diagonal, which is either 0 or 1,
and [[k]], which is the number of bishops. The results of this method is the
number of placements of $k$ bishops on a board of size $n$, but only one the
squares of the specific color. We can assume 0 means black squares and 1 means
white squares (or vice versa, it doesn't matter).

At the same time we do a little optimization here. If it's not possible to
place $i$ (out of $k$) bishops on the black squares, then we don't even try to
place the $k-i$ bishops on the white squares.

<<Little Bishops>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

class LittleBishops {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private final int[][] attack;
    private final int n;
    private final int totalCount;

    public LittleBishops(int n, int k) {
        this.attack = new int[n][n];
        this.n = n;
        if (k > 0) {
            int total = 0;
            for (int i = 1; i < k; ++i) {
                int v = getCount(0, i);
                if (v > 0) {
                    total += v * getCount(1, k - i);
                }
            }
            this.totalCount = total + getCount(0, k) + getCount(1, k);
        } else {
            this.totalCount = 1;
        }
    }

    private int getCount(int s, int k) {
        AtomicInteger counter = new AtomicInteger(0);
        count(s, k, counter);
        return counter.get();
    }

    private void attack(int i, int j, int d) {
        while (i + 1 < n && j + 1 < n) {
            attack[++i][++j] += d;
        }
    }

    public void count(int s, int k, AtomicInteger counter) {
        <<8.1 Backtrack>>
    }

    public static void main(String[] args) throws IOException {
        int[][] memo = new int[9][65];
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 65; ++j) {
                memo[i][j] = -1;
            }
        }

        String currentLine = null;
        while ((currentLine = reader.readLine()) != null) {
            List<Integer> input = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals("")).map(Integer::parseInt)
                    .collect(toList());
            if (input.get(0) == 0 && input.get(1) == 0) {
                break;
            }
            int i = input.get(0);
            int j = input.get(1);
            if (memo[i][j] == -1) {
                LittleBishops s = new LittleBishops(i, j);
                memo[i][j] = s.totalCount;
            }
            System.out.println(memo[i][j]);
        }
    }
}

@

A $n$-sized board has $2n-1$ diagonals. The search will try each diagonal (of
the same color) one by one and try to place exactly one bishop on the diagonal
in one of the squares of it. We will assume the squares of the given board are
enumerated from 0 to $n^2-1$, from the upper left to the right and down.  
For $i$-th diagonal we need to find the index of the initial square, this is
saved in the [[ii]] variable. When $i < n$, the index of the initial square is
simply $i$. If $i \geq n$ then the initial index of the squares will be
$n(i-n+2)-1$.

The number of the squares in $i$-th diagonal is determined by the
[[squares]] variable. If $i < n$ the number of the squares equals $i+1$ (plus
one because we count diagonal from 0). When $i \geq n$ then the number of the
squares will be $2n-i-1$. We iterate on these squares in a diagonal by simply
adding $n-1$ to the current index. 

The array [[attack]] holds the number of attackers for each square. So if a
corresponding element in the array is non-zero it means that square is under
attack, and therefore we should not try to place any of the remaining bishops
on it. 

<<8.1 Backtrack>>=
if (k == 0) {
    counter.incrementAndGet();
    return;
}

for (int i = s; i <= 2 * n - 1; i += 2) {
    int ii = i >= n ? n * (i - n + 2) - 1 : i;
    int squares = i >= n ? 2 * n - i - 1 : i + 1;
    for (int j = ii, num = 0; num < squares; j += (n - 1), ++num) {
        int x = j / n;
        int y = j % n;
        if (attack[x][y] > 0) {
            continue;
        }
        attack(x, y, 1);
        count(i + 2, k - 1, counter);
        attack(x, y, -1);
    }
}
@

\subsection{15-Puzzle Problem}

This task, if it was smaller, could be solved using BFS algorithm. But
15-puzzle is quite troublesome to solve using BFS. However the task can be
solved using the iterative deepening A* algorithm. Even though the time limit is 15
seconds, some cases may take much longer even with IDA* algorithm, but it seems
that the online judge doesn't have such test cases. 

First, let's sort out the unsolvable cases. There is a way to determine unsolvable
cases and it is described in \cite{15PZL}: If the square containing the number
$i$ appears before $n$ numbers that are less than $i$, then call it an
inversion of order $n$, and denote it $n_i$. Let $N=\sum_{i=1}^{15}n_i$.  Now
let $r_0$ be the row number containing the empty square (counting from 1), then
if $N + r_0$ value is odd, then the puzzle is unsolvable.

The IDA* algorithm requires a heuristic. Various heuristics may work with this
task\footnote{See for example:
\url{http://www.ic-net.or.jp/home/takaken/e/15pz/index.html}}, but the simple
Manhattan distance is sufficient for the judge's input cases.

We are going to use a 1D array to store the puzzle state, 0 denoting the empty
square. We will introduce a class to represent a node in a graph, which will
hold puzzle's state and some additional information such as whether this
configuration is solvable or not, and the Manhattan distance.

Let's sort out input/output.

<<15 Puzzle Problem>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.List;

public class The15PuzzleProblem {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    <<8.2. Node Class>>
    <<8.2. IDA* Search>>

    private static List<Integer> parseLine(String line) {
        return stream(line.trim().split(" "))
                .filter(x -> !x.equals(""))
                .map(Integer::parseInt)
                .collect(toList());
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            int[] puzzle = new int[16];
            int l = 0;
            for (int j = 0; j < 4; ++j) {
                List<Integer> line = parseLine(reader.readLine().trim());
                for (int k = 0; k < 4; ++k) {
                    puzzle[l] = line.get(k);
                    l += 1;
                }
            }
            Node node = new Node(puzzle);
            if (!node.isSolvable()) {
                System.out.println("This puzzle is not solvable.");
            } else {
                System.out.println(solve(node));
            }
        }
    }
}

@

The [[Node]] class is quite straightforward. Its [[isSolvable]] method
implements the check we discussed earlier. It also overrides [[equals]] because
we will be checking if an instance of [[Node]] is in the stack or not in our
implementation of the IDA* algorithm. The constructor takes a node, two indexes
and a string. Two indexes define elements of the squares that need to be
swapped, and the string argument is the direction of the move. Obviously, if
the Manhattan distance is 0, then this configuration is the solution of the
puzzle.

<<8.2. Node Class>>=
static class Node {
    final int[] node;
    final String path;
    final int d;
    final boolean isSolution;

    public Node(Node node, int i, int j, String p) {
        this.node = Arrays.copyOf(node.node, node.node.length);
        int tmp = this.node[i];
        this.node[i] = this.node[j];
        this.node[j] = tmp;
        this.path = node.path + p;
        this.d = distance(this.node);
        this.isSolution = d == 0;
    }

    private boolean isSolvable() {
        int sum = 0;
        int f = indexOfZero(this.node) / 4 + 1;
        for (int i = 0; i < this.node.length; ++i) {
            int c = 0;
            for (int j = i; j < this.node.length; ++j) {
                if (this.node[i] > 0 && this.node[j] > 0 &&
                        this.node[i] > this.node[j]) {
                    c++;
                }
            }
            sum += c;
        }
        return (sum + f) % 2 == 0;
    }

    private int distance(int[] node) {
        int d = 0;
        for (int k = 0; k < node.length; ++k) {
            if (node[k] == 0) {
                continue;
            }
            int r0 = (node[k] - 1) / 4;
            int c0 = (node[k] - 1) % 4;
            int r1 = (k) / 4;
            int c1 = (k) % 4;
            d += Math.abs(r0 - r1) + Math.abs(c0 - c1);
        }
        return d;
    }

    public Node(int[] puzzle) {
        this.node = puzzle;
        this.path = "";
        this.d = distance(this.node);
        this.isSolution = d == 0;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + Arrays.hashCode(node);
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Node other = (Node) obj;
        if (!Arrays.equals(node, other.node))
            return false;
        return true;
    }
}

@

Now let's implement the search algorithm. This implementation is a direct
translation of the pseudocode from \cite{IDA*}. The method [[adjacent]] simply
returns all possible movements for the given [[puzzle]].

<<8.2. IDA* Search>>=
private static final int FOUND = Integer.MIN_VALUE;

public static int indexOfZero(int[] puzzle) {
    for (int i = 0; i < puzzle.length; ++i) {
        if (puzzle[i] == 0) {
            return i;
        }
    }
    return 0;
}

public static List<Node> adjacent(Node puzzle) {
    List<Node> nodes = new ArrayList<>();
    int p = indexOfZero(puzzle.node);

    if (p + 1 <= 15 && p != 3 && p != 7 && p != 11 && p != 15) {
        nodes.add(new Node(puzzle, p, p + 1, "R"));
    }

    if (p - 4 >= 0) {
        nodes.add(new Node(puzzle, p, p - 4, "U"));
    }

    if (p - 1 >= 0 && p % 4 != 0) {
        nodes.add(new Node(puzzle, p, p - 1, "L"));
    }

    if (p + 4 <= 15) {
        nodes.add(new Node(puzzle, p, p + 4, "D"));
    }

    return nodes;
}

private static String solve(Node root) {
    int limit = root.d;
    Deque<Node> stack = new ArrayDeque<>();
    stack.push(root);
    while (true) {
        int newBound = search(stack, 0, limit);
        if (newBound == FOUND) {
            return stack.peek().path;
        }
        if (newBound == Integer.MAX_VALUE) {
            return "This puzzle is not solvable.";
        }
        limit = newBound;
    }
}

private static int search(Deque<Node> stack, int g, int limit) {
    Node node = stack.peek();
    int f = g + node.d;

    if (f > limit) {
        return f;
    }
    if (node.isSolution) {
        return FOUND;
    }
    int min = Integer.MAX_VALUE;
    for (Node adjNode : adjacent(node)) {
        if (!stack.contains(adjNode)) {
            stack.push(adjNode);
            int newBound = search(stack, g + 1, limit);
            if (newBound == FOUND) {
                return FOUND;
            }
            if (newBound < min) {
                min = newBound;
            }
            stack.pop();
        }
    }
    return min;
}
@

\subsection{Queue}

This task was quite challenging despite the fact it is rated as Level 2 task.
It took me two attempts before I came up with a correct solution.

Let's agree that $l$ is the number of people visible while looking from the
beginning of the queue, and $r$ is the number of people visible while looing
from the end of the queue.

Now, two important observations. Notice that out of $n$ persons there will
always be the tallest person and that one will be visible from both ends of the
queue. This is because all persons are of different height and if the person
visible from both ends is not the tallest, then there will be a person that we
will need to fit in between the persons and we won't be able to do that. So in
every proper configuration the person visible from both ends is the tallest
person. The second observation is that we don't need to arrange people into a
queue as described in the problem in order to determine the required queue
configurations. All we have to do is to find a configuration where all the
people go in ascending order and such that the length of the arrangement is
$l+r-2$; let's call this a queue. (Minus $2$ because both $l$ and $r$ parts
``contain'' the tallest person). Then the number of configurations as it's
asked in the problem statement is equal to ${l+r-2} \choose {l-1}$. Now we will
have some people that should be distributed in between these people in the
queue. For example if we have three people in a queue $p_1, p_2, p_3$ and $p_1
< p_2 < p_3$ then the other people can be inserted between $p_1$ and $p_2$
(let's call it $p_1$ bucket), and $p_2$ and $p_3$ ($p_2$ bucket), provided that
$p_2 - p_1 > 1$ and $p_3 - p_2 > 1$, and that those other people heights are
less than $p_1$ and $p_2$ and so on. This is where the backtracking technique
comes in: We try all possible placements of the people into such buckets. Note
that we put the people into buckets in a methodic way and in ascending order.
Once we have a placement in a bucket, $d$ people within the bucket can be
permuted in $d!$ ways. Since we have multiple buckets we just multiple these
factorials to get the final answer. Then we find another distribution in the
buckets and repeat the calculation while accumulating the value. Once
distributions in the buckets are exhausted for this queue, we find a nother
queue and repeat the process.\footnote{Incidentally, there's a very short and
efficient solution using dynamic programming technique. See
\url{https://github.com/morris821028/UVa/blob/master/volume101/10128 - Queue.cpp}.}

<<Queue>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;
import java.util.stream.LongStream;

public class Queue {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private final int n;
    private final int k;
    private final int[] buckets;
    private final int[] queue;
    private final int[] values;
    private final boolean[] skip;
    private long total;
    private long counter;

    private static final long[] factorial = LongStream.rangeClosed(0, 13)
            .map(f -> f == 0 ? 1
                    : LongStream.rangeClosed(1, f).reduce(1L,
                            (x, y) -> x * y))
            .toArray();

    private static final Long[][][] cache = new Long[13 + 1][13 + 1][13 + 1];

    public Queue(int n, int l, int r) {
        this.n = n;
        this.k = l - 1;
        buckets = new int[n + 1];
        skip = new boolean[n + 1];
        queue = new int[l + r - 2];
        values = new int[n - (l + r - 2) - 1 < 0 ? 0 : n - (l + r - 2) - 1];
        skip[n] = true;
        if (cache[n][l][r] != null) {
            total = cache[n][l][r];
        } else {
            select(0);
            cache[n][l][r] = total;
        }
    }

    private void select(int pos) {
        if (pos == queue.length) {
            for (int i = 1, j = 0; i <= n; ++i) {
                if (!skip[i]) {
                    values[j++] = i;
                }
            }
            counter = 0;
            count(0);
            int nn = queue.length;
            total += counter * factorial[nn] /
                    (factorial[k] * factorial[nn - k]);
            return;
        }

        int start = pos - 1 >= 0 ? queue[pos - 1] + 1 : 1;
        for (int i = start; i < n; ++i) {
            queue[pos] = i;
            skip[i] = true;
            select(pos + 1);
            skip[i] = false;
        }
    }

    private void count(int pos) {
        if (pos == values.length) {
            long permutations = 1;
            for (int i = 0; i < buckets.length; ++i) {
                permutations *= factorial[buckets[i]];
            }
            counter += permutations;
            return;
        }

        for (int bucket : queue) {
            if (bucket > values[pos]) {
                buckets[bucket]++;
                count(pos + 1);
                buckets[bucket]--;
            }
        }
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            List<Integer> line = stream(reader.readLine().split(" "))
                    .filter(x -> !x.equals(""))
                    .map(Integer::parseInt)
                    .collect(toList());
            int l = line.get(1);
            int r = line.get(2);
            if (l + r - 1 > 13) {
                System.out.println(0);
            } else {
                Queue q = new Queue(line.get(0), l, r);
                System.out.println(q.total);
            }
        }
    }

}

@

\subsection{Servicing Stations}

There's no alternative other than just try all possible configurations as this
task is known to be an NP problem\footnote{See ``dominating set''}. So we will
have to exhaustively try various configurations until we arrive at one that
satisfies the problem requirements. We start with just one node, and if we
can't find a solution we try two nodes, then three nodes, and so on, until we
find a solution.

One important thing to do is to find the graphs, because some nodes can be
disconnected from the others. Once we found these graphs we then find the
dominating sets per each graph and sum up the sizes of those dominating
sets to get the final result.

We will be using bit arrays per each node. Each such bit array will define
which nodes are connected to the node. A bit at index $i$ tells whether node
$i$ is connected to this node. At first I chose to use [[boolean]] arrays but then
switched to Java's [[BitSet]]. However, [[BitSet]]'s performance wasn't satisfactory,
whether [[boolean]] arrays required a number of ugly cycles to be coded here and 
there. Therefore I chose to use [[long]] type to hold my bits and use bit operations
to set and unset bits in it.

The template for the program will be as follows.

<<Servicing Stations>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

public class ServicingStations {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    <<8.4 Bits Class>>
    <<8.4 Fields>>

    public ServicingStations(Bits[] cities) throws Exception {
        <<8.4 Constuctor>>
    }

    <<8.4 Graphs>>
    <<8.4 Backtrack>>

    private static List<Integer> parseLine(String line) {
        return stream(line.split(" "))
                .filter(x -> !x.equals(""))
                .map(Integer::parseInt)
                .collect(toList());
    }

    public static void main(String[] args) throws Exception {
        <<8.4 Input/Output>>
    }

}

@

Let's add the [[Bits]] class first. It's just a wrapper around
[[long]] value that sets and reads bits of it:

<<8.4 Bits Class>>=
static class Bits {
    long v = 0L;

    boolean get(int b) {
        return (this.v & (1L << b)) != 0;
    }

    void set(int b) {
        this.v |= (1L << b);
    }
}

@

Our input graph will be represented as an array of [[Bits]], [[Bits[] cities]],
where an index $i$ in the array [[cities]] is the node $i$, and the
corresponding array element of type [[Bits]], e.g. [[cities[i]]], is its
adjacency bit array.

The input graph may be actually a set of graphs which are completely isolated
from each other. We would like to decompose the input graph to such isolated
graphs first.

To do that we are going to use the depth-first search:

<<8.4 Graphs>>=
private List<Bits> graphs(Bits[] cities) {
    List<Bits> graphs = new ArrayList<>();
    Bits all = new Bits();
    boolean finished = false;
    while (!finished) {
        finished = true;
        for (int i = 0; i < cities.length; ++i) {
            if (!all.get(i)) {
                finished = false;
                Bits graph = bfs(i, cities);
                graphs.add(graph);
                all.v |= graph.v;
                break;
            }
        }
    }
    return graphs;
}

private Bits bfs(int s, Bits[] cities) {
    Deque<Integer> next = new ArrayDeque<>();
    Bits visited = new Bits();
    next.add(s);
    while (!next.isEmpty()) {
        int n = next.pop();
        for (int i = 0; i < cities.length; ++i) {
            if (cities[n].get(i) && !visited.get(i)) {
                next.add(i);
            }
        }
        visited.set(n);
    }
    return visited;
}

@

Before implementing the constructor, let's introduce some fields that we are
going to need:

<<8.4 Fields>>=
private final Bits[] cities;
private final Bits[] stack;
private int count;
private Bits currentGraph;

@

[[count]] field will hold the minimum number we are seeking; [[cities]] will be
the input array, [[stack]] and [[currentGraph]] will be used in our
backtracking.

Let's implement the constructor:

<<8.4 Constuctor>>=
count = 0;
this.stack = new Bits[40];
for (int i = 0; i < this.stack.length; ++i) {
    this.stack[i] = new Bits();
}
this.cities = cities;
for (Bits graph : graphs(this.cities)) {
    currentGraph = graph;
    for (int i = 0; i < cities.length; ++i) {
        <<8.4 Invoke Backtrack>>
    }
}
@

Now let's get to the backtrack. It's going to be a classic backtrack. When we
try a new node, we first check if that node is within our current graph, and
that adding that node gives us any improvement or not. If it does not, then it
moves on to next node. If it does improve, it recurses. Once we've tried the
predefined number of nodes and we found a configuration, we check if that
configuration covered all the nodes in the graph, and if it did, it means we
found a solution. If not, we backtrack. (Note how we are using the bitwise
operations on the adjacency bits and the [[stack]]. We could have done this
without the [[stack]]. But the reason we have the [[stack]] is to avoid
repeated creation of [[Bits]] objects.)

<<8.4 Backtrack>>=
private boolean backtrack(int count, int pos, int depth) throws Exception {
    if (count == 0) {
        return ((stack[depth].v &
                currentGraph.v) == currentGraph.v);
    }
    for (int i = pos; i < cities.length; ++i) {
        if (!currentGraph.get(i) && !stack[depth].get(i)) {
            continue;
        }

        stack[depth + 1].v = stack[depth].v | cities[i].v;
        if (stack[depth + 1].v == stack[depth].v) {
            continue;
        }

        if (backtrack(count - 1, i + 1, depth + 1)) {
            return true;
        }
    }
    return false;
}

@

Now we need to invoke this from the constructor:

<<8.4 Invoke Backtrack>>=
if (backtrack(i, 0, 0)) {
    count += i;
    break;
}
@

Finally we can implement the input/output:

<<8.4 Input/Output>>=
String currentLine;
while ((currentLine = reader.readLine()) != null) {
    if (currentLine.trim().isEmpty()) {
        continue;
    }
    List<Integer> nm = parseLine(currentLine);
    int n = nm.get(0);
    int m = nm.get(1);
    if (n == 0 && m == 0) {
        break;
    }
    Bits[] cities = new Bits[n];
    for (int i = 0; i < cities.length; ++i) {
        cities[i] = new Bits();
        cities[i].set(i);
    }
    while (m > 0) {
        if ((currentLine = reader.readLine()).trim().isEmpty()) {
            continue;
        }
        List<Integer> fromTo = parseLine(currentLine.trim());
        cities[fromTo.get(0) - 1].set(fromTo.get(1) - 1);
        cities[fromTo.get(1) - 1].set(fromTo.get(0) - 1);
        m--;
    }
    System.out.println(new ServicingStations(cities).count);
}
@

\subsection{Tug Of War}

I have no idea how to solve this task using backtrack and it seems neither
do the authors of the book.

The task can be solved using dynamic programming. Let's say the input array is
$A$ of size $n$. Let $S$ be the sum of the elements of $A$. Let's also assume
we have an array $M$ of boolean values of size $S+1$. The $i$-th item in this
array means whether there's a sum that is equal to $i$ using some elements of $A$
or not. So $M[0]=true$, because we can always have a sum that is equal to $0$
by taking none of the elements of $A$. Let's take the first element from
$A$, $A[0]$. Now we will have $M[0]=true$ and $M[0+A[0]]=true$, because we can
extend our empty set by adding $A[0]$ into it. Now, generally, when we are
processing $A[i]$, then at every position $j$ in $M$ where $M[j]=true$ we can
extend it by adding the $A[i]$ element by setting $M[j+A[i]]$ to $true$. Once
we have finished, we can check if $M[S/2]$ is true and if so, then there's a
subset of $A$ that sums to $S/2$. 

That answer is absolutely correct, but it doesn't take into account the size of
the subsets! We need to somehow modify this algorithm so that it also keeps
track of the number of elements of the subsets. Then we could choose the one
that matches the requirement, that is such that the size of the subset is the
half of the $A$ exactly or differs by no more than 1 and that the sum is as
close to the $S/2$ value as possible.

Let's modify our $M$ array to hold integers instead of boolean values (it is of
[[long]] type, because we may have up to 50 elements in our subset and long is
64-bit in Java). Then we shift the value at $M[i]$ to the left by one each time
we extend the subset, and use the bitwise OR to combine the values. Once
finished, we will have values at $M[i]$ such that bits in this value will
define the sizes of the subsets. So the bit at $j$-th position in the value
$M[i]$ means there's a subset of size $j$ that sums to $i$. To get the
required answer, we start with the value at $M[S/2]$ and check if the bit at
$n/2$-th position is set or not if $n$ is even, and we check both $n/2$-th and
$n/2+1$-th bits if $n$ is odd. If the bit is set, then $S/2$ is the answer.
Otherwise we check $M[S/2-1]$, $M[S/2-2]$, and so on until we find a match.

To arrive at this solution a tutorial \cite{DP3} was of great help. The bit 
trick was purloined from \cite{TOW}.

<<Tug Of War>>=
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;

public class TugOfWar {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static int[] solve(int[] arr) {
        int n = arr.length;
        int sum = Arrays.stream(arr).sum();
        long[] m = new long[sum + 1];
        m[0] = 1;
        for (int i = 0; i < n; ++i) {
            for (int j = sum - arr[i]; j >= 0; --j) {
                m[j + arr[i]] |= m[j] << 1L;
            }
        }

        for (int i = sum / 2; i >= 0; --i) {
            if (n % 2 == 0) {
                if ((m[i] & 1L << (n / 2)) > 0) {
                    return new int[] { i, sum - i };
                }
            } else {
                if ((m[i] & 1L << (n / 2)) > 0 ||
                        (m[i] & 1L << (n / 2 + 1)) > 0) {
                    return new int[] { i, sum - i };
                }
            }
        }

        return null;
    }

    public static void main(String[] args) throws Exception {
        int n = Integer.parseInt(reader.readLine().trim());
        reader.readLine();
        for (int i = 0; i < n; ++i) {
            int m = Integer.parseInt(reader.readLine().trim());
            int[] arr = new int[m];
            for (int j = 0; j < m; ++j) {
                arr[j] = Integer.parseInt(reader.readLine().trim());
            }
            int[] s = solve(arr);
            System.out.println(s[0] + " " + s[1]);
            if (i < n - 1) {
                System.out.println();
                reader.readLine();
            }
        }
    }

}

@

\subsection{Garden of Eden}

Because the given state in the input may be a ``Garden of Eden'' state,
i.e. no other state leads to it using the given automaton, all we need to do is
to try to proove such a previous state doesn't exist. If it does, then this
state is not ``Garden of Eden'' state.

To solve the task a simple backtracking without any special tricks will do. We
just use the transition table for the given automaton while trying to
reconstruct the previous state.

<<Garden of Eden>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.List;

public class GardenOfEden {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    static final boolean[][] trans = new boolean[][] {
            { false, false, false },
            { false, false, true },
            { false, true, false },
            { false, true, true },
            { true, false, false },
            { true, false, true },
            { true, true, false },
            { true, true, true }
    };

    final boolean[] auto;
    final boolean[] curr;
    final boolean[] prev;
    boolean reachable;

    GardenOfEden(boolean[] auto, boolean[] curr) {
        this.auto = auto;
        this.curr = curr;
        this.prev = new boolean[curr.length];
        for (int j = 0; j < auto.length; ++j) {
            if (auto[j] == curr[0]) {
                prev[prev.length - 1] = trans[j][0];
                prev[0] = trans[j][1];
                prev[1] = trans[j][2];
                reachable = backtrack(1);
                if (reachable) {
                    break;
                }
            }
        }
    }

    boolean backtrack(int pos) {
        for (int j = 0; j < auto.length; ++j) {
            if (auto[j] != curr[pos]) {
                continue;
            }
            if (prev[pos - 1] == trans[j][0] &&
                    prev[pos] == trans[j][1]) {
                if (pos == curr.length - 1) {
                    if (prev[0] == trans[j][2]) {
                        return true;
                    }
                } else if (pos + 1 == curr.length - 1) {
                    if (prev[pos + 1] == trans[j][2]) {
                        if (backtrack(pos + 1)) {
                            return true;
                        }
                    }
                } else {
                    prev[pos + 1] = trans[j][2];
                    if (backtrack(pos + 1)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public static void main(String[] args) throws Exception {
        String currentLine;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().isEmpty()) {
            List<String> input = stream(currentLine.trim().split(" "))
                    .filter(x -> !x.equals(""))
                    .collect(toList());
            boolean[] automaton = new boolean[8];
            String id = Integer.toBinaryString(Integer.parseInt(input.get(0)));
            for (int i = id.length() - 1, j = 0; i >= 0; --i, ++j) {
                automaton[j] = id.charAt(i) == '1';
            }
            boolean[] state = new boolean[input.get(2).length()];
            for (int i = 0; i < state.length; ++i) {
                state[i] = input.get(2).charAt(i) == '1';
            }
            System.out
                    .println(new GardenOfEden(automaton, state).reachable ? "REACHABLE"
                            : "GARDEN OF EDEN");
        }
    }

}

@

\subsection{Colours Hash}

It seems that this can be solved with a breadth-first search. And it can, but
it won't be very quick. There's a trick, however, that works well with this
task: Using the BFS we can find all the reachable states (and how to get there)
starting from the final state up to a certain depth level.  Having the depth of
8 is enough for this task. One we have this precomputed set, we start doing the
BFS from the input state, but we again limit it to 8 levels of depth. (Note
that the task's requirement is to give up searching if the depth is more than
16.) If we can reach any state in the precomputed set from an input state,
then we know there's a path, and we can reconstruct it.

<<Colours Hash>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class ColoursHash {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    <<8.7 Fields>>

    <<8.7 State Class>>

    <<8.7 Precompute>>

    <<8.7 Find>>

    public static void main(String[] args) throws Exception {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            String line = reader.readLine();
            List<Integer> input = stream(line.trim().split(" "))
                    .filter(x -> !x.equals(""))
                    .map(Integer::parseInt)
                    .collect(toList());
            State state = new State(input);
            if (state.equals(finalState)) {
                System.out.println("PUZZLE ALREADY SOLVED");
            } else {
                String solution = find(state);
                if (solution != null) {
                    System.out.println(solution);
                } else {
                    System.out.println("NO SOLUTION WAS FOUND IN 16 STEPS");
                }
            }
        }

    }
}
@

The [[State]] class is going to be fairly simple. It will hold the state as an
array of integers. The constructor will allow to create a new state from the
given state by rotating the wheels. I have chosen to use [[LinkedList]] here as
it has convenient methods to do the rotations. I could have done this using
[[System.arraycopy]] too, but decided for something that is more readable (that
is [[LinkedList]]). The [[equals]] and [[hashCode]] are necessary as we will be
using maps and sets while doing the BFS.

<<8.7 State Class>>=
static class State {
    final int[] curr;

    public State(State state, int rotation) {
        this(state.curr, rotation);
    }

    public State(List<Integer> state) {
        curr = new int[21];
        for (int i = 0; i < curr.length; ++i) {
            curr[i] = state.get(i);
        }
    }

    public State(int[] state, int rotation) {
        this.curr = new int[21];

        final LinkedList<Integer> left = new LinkedList<>();
        final LinkedList<Integer> right = new LinkedList<>();
        final LinkedList<Integer> middle = new LinkedList<>();

        for (int i = 0; i < 12; ++i) {
            if (i < 9) {
                left.add(state[i]);
                right.add(state[i + 12]);
            } else {
                middle.add(state[i]);
            }
        }

        if (rotation == 1) {
            middle.addFirst(left.removeLast());
            middle.addFirst(left.removeLast());
            left.addFirst(middle.removeLast());
            left.addFirst(middle.removeLast());
        } else if (rotation == 2) {
            middle.addLast(right.removeFirst());
            middle.addLast(right.removeFirst());
            right.addLast(middle.removeFirst());
            right.addLast(middle.removeFirst());
        } else if (rotation == 3) {
            middle.addLast(left.removeFirst());
            middle.addLast(left.removeFirst());
            left.addLast(middle.removeFirst());
            left.addLast(middle.removeFirst());
        } else if (rotation == 4) {
            middle.addFirst(right.removeLast());
            middle.addFirst(right.removeLast());
            right.addFirst(middle.removeLast());
            right.addFirst(middle.removeLast());
        }

        for (int i = 0; i < left.size(); ++i) {
            curr[i] = left.get(i);
        }
        for (int i = 0; i < middle.size(); ++i) {
            curr[9 + i] = middle.get(i);
        }
        for (int i = 0; i < right.size(); ++i) {
            curr[12 + i] = right.get(i);
        }
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + Arrays.hashCode(curr);
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        State other = (State) obj;
        if (!Arrays.equals(curr, other.curr))
            return false;
        return true;
    }
}
@

Now we can define the initial state:

<<8.7 Fields>>=
private static State finalState = new State(
        new int[] { 0, 3, 4, 3, 0, 5, 6, 5, 0, 1,
                2, 1, 0, 7, 8, 7, 0, 9, 10, 9, 0 },
        0);

@

Let's write the initialization of the [[precomputed]] set, the set of the
states that are reachable from the [[finalState]]. First, let's define
[[moves]] array. Because we are searching from the [[finalState]] to a
reachable state, we will use this array to know the ``reversed'' moves, because
we are looking for a path from a rechable state to the final state and not the
other way round.

<<8.7 Fields>>=
final static int[] moves = new int[] { 3, 4, 1, 2 };
final static Map<State, String> precomputed = init();
@

We will need to keep track of the depths and moves sequences while doing BFS ,
so let's define a helper class for that:

<<8.7 Precompute>>=
static class Tuple {
    int depth;
    String solution;

    public Tuple(int depth, String solution) {
        this.depth = depth;
        this.solution = solution;
    }
}

@

Now let's implement the [[init()]] method that precomputes the reachable states
set. The [[generate]] method is a simple BFS implementation, the only difference
is that it terminates once it has reached the depth of 8.

<<8.7 Precompute>>=
static Map<State, String> init() {
    Map<State, String> solutions = new HashMap<>();
    generate(solutions, finalState);
    return solutions;
}

private static void generate(Map<State, String> solutions, State node) {
    Deque<State> next = new ArrayDeque<>();
    Map<State, Tuple> depths = new HashMap<>();
    Set<State> visited = new HashSet<>();
    next.addLast(node);
    depths.put(node, new Tuple(0, ""));
    visited.add(node);

    while (!next.isEmpty()) {
        State n = next.pop();
        Tuple tuple = depths.get(n);
        if (tuple.depth > 8) {
            continue;
        }
        String solution = tuple.solution;
        for (int i = 1; i <= 4; ++i) {
            State adj = new State(n, moves[i - 1]);
            if (!visited.contains(adj)) {
                next.add(adj);
                depths.putIfAbsent(adj,
                        new Tuple(tuple.depth + 1, i + solution));
                solutions.putIfAbsent(adj, i + solution);
            }
        }
        visited.add(n);
    }
}

@

Now we can implement the [[find]] method, that will do a similar BFS, but will
check whether we have reached any state in [[precomputed]] set. If we have,
then we have found the solution!

<<8.7 Find>>=
private static String find(State node) {
    Deque<State> next = new ArrayDeque<>();
    Map<State, Tuple> depths = new HashMap<>();
    Set<State> visited = new HashSet<>();
    next.addLast(node);
    depths.put(node, new Tuple(0, ""));
    visited.add(node);

    while (!next.isEmpty()) {
        State n = next.pop();
        Tuple tuple = depths.get(n);
        String solution = tuple.solution;
        if (tuple.depth > 8) {
            continue;
        }
        if (ColoursHash.precomputed.containsKey(n)) {
            return solution + ColoursHash.precomputed.get(n);
        }
        for (int i = 1; i <= 4; ++i) {
            State adj = new State(n, i);
            if (!visited.contains(adj)) {
                next.add(adj);
                depths.putIfAbsent(adj,
                        new Tuple(tuple.depth + 1, solution + i));
            }
        }
        visited.add(n);
    }

    return null;
}

@

\subsection{Bigger Square Please...}

Well, this task is impossible to solve in under 3 seconds as the judge expects
us to solve.  So the only sensible way is to write a meta-program that
generates a program than then gets accepted by the judge. The generated program
got to be a simple lookup type of a program that uses pre-computed table of
solutions. This is possible as the range for the input is small.

But even a meta-program will need to be written with some heuristics here and
there to allow for better run time. As this meta-program won't be run by the
judge we can use all available tools. Specifically, we will use all the cores of
the CPU to run computations in parallel as much as possible.

Just a few notes on the problem itself. It's a very well known problem; the
sequence of minimal number of smaller integer-sided squares that tile an $n
\times n$ square is registered in the On-Line Encyclopedia of Integer Sequences
as A018835 sequence\cite{OEIS}.

Obviously, any square that has a side of an even length is trivially divisible
into four squares of equal size, and you can't do better than that. So at least
half of the problem is now solved! Any square that has a side length that is a
multiple of 3 (but not 5) is also trivially divisible. So we only need to use
backtracking for the rest of the values in $2 \leq p \leq 50$ interval.

\begin{figure}[h]
\centering
\begin{pspicture}(-4,0)(4,3)

\rput(-3.2, 0){
\psframe(0,0)(3,3)
\psframe(0,0)(2,2)
\rput[bl](0.1,0.1){6}
\rput(0,2){\rput[bl](0.1,0.1){\small{3}}\psframe(0,0)(1,1)}
\rput(1,2){\rput[bl](0.1,0.1){\small{3}}\psframe(0,0)(1,1)}
\rput(2,2){\rput[bl](0.1,0.1){\small{3}}\psframe(0,0)(1,1)}
\rput(2,1){\rput[bl](0.1,0.1){\small{3}}\psframe(0,0)(1,1)}
\rput(2,0){\rput[bl](0.1,0.1){\small{3}}\psframe(0,0)(1,1)}
}

\rput(0.2,0){
\psframe(0,0)(0,3)
\rput(0,0){\rput[bl](0.1,0.1){\small{2}}\psframe(0,0)(1.5,1.5)}
\rput(0,1.5){\rput[bl](0.1,0.1){\small{2}}\psframe(0,0)(1.5,1.5)}
\rput(1.5,0){\rput[bl](0.1,0.1){\small{2}}\psframe(0,0)(1.5,1.5)}
\rput(1.5,1.5){\rput[bl](0.1,0.1){\small{2}}\psframe(0,0)(1.5,1.5)}
}
\end{pspicture}
\caption{Example for $9 \times 9$ and $4 \times 4$.}
\end{figure}

Let's outline the general approach to solve the task. First, it's always very
beneficial to try a few small cases. This allows (with some luck) to notice
patterns. In our case this may suggest heuristics. There's no guarantee that
these heuristics will lead to the optimal solutions, but still worth trying.
(Do we have any other choice here?)

Once a few small cases have been computed you will notice that all the solutions
for the squares of odd side lengths start with a similar pattern: Namely the
biggest square is usually of $n/2+1$ and there are two smaller squares of size
$n/2$ by its sides; everything else gets packed in the remaining part. This
observation will reduce our search space.

Another thing to notice is that for every prime $n$ the number of squares seems
to grow monotonically. This also allows for the search space reduction.

OK, once we have put those three squares we have the remaining part to fill
out. We know the unfilled area so we generate all the possible square
combinations of different sizes that sum up to the unfilled area. Then we try
to tile that area with these squares. In both cases we use backtracking, that
is generating the candidate square sets, and trying to tile them into the
unfilled area.

\begin{figure}
\centering
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{2}}
        \psframe(0.0000,0.0000)(2.0000,2.0000)
        \rput[bl](2.1000,2.1000){\tiny{1}}
        \psframe(2.0000,2.0000)(3.0000,3.0000)
        \rput[bl](2.1000,0.1000){\tiny{1}}
        \psframe(2.0000,0.0000)(3.0000,1.0000)
        \rput[bl](0.1000,2.1000){\tiny{1}}
        \psframe(0.0000,2.0000)(1.0000,3.0000)
        \rput[bl](2.1000,1.1000){\tiny{1}}
        \psframe(2.0000,1.0000)(3.0000,2.0000)
        \rput[bl](1.1000,2.1000){\tiny{1}}
        \psframe(1.0000,2.0000)(2.0000,3.0000)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{3}}
        \psframe(0.0000,0.0000)(1.8000,1.8000)
        \rput[bl](1.9000,0.1000){\tiny{2}}
        \psframe(1.8000,0.0000)(3.0000,1.2000)
        \rput[bl](0.1000,1.9000){\tiny{2}}
        \psframe(0.0000,1.8000)(1.2000,3.0000)
        \rput[bl](1.3000,1.9000){\tiny{2}}
        \psframe(1.2000,1.8000)(2.4000,3.0000)
        \rput[bl](1.9000,1.3000){\tiny{1}}
        \psframe(1.8000,1.2000)(2.4000,1.8000)
        \rput[bl](2.5000,1.3000){\tiny{1}}
        \psframe(2.4000,1.2000)(3.0000,1.8000)
        \rput[bl](2.5000,1.9000){\tiny{1}}
        \psframe(2.4000,1.8000)(3.0000,2.4000)
        \rput[bl](2.5000,2.5000){\tiny{1}}
        \psframe(2.4000,2.4000)(3.0000,3.0000)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{4}}
        \psframe(0.0000,0.0000)(1.7143,1.7143)
        \rput[bl](1.8143,0.1000){\tiny{3}}
        \psframe(1.7143,0.0000)(3.0000,1.2857)
        \rput[bl](0.1000,1.8143){\tiny{3}}
        \psframe(0.0000,1.7143)(1.2857,3.0000)
        \rput[bl](1.3857,1.8143){\tiny{2}}
        \psframe(1.2857,1.7143)(2.1429,2.5714)
        \rput[bl](2.2429,1.3857){\tiny{2}}
        \psframe(2.1429,1.2857)(3.0000,2.1429)
        \rput[bl](2.2429,2.2429){\tiny{2}}
        \psframe(2.1429,2.1429)(3.0000,3.0000)
        \rput[bl](1.3857,2.6714){\tiny{1}}
        \psframe(1.2857,2.5714)(1.7143,3.0000)
        \rput[bl](1.8143,1.3857){\tiny{1}}
        \psframe(1.7143,1.2857)(2.1429,1.7143)
        \rput[bl](1.8143,2.6714){\tiny{1}}
        \psframe(1.7143,2.5714)(2.1429,3.0000)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{6}}
        \psframe(0.0000,0.0000)(2.0000,2.0000)
        \rput[bl](2.1000,2.1000){\tiny{3}}
        \psframe(2.0000,2.0000)(3.0000,3.0000)
        \rput[bl](2.1000,0.1000){\tiny{3}}
        \psframe(2.0000,0.0000)(3.0000,1.0000)
        \rput[bl](0.1000,2.1000){\tiny{3}}
        \psframe(0.0000,2.0000)(1.0000,3.0000)
        \rput[bl](2.1000,1.1000){\tiny{3}}
        \psframe(2.0000,1.0000)(3.0000,2.0000)
        \rput[bl](1.1000,2.1000){\tiny{3}}
        \psframe(1.0000,2.0000)(2.0000,3.0000)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{6}}
        \psframe(0.0000,0.0000)(1.6364,1.6364)
        \rput[bl](1.7364,0.1000){\tiny{5}}
        \psframe(1.6364,0.0000)(3.0000,1.3636)
        \rput[bl](0.1000,1.7364){\tiny{5}}
        \psframe(0.0000,1.6364)(1.3636,3.0000)
        \rput[bl](1.4636,2.0091){\tiny{4}}
        \psframe(1.3636,1.9091)(2.4545,3.0000)
        \rput[bl](1.7364,1.4636){\tiny{2}}
        \psframe(1.6364,1.3636)(2.1818,1.9091)
        \rput[bl](2.2818,1.4636){\tiny{2}}
        \psframe(2.1818,1.3636)(2.7273,1.9091)
        \rput[bl](2.5545,2.0091){\tiny{2}}
        \psframe(2.4545,1.9091)(3.0000,2.4545)
        \rput[bl](2.5545,2.5545){\tiny{2}}
        \psframe(2.4545,2.4545)(3.0000,3.0000)
        \psframe(1.3636,1.6364)(1.6364,1.9091)
        \psframe(2.7273,1.3636)(3.0000,1.6364)
        \psframe(2.7273,1.6364)(3.0000,1.9091)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{7}}
        \psframe(0.0000,0.0000)(1.6154,1.6154)
        \rput[bl](1.7154,0.1000){\tiny{6}}
        \psframe(1.6154,0.0000)(3.0000,1.3846)
        \rput[bl](0.1000,1.7154){\tiny{6}}
        \psframe(0.0000,1.6154)(1.3846,3.0000)
        \rput[bl](1.4846,2.1769){\tiny{4}}
        \psframe(1.3846,2.0769)(2.3077,3.0000)
        \rput[bl](1.9462,1.4846){\tiny{3}}
        \psframe(1.8462,1.3846)(2.5385,2.0769)
        \rput[bl](2.4077,2.4077){\tiny{3}}
        \psframe(2.3077,2.3077)(3.0000,3.0000)
        \rput[bl](1.4846,1.7154){\tiny{2}}
        \psframe(1.3846,1.6154)(1.8462,2.0769)
        \rput[bl](2.6385,1.4846){\tiny{2}}
        \psframe(2.5385,1.3846)(3.0000,1.8462)
        \rput[bl](2.6385,1.9462){\tiny{2}}
        \psframe(2.5385,1.8462)(3.0000,2.3077)
        \psframe(1.6154,1.3846)(1.8462,1.6154)
        \psframe(2.3077,2.0769)(2.5385,2.3077)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{10}}
        \psframe(0.0000,0.0000)(2.0000,2.0000)
        \rput[bl](2.1000,2.1000){\tiny{5}}
        \psframe(2.0000,2.0000)(3.0000,3.0000)
        \rput[bl](2.1000,0.1000){\tiny{5}}
        \psframe(2.0000,0.0000)(3.0000,1.0000)
        \rput[bl](0.1000,2.1000){\tiny{5}}
        \psframe(0.0000,2.0000)(1.0000,3.0000)
        \rput[bl](2.1000,1.1000){\tiny{5}}
        \psframe(2.0000,1.0000)(3.0000,2.0000)
        \rput[bl](1.1000,2.1000){\tiny{5}}
        \psframe(1.0000,2.0000)(2.0000,3.0000)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{9}}
        \psframe(0.0000,0.0000)(1.5882,1.5882)
        \rput[bl](1.6882,0.1000){\tiny{8}}
        \psframe(1.5882,0.0000)(3.0000,1.4118)
        \rput[bl](0.1000,1.6882){\tiny{8}}
        \psframe(0.0000,1.5882)(1.4118,3.0000)
        \rput[bl](2.2176,2.2176){\tiny{5}}
        \psframe(2.1176,2.1176)(3.0000,3.0000)
        \rput[bl](1.5118,2.0412){\tiny{4}}
        \psframe(1.4118,1.9412)(2.1176,2.6471)
        \rput[bl](2.3941,1.5118){\tiny{4}}
        \psframe(2.2941,1.4118)(3.0000,2.1176)
        \rput[bl](1.8647,1.5118){\tiny{3}}
        \psframe(1.7647,1.4118)(2.2941,1.9412)
        \rput[bl](1.5118,1.6882){\tiny{2}}
        \psframe(1.4118,1.5882)(1.7647,1.9412)
        \rput[bl](1.5118,2.7471){\tiny{2}}
        \psframe(1.4118,2.6471)(1.7647,3.0000)
        \rput[bl](1.8647,2.7471){\tiny{2}}
        \psframe(1.7647,2.6471)(2.1176,3.0000)
        \psframe(1.5882,1.4118)(1.7647,1.5882)
        \psframe(2.1176,1.9412)(2.2941,2.1176)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{10}}
        \psframe(0.0000,0.0000)(1.5789,1.5789)
        \rput[bl](1.6789,0.1000){\tiny{9}}
        \psframe(1.5789,0.0000)(3.0000,1.4211)
        \rput[bl](0.1000,1.6789){\tiny{9}}
        \psframe(0.0000,1.5789)(1.4211,3.0000)
        \rput[bl](1.5211,1.9947){\tiny{7}}
        \psframe(1.4211,1.8947)(2.5263,3.0000)
        \rput[bl](1.8368,1.5211){\tiny{3}}
        \psframe(1.7368,1.4211)(2.2105,1.8947)
        \rput[bl](2.3105,1.5211){\tiny{3}}
        \psframe(2.2105,1.4211)(2.6842,1.8947)
        \rput[bl](2.6263,2.1526){\tiny{3}}
        \psframe(2.5263,2.0526)(3.0000,2.5263)
        \rput[bl](2.6263,2.6263){\tiny{3}}
        \psframe(2.5263,2.5263)(3.0000,3.0000)
        \rput[bl](1.5211,1.6789){\tiny{2}}
        \psframe(1.4211,1.5789)(1.7368,1.8947)
        \rput[bl](2.7842,1.5211){\tiny{2}}
        \psframe(2.6842,1.4211)(3.0000,1.7368)
        \rput[bl](2.7842,1.8368){\tiny{2}}
        \psframe(2.6842,1.7368)(3.0000,2.0526)
        \psframe(1.5789,1.4211)(1.7368,1.5789)
        \psframe(2.5263,1.8947)(2.6842,2.0526)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{14}}
        \psframe(0.0000,0.0000)(2.0000,2.0000)
        \rput[bl](2.1000,2.1000){\tiny{7}}
        \psframe(2.0000,2.0000)(3.0000,3.0000)
        \rput[bl](2.1000,0.1000){\tiny{7}}
        \psframe(2.0000,0.0000)(3.0000,1.0000)
        \rput[bl](0.1000,2.1000){\tiny{7}}
        \psframe(0.0000,2.0000)(1.0000,3.0000)
        \rput[bl](2.1000,1.1000){\tiny{7}}
        \psframe(2.0000,1.0000)(3.0000,2.0000)
        \rput[bl](1.1000,2.1000){\tiny{7}}
        \psframe(1.0000,2.0000)(2.0000,3.0000)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{12}}
        \psframe(0.0000,0.0000)(1.5652,1.5652)
        \rput[bl](1.6652,0.1000){\tiny{11}}
        \psframe(1.5652,0.0000)(3.0000,1.4348)
        \rput[bl](0.1000,1.6652){\tiny{11}}
        \psframe(0.0000,1.5652)(1.4348,3.0000)
        \rput[bl](1.5348,2.1870){\tiny{7}}
        \psframe(1.4348,2.0870)(2.3478,3.0000)
        \rput[bl](1.9261,1.5348){\tiny{5}}
        \psframe(1.8261,1.4348)(2.4783,2.0870)
        \rput[bl](2.4478,2.4478){\tiny{5}}
        \psframe(2.3478,2.3478)(3.0000,3.0000)
        \rput[bl](2.5783,1.5348){\tiny{4}}
        \psframe(2.4783,1.4348)(3.0000,1.9565)
        \rput[bl](1.5348,1.7957){\tiny{3}}
        \psframe(1.4348,1.6957)(1.8261,2.0870)
        \rput[bl](2.7087,2.0565){\tiny{3}}
        \psframe(2.6087,1.9565)(3.0000,2.3478)
        \psframe(1.5652,1.4348)(1.8261,1.6957)
        \psframe(2.3478,2.0870)(2.6087,2.3478)
        \psframe(1.4348,1.5652)(1.5652,1.6957)
        \psframe(2.4783,1.9565)(2.6087,2.0870)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{15}}
        \psframe(0.0000,0.0000)(1.8000,1.8000)
        \rput[bl](1.9000,0.1000){\tiny{10}}
        \psframe(1.8000,0.0000)(3.0000,1.2000)
        \rput[bl](0.1000,1.9000){\tiny{10}}
        \psframe(0.0000,1.8000)(1.2000,3.0000)
        \rput[bl](1.3000,1.9000){\tiny{10}}
        \psframe(1.2000,1.8000)(2.4000,3.0000)
        \rput[bl](1.9000,1.3000){\tiny{5}}
        \psframe(1.8000,1.2000)(2.4000,1.8000)
        \rput[bl](2.5000,1.3000){\tiny{5}}
        \psframe(2.4000,1.2000)(3.0000,1.8000)
        \rput[bl](2.5000,1.9000){\tiny{5}}
        \psframe(2.4000,1.8000)(3.0000,2.4000)
        \rput[bl](2.5000,2.5000){\tiny{5}}
        \psframe(2.4000,2.4000)(3.0000,3.0000)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{18}}
        \psframe(0.0000,0.0000)(2.0000,2.0000)
        \rput[bl](2.1000,2.1000){\tiny{9}}
        \psframe(2.0000,2.0000)(3.0000,3.0000)
        \rput[bl](2.1000,0.1000){\tiny{9}}
        \psframe(2.0000,0.0000)(3.0000,1.0000)
        \rput[bl](0.1000,2.1000){\tiny{9}}
        \psframe(0.0000,2.0000)(1.0000,3.0000)
        \rput[bl](2.1000,1.1000){\tiny{9}}
        \psframe(2.0000,1.0000)(3.0000,2.0000)
        \rput[bl](1.1000,2.1000){\tiny{9}}
        \psframe(1.0000,2.0000)(2.0000,3.0000)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{15}}
        \psframe(0.0000,0.0000)(1.5517,1.5517)
        \rput[bl](1.6517,0.1000){\tiny{14}}
        \psframe(1.5517,0.0000)(3.0000,1.4483)
        \rput[bl](0.1000,1.6517){\tiny{14}}
        \psframe(0.0000,1.5517)(1.4483,3.0000)
        \rput[bl](2.2724,2.2724){\tiny{8}}
        \psframe(2.1724,2.1724)(3.0000,3.0000)
        \rput[bl](1.5483,2.3759){\tiny{7}}
        \psframe(1.4483,2.2759)(2.1724,3.0000)
        \rput[bl](2.3759,1.5483){\tiny{7}}
        \psframe(2.2759,1.4483)(3.0000,2.1724)
        \rput[bl](1.5483,1.8586){\tiny{5}}
        \psframe(1.4483,1.7586)(1.9655,2.2759)
        \rput[bl](1.7552,1.5483){\tiny{3}}
        \psframe(1.6552,1.4483)(1.9655,1.7586)
        \rput[bl](2.0655,1.5483){\tiny{3}}
        \psframe(1.9655,1.4483)(2.2759,1.7586)
        \rput[bl](2.0655,1.8586){\tiny{3}}
        \psframe(1.9655,1.7586)(2.2759,2.0690)
        \psframe(1.4483,1.5517)(1.6552,1.7586)
        \psframe(1.9655,2.0690)(2.1724,2.2759)
        \psframe(1.5517,1.4483)(1.6552,1.5517)
        \psframe(2.1724,2.0690)(2.2759,2.1724)
    }
\end{pspicture}
\begin{pspicture}(0,0)(3.2000,3.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{16}}
        \psframe(0.0000,0.0000)(1.5484,1.5484)
        \rput[bl](1.6484,0.1000){\tiny{15}}
        \psframe(1.5484,0.0000)(3.0000,1.4516)
        \rput[bl](0.1000,1.6484){\tiny{15}}
        \psframe(0.0000,1.5484)(1.4516,3.0000)
        \rput[bl](1.5516,2.0355){\tiny{11}}
        \psframe(1.4516,1.9355)(2.5161,3.0000)
        \rput[bl](1.7452,1.5516){\tiny{5}}
        \psframe(1.6452,1.4516)(2.1290,1.9355)
        \rput[bl](2.2290,1.5516){\tiny{5}}
        \psframe(2.1290,1.4516)(2.6129,1.9355)
        \rput[bl](2.6161,2.1323){\tiny{5}}
        \psframe(2.5161,2.0323)(3.0000,2.5161)
        \rput[bl](2.6161,2.6161){\tiny{5}}
        \psframe(2.5161,2.5161)(3.0000,3.0000)
        \rput[bl](2.7129,1.5516){\tiny{4}}
        \psframe(2.6129,1.4516)(3.0000,1.8387)
        \psframe(1.4516,1.5484)(1.6452,1.7419)
        \psframe(1.4516,1.7419)(1.6452,1.9355)
        \psframe(2.6129,1.8387)(2.8065,2.0323)
        \psframe(2.8065,1.8387)(3.0000,2.0323)
        \psframe(1.5484,1.4516)(1.6452,1.5484)
        \psframe(2.5161,1.9355)(2.6129,2.0323)
    }
\end{pspicture}
\caption{Solutions for odd side lengths $3 \leq n \leq 31$.}
\end{figure}

Now let's start writing code. 

<<Bigger Square Please Offline>>=
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.function.Function;
import java.util.stream.Collectors;

public class BiggerSquarePleaseOffline {
    <<8.8 Classes>>
    <<8.8 Methods>>
    <<8.8 Main>>
}
@

First, we start off with the generator of the square side lengths. It uses
backtracking to generate sets (multisets in fact) of the square sizes whose
areas sum up to a specified value.

[[minSolutionSize]] parameter is used to skip the sets that are too small to
consider. This is useful, because we assumed earlier that the minimal number of
square tiles for the squares whose side lengths are prime values grows
monotonically.  Also, note [[HEURISTIC_DEPTH]] constant: We assume that no
solution will be bigger than 15 squares. (Well, at least for our task's input
range $ 3 \leq n \leq 50$. We know this by looking at A018835.)

Another heuristic is to filter out those sets that have 4 or more squares of
the same size. It seems that the optimal solutions never have more than 4
squares of the same size in them, so we can skip such sets. (Again, this seem
to be true only for $n < 50$).

The backtracking itself here is quite straightforward. One the instance of this
class is constructed, all the sets will be in [[squareSizes]] field.

<<8.8 Classes>>=
static class SquareSideLengthsGenerator {
    private static final int HEURISTIC_DEPTH = 15;
    private Deque<Integer> currSquareSizes = new ArrayDeque<>();
    private List<List<Integer>> squareSizes = new ArrayList<>();

    SquareSideLengthsGenerator(int startSquareSize,
            int targetArea,
            int minSolutionSize) {
        search(startSquareSize, 0, targetArea, HEURISTIC_DEPTH);
        squareSizes = squareSizes.stream()
                .filter(SquareSideLengthsGenerator::heuristicFilter)
                .sorted((x, y) -> Integer.compare(x.size(), y.size()))
                .filter(x -> x.size() >= minSolutionSize)
                .collect(Collectors.toList());
    }

    private static boolean heuristicFilter(List<Integer> s) {
        Map<Integer, Long> result = s.stream().collect(
                Collectors.groupingBy(
                        Function.identity(), Collectors.counting()));
        return Collections.max(result.values()) <= 4;
    }

    private void search(int startSquareSize, int currArea, int targetArea,
            int maxLen) {
        if (currArea == targetArea) {
            squareSizes.add(new ArrayList<>(currSquareSizes));
            return;
        }
        for (int i = startSquareSize; i >= 1; --i) {
            if (currArea + i * i <= targetArea &&
                    currSquareSizes.size() <= maxLen) {
                currSquareSizes.addLast(i);
                search(i, currArea + i * i, targetArea, maxLen);
                currSquareSizes.removeLast();
            }
        }
    }
}

@

Now we will write another backtracking code that will be trying to tile the
squares generated by the [[SquareSideLengthsGenerator]].

It uses a boolean array to keep track of tiling. I could have used some square
overlapping conditions instead of an array, but because the input is small, $2
\leq n \leq 50$, I decided to use a boolean array. Placing or removing a square
in the bigger square is simply setting corresponding cells to [[true]] or
[[false]], and checking if a square can be inserted is as simple as checking if
none of the cells inside of that square are set to [[true]].

Notice [[HEURISTIC_THRESHOLD]] constant. It's a heuristic: If we've been trying
to tile this set for too long, we halt it and conclude it can't be tiled. It
seems that having it set to 25K doesn't affect correctness of the answers, but
setting it to some smaller values may give you non-optimal answers.

<<8.8 Classes>>=
static class SolutionFinder {
    private static final int HEURISTIC_THRESHOLD = 25000;
    private final int n;
    private final boolean[][] square;
    private final List<Integer> candidate;
    private final Deque<int[]> solution = new ArrayDeque<>();
    private final boolean solutionFound;
    private boolean haltSearch;
    private int heuristicCounter;

    SolutionFinder(Deque<int[]> initial,
            List<Integer> candidateSquareSideSizes,
            int n) {
        this.n = n;
        this.candidate = candidateSquareSideSizes;
        this.square = new boolean[n][n];
        initial.forEach(x -> {
            this.solution.add(x);
            set(x, true);
        });
        solutionFound = find(0);
    }

    private boolean isInsertable(int[] s) {
        for (int i = s[0]; i <= s[0] + s[2] - 1; ++i) {
            for (int j = s[1]; j <= s[1] + s[2] - 1; ++j) {
                if (j > n - 1 || i > n - 1 || square[i][j]) {
                    return false;
                }
            }
        }
        return true;
    }

    private void set(int[] s, boolean f) {
        for (int i = s[0]; i <= s[0] + s[2] - 1; ++i) {
            for (int j = s[1]; j <= s[1] + s[2] - 1; ++j) {
                square[i][j] = f;
            }
        }
    }

    private boolean find(int pos) {
        if (pos == candidate.size()) {
            return true;
        }

        if (++heuristicCounter > HEURISTIC_THRESHOLD) {
            haltSearch = true;
            return false;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (square[i][j]) {
                    continue;
                }
                int[] s = new int[] { i, j, candidate.get(pos) };
                if (isInsertable(s)) {
                    set(s, true);
                    solution.addLast(s);
                    if (find(pos + 1)) {
                        return true;
                    }
                    if (haltSearch) {
                        return false;
                    }
                    solution.removeLast();
                    set(s, false);
                }
            }
        }

        return false;
    }
}

@

We will be running many tasks in parallel so let's add a few helper classes for
that. [[SolutionFinderTaskResult]] has [[index]] field. This field denotes its
position in the list of sets of square sizes generated by
[[SquareSideLengthsGenerator]]. If we found a solution that has [[found]] set
to [[true]], then if all the results that have index less than this index and
[[found]] set to false, then it means this solution is an optimal solution.

<<8.8 Classes>>=
static class SolutionFinderTaskResult {
    final Deque<int[]> solution;
    final boolean found;
    final int index;

    public SolutionFinderTaskResult(boolean found, Deque<int[]> solution,
            int index) {
        this.solution = solution;
        this.found = found;
        this.index = index;
    }
}

static class SolutionFinderTask
        implements Callable<SolutionFinderTaskResult> {
    final int index;
    final Deque<int[]> initial;
    final List<Integer> sizes;
    final int n;

    SolutionFinderTask(int index, Deque<int[]> initial, List<Integer> sizes,
            int n) {
        this.index = index;
        this.initial = initial;
        this.sizes = sizes;
        this.n = n;
    }

    @Override
    public SolutionFinderTaskResult call() throws Exception {
        SolutionFinder finder = new SolutionFinder(initial, sizes, n);
        return new SolutionFinderTaskResult(finder.solutionFound,
                finder.solution,
                index);
    }
}

@

\begin{figure}
\centering
\begin{pspicture}(0,0)(5.2000,5.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{16}}
        \psframe(0.0000,0.0000)(2.5806,2.5806)
        \rput[bl](2.6806,0.1000){\tiny{15}}
        \psframe(2.5806,0.0000)(5.0000,2.4194)
        \rput[bl](0.1000,2.6806){\tiny{15}}
        \psframe(0.0000,2.5806)(2.4194,5.0000)
        \rput[bl](2.5194,3.3258){\tiny{11}}
        \psframe(2.4194,3.2258)(4.1935,5.0000)
        \rput[bl](2.8419,2.5194){\tiny{5}}
        \psframe(2.7419,2.4194)(3.5484,3.2258)
        \rput[bl](3.6484,2.5194){\tiny{5}}
        \psframe(3.5484,2.4194)(4.3548,3.2258)
        \rput[bl](4.2935,3.4871){\tiny{5}}
        \psframe(4.1935,3.3871)(5.0000,4.1935)
        \rput[bl](4.2935,4.2935){\tiny{5}}
        \psframe(4.1935,4.1935)(5.0000,5.0000)
        \rput[bl](4.4548,2.5194){\tiny{4}}
        \psframe(4.3548,2.4194)(5.0000,3.0645)
        \rput[bl](2.5194,2.6806){\tiny{2}}
        \psframe(2.4194,2.5806)(2.7419,2.9032)
        \rput[bl](2.5194,3.0032){\tiny{2}}
        \psframe(2.4194,2.9032)(2.7419,3.2258)
        \rput[bl](4.4548,3.1645){\tiny{2}}
        \psframe(4.3548,3.0645)(4.6774,3.3871)
        \rput[bl](4.7774,3.1645){\tiny{2}}
        \psframe(4.6774,3.0645)(5.0000,3.3871)
        \psframe(2.5806,2.4194)(2.7419,2.5806)
        \psframe(4.1935,3.2258)(4.3548,3.3871)
    }
\end{pspicture}
\begin{pspicture}(0,0)(5.2000,5.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{21}}
        \psframe(0.0000,0.0000)(3.0000,3.0000)
        \rput[bl](3.1000,0.1000){\tiny{14}}
        \psframe(3.0000,0.0000)(5.0000,2.0000)
        \rput[bl](0.1000,3.1000){\tiny{14}}
        \psframe(0.0000,3.0000)(2.0000,5.0000)
        \rput[bl](2.1000,3.1000){\tiny{14}}
        \psframe(2.0000,3.0000)(4.0000,5.0000)
        \rput[bl](3.1000,2.1000){\tiny{7}}
        \psframe(3.0000,2.0000)(4.0000,3.0000)
        \rput[bl](4.1000,2.1000){\tiny{7}}
        \psframe(4.0000,2.0000)(5.0000,3.0000)
        \rput[bl](4.1000,3.1000){\tiny{7}}
        \psframe(4.0000,3.0000)(5.0000,4.0000)
        \rput[bl](4.1000,4.1000){\tiny{7}}
        \psframe(4.0000,4.0000)(5.0000,5.0000)
    }
\end{pspicture}
\begin{pspicture}(0,0)(5.2000,5.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{19}}
        \psframe(0.0000,0.0000)(2.5676,2.5676)
        \rput[bl](2.6676,0.1000){\tiny{18}}
        \psframe(2.5676,0.0000)(5.0000,2.4324)
        \rput[bl](0.1000,2.6676){\tiny{18}}
        \psframe(0.0000,2.5676)(2.4324,5.0000)
        \rput[bl](3.4784,3.4784){\tiny{12}}
        \psframe(3.3784,3.3784)(5.0000,5.0000)
        \rput[bl](2.5324,3.2081){\tiny{7}}
        \psframe(2.4324,3.1081)(3.3784,4.0541)
        \rput[bl](2.5324,4.1541){\tiny{7}}
        \psframe(2.4324,4.0541)(3.3784,5.0000)
        \rput[bl](4.1541,2.5324){\tiny{7}}
        \psframe(4.0541,2.4324)(5.0000,3.3784)
        \rput[bl](2.9378,2.5324){\tiny{5}}
        \psframe(2.8378,2.4324)(3.5135,3.1081)
        \rput[bl](3.6135,2.5324){\tiny{4}}
        \psframe(3.5135,2.4324)(4.0541,2.9730)
        \rput[bl](2.5324,2.8027){\tiny{3}}
        \psframe(2.4324,2.7027)(2.8378,3.1081)
        \rput[bl](3.7486,3.0730){\tiny{3}}
        \psframe(3.6486,2.9730)(4.0541,3.3784)
        \psframe(2.5676,2.4324)(2.8378,2.7027)
        \psframe(3.3784,3.1081)(3.6486,3.3784)
        \psframe(2.4324,2.5676)(2.5676,2.7027)
        \psframe(3.5135,2.9730)(3.6486,3.1081)
    }
\end{pspicture}
\begin{pspicture}(0,0)(5.2000,5.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{23}}
        \psframe(0.0000,0.0000)(2.8049,2.8049)
        \rput[bl](2.9049,0.1000){\tiny{18}}
        \psframe(2.8049,0.0000)(5.0000,2.1951)
        \rput[bl](0.1000,2.9049){\tiny{18}}
        \psframe(0.0000,2.8049)(2.1951,5.0000)
        \rput[bl](3.6366,3.6366){\tiny{12}}
        \psframe(3.5366,3.5366)(5.0000,5.0000)
        \rput[bl](2.2951,3.7585){\tiny{11}}
        \psframe(2.1951,3.6585)(3.5366,5.0000)
        \rput[bl](3.7585,2.2951){\tiny{11}}
        \psframe(3.6585,2.1951)(5.0000,3.5366)
        \rput[bl](2.2951,2.9049){\tiny{7}}
        \psframe(2.1951,2.8049)(3.0488,3.6585)
        \rput[bl](3.1488,2.7829){\tiny{5}}
        \psframe(3.0488,2.6829)(3.6585,3.2927)
        \rput[bl](3.2707,2.2951){\tiny{4}}
        \psframe(3.1707,2.1951)(3.6585,2.6829)
        \rput[bl](2.9049,2.2951){\tiny{3}}
        \psframe(2.8049,2.1951)(3.1707,2.5610)
        \rput[bl](3.1488,3.3927){\tiny{3}}
        \psframe(3.0488,3.2927)(3.4146,3.6585)
        \psframe(2.8049,2.5610)(3.0488,2.8049)
        \psframe(3.4146,3.2927)(3.6585,3.5366)
        \psframe(3.0488,2.5610)(3.1707,2.6829)
        \psframe(3.4146,3.5366)(3.5366,3.6585)
    }
\end{pspicture}
\begin{pspicture}(0,0)(5.2000,5.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{22}}
        \psframe(0.0000,0.0000)(2.5581,2.5581)
        \rput[bl](2.6581,0.1000){\tiny{21}}
        \psframe(2.5581,0.0000)(5.0000,2.4419)
        \rput[bl](0.1000,2.6581){\tiny{21}}
        \psframe(0.0000,2.5581)(2.4419,5.0000)
        \rput[bl](2.5419,3.4721){\tiny{14}}
        \psframe(2.4419,3.3721)(4.0698,5.0000)
        \rput[bl](2.8907,2.5419){\tiny{8}}
        \psframe(2.7907,2.4419)(3.7209,3.3721)
        \rput[bl](4.1698,3.2395){\tiny{8}}
        \psframe(4.0698,3.1395)(5.0000,4.0698)
        \rput[bl](4.1698,4.1698){\tiny{8}}
        \psframe(4.0698,4.0698)(5.0000,5.0000)
        \rput[bl](4.4023,2.5419){\tiny{6}}
        \psframe(4.3023,2.4419)(5.0000,3.1395)
        \rput[bl](3.8209,2.5419){\tiny{5}}
        \psframe(3.7209,2.4419)(4.3023,3.0233)
        \rput[bl](2.5419,2.7744){\tiny{3}}
        \psframe(2.4419,2.6744)(2.7907,3.0233)
        \rput[bl](2.5419,3.1233){\tiny{3}}
        \psframe(2.4419,3.0233)(2.7907,3.3721)
        \rput[bl](3.8209,3.1233){\tiny{3}}
        \psframe(3.7209,3.0233)(4.0698,3.3721)
        \psframe(2.5581,2.4419)(2.7907,2.6744)
        \psframe(2.4419,2.5581)(2.5581,2.6744)
        \psframe(4.0698,3.0233)(4.1860,3.1395)
        \psframe(4.1860,3.0233)(4.3023,3.1395)
    }
\end{pspicture}
\begin{pspicture}(0,0)(5.2000,5.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{24}}
        \psframe(0.0000,0.0000)(2.5532,2.5532)
        \rput[bl](2.6532,0.1000){\tiny{23}}
        \psframe(2.5532,0.0000)(5.0000,2.4468)
        \rput[bl](0.1000,2.6532){\tiny{23}}
        \psframe(0.0000,2.5532)(2.4468,5.0000)
        \rput[bl](2.5468,3.6106){\tiny{14}}
        \psframe(2.4468,3.5106)(3.9362,5.0000)
        \rput[bl](3.1851,2.5468){\tiny{10}}
        \psframe(3.0851,2.4468)(4.1489,3.5106)
        \rput[bl](4.0362,4.0362){\tiny{10}}
        \psframe(3.9362,3.9362)(5.0000,5.0000)
        \rput[bl](4.2489,2.5468){\tiny{8}}
        \psframe(4.1489,2.4468)(5.0000,3.2979)
        \rput[bl](2.5468,2.9723){\tiny{6}}
        \psframe(2.4468,2.8723)(3.0851,3.5106)
        \rput[bl](4.4617,3.3979){\tiny{6}}
        \psframe(4.3617,3.2979)(5.0000,3.9362)
        \rput[bl](2.7596,2.5468){\tiny{4}}
        \psframe(2.6596,2.4468)(3.0851,2.8723)
        \rput[bl](4.0362,3.6106){\tiny{4}}
        \psframe(3.9362,3.5106)(4.3617,3.9362)
        \psframe(2.4468,2.5532)(2.6596,2.7660)
        \psframe(4.1489,3.2979)(4.3617,3.5106)
        \psframe(2.4468,2.7660)(2.5532,2.8723)
        \psframe(2.5532,2.4468)(2.6596,2.5532)
        \psframe(2.5532,2.7660)(2.6596,2.8723)
    }
\end{pspicture}
\begin{pspicture}(0,0)(5.2000,5.2000)
    \rput(0, 0){
        \rput[bl](0.1000,0.1000){\tiny{28}}
        \psframe(0.0000,0.0000)(2.8571,2.8571)
        \rput[bl](2.9571,0.1000){\tiny{21}}
        \psframe(2.8571,0.0000)(5.0000,2.1429)
        \rput[bl](0.1000,2.9571){\tiny{21}}
        \psframe(0.0000,2.8571)(2.1429,5.0000)
        \rput[bl](2.2429,2.9571){\tiny{14}}
        \psframe(2.1429,2.8571)(3.5714,4.2857)
        \rput[bl](3.6714,2.2429){\tiny{14}}
        \psframe(3.5714,2.1429)(5.0000,3.5714)
        \rput[bl](3.6714,3.6714){\tiny{14}}
        \psframe(3.5714,3.5714)(5.0000,5.0000)
        \rput[bl](2.2429,4.3857){\tiny{7}}
        \psframe(2.1429,4.2857)(2.8571,5.0000)
        \rput[bl](2.9571,2.2429){\tiny{7}}
        \psframe(2.8571,2.1429)(3.5714,2.8571)
        \rput[bl](2.9571,4.3857){\tiny{7}}
        \psframe(2.8571,4.2857)(3.5714,5.0000)
    }
\end{pspicture}
\caption{Solutions for prime side lengths ($31 < n < 50$).}
\end{figure}

Let's now implement the method that solves the trivial cases. It puts one large
square and then fills the remaining parts with the samller squares. The
parameter [[d]] can take 2 or 3 as values, and [[n]] is the square side length.
It returns a list of arrays of [[int]]s, which have three values in the format
as outlined in the problem description.

<<8.8 Methods>>=
private static Deque<int[]> trivial(int n, int d) {
    Deque<int[]> initial = new ArrayDeque<>();
    int h = n / d;
    initial.add(new int[] { 0, 0, (d - 1) * h });
    initial.add(new int[] { (d - 1) * h, (d - 1) * h, h });
    for (int i = 0; i < (d - 1); ++i) {
        initial.add(new int[] { (d - 1) * h, h * i, h });
        initial.add(new int[] { h * i, (d - 1) * h, h });
    }
    return initial;
}

@

Finally, we can start writing the method that will actually try to solve the
input. [[minSolutionSize]] is the minimal size of a solution we are trying to
find. This is used for prime values only (except 2) as only for them the
solution sizes seem to grow monotonically. [[adjust]] parameter is used to
change the sizes of the initial three squares.

<<8.8 Methods>>=
final static int[] primes = new int[] { 3, 5, 7, 11, 13, 17, 19, 23,
        29, 31, 37, 41, 43, 47 };

static Deque<int[]> getSolution(int n, int minSolutionSize, int adjust)
        throws InterruptedException, ExecutionException {
    if (n % 2 == 0) {
        return trivial(n, 2);
    } else if (n % 3 == 0) {
        return trivial(n, 3);
    } else {
        Deque<int[]> initial = new ArrayDeque<>();
        int size = n / 2 + 1;
        initial = new ArrayDeque<>();
        initial.add(new int[] { 0, 0, size + adjust });
        initial.add(new int[] { size + adjust, 0, size - 1 - adjust });
        initial.add(new int[] { 0, size + adjust, size - 1 - adjust });
        if (Arrays.binarySearch(primes, n) >= 0) {
            return getSolution(n, initial, minSolutionSize);
        } else {
            return getSolution(n, initial, 0);
        }
    }
}

@

Now we add a method that repeatedly calls [[getSolution]] with different
[[adjust]] values and selects the one that gives the minimal solution. It's
another heuristic: We increase [[adjust]] value up to 4, this seems to be
enough to give correct answers for $n \leq 50$.

<<8.8 Methods>>=
static Deque<int[]> getSolution(int n, int minSolutionSize)
        throws InterruptedException, ExecutionException {
    Deque<int[]> best = getSolution(n, minSolutionSize, 0);
    int size = n / 2 + 1;
    for (int i = 1; size + i < n - 1 && i < 4; ++i) {
        Deque<int[]> curr = getSolution(n, minSolutionSize, i);
        if (curr.size() < best.size()) {
            best = curr;
        }
    }
    return best;
}

@

The following method generates a list of sets of the square sizes and 
tries to tile them all doing this in parallel.

<<8.8 Methods>>=
static Deque<int[]> getSolution(int n, Deque<int[]> initial,
        int minSolutionSize)
        throws InterruptedException, ExecutionException {
    int count = 0;
    for (int[] s : initial) {
        count += s[2] * s[2];
    }
    int maxHeight = n - initial.getFirst()[2];
    SquareSideLengthsGenerator s = new SquareSideLengthsGenerator(
            maxHeight,
            n * n - count,
            minSolutionSize - initial.size());

    final ExecutorService executor = 
        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
    final CompletionService<SolutionFinderTaskResult> completionService = 
        new ExecutorCompletionService<>(executor);

    for (int i = 0; i < s.squareSizes.size(); ++i) {
        completionService.submit(
            new SolutionFinderTask(i, initial, s.squareSizes.get(i), n));
    }

    SolutionFinderTaskResult[] result = 
        new SolutionFinderTaskResult[s.squareSizes.size()];

    int lastIndex = 0;
    try {
        while (true) {
            Future<SolutionFinderTaskResult> f = completionService.take();
            result[f.get().index] = f.get();
            for (int i = lastIndex; i < result.length; ++i) {
                if (result[i] == null) {
                    break;
                } else if (!result[i].found) {
                    lastIndex++;
                } else if (result[i].found) {
                    return result[i].solution;
                }
            }
        }
    } finally {
        if (executor != null) {
            executor.shutdownNow();
        }
    }
}

@

And that's all. Now we can write our main method.

<<8.8 Main>>=
public static void main(String[] args) throws Exception {
    int minSolutionSize = 0;
    for (int i = 1; i <= 10; ++i) {
        System.out.println(i);
        if (i < 3) {
            System.out.println("0");
            continue;
        }
        Deque<int[]> solution = getSolution(i, minSolutionSize);
        minSolutionSize = solution.size();
        System.out.println(solution.size());
        for (int[] square : solution) {
            System.out.printf("%d %d %d\n", square[0] + 1,
                    square[1] + 1, square[2]);
        }
    }
}

@

This program is painfuly slow. It took 90 minutes on my laptop to find all the
solutions for the input range.

Note though that this program returns answers in the following format: The
value on the first line is the size of the square $n$, the next line has the
number of squares $s$, and the following $s$ lines have the coordinates and
sizes of the smaller squares.

To convert this into a program that you can submit to UVa online judge we
need another program, which reads this input and produces a program as
output.

Of course, we could have written the first program to output a program without
this intermediate output, but I used the output to also generate \LaTeX\ code for
the images with the solutions.

Here is the program that generates a program to be submitted to the judge.

<<Bigger Square Please Meta>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BiggerSquarePleaseMetaProgram {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    private static final String indend8 = "        ";
    private static final String indend4 = "    ";

    private static void printProgram(Map<Integer, List<List<Integer>>> solutions) {
        System.out.println("import java.io.BufferedReader;");
        System.out.println("import java.io.InputStreamReader;");
        System.out.println();
        System.out.println("public class BiggerSquarePlease {");
        System.out.println("    private static final BufferedReader reader = new BufferedReader(");
        System.out.println("            new InputStreamReader(System.in));");
        System.out.println();
        System.out.println("    private static final int[][][] table = new int[][][] {");

        for (int i = 0; i <= 50; ++i) {
            List<List<Integer>> solution = solutions.get(i);
            if (solution == null || solution.size() == 0) {
                System.out.println(indend8 + "{{}}, //" + i);
                continue;
            }
            System.out.print(indend8 + "{");
            for (List<Integer> s : solution) {
                System.out.printf("{%d, %d, %d},", s.get(0), s.get(1), s.get(2));
            }
            System.out.println("}, //" + i);
        }
        System.out.println(indend4 + "};");
        System.out.println();
        System.out.println(indend4 + "public static void main(String[] args) throws Exception {");
        System.out.println(indend4 + "    int n = Integer.parseInt(reader.readLine().trim());");
        System.out.println(indend4 + "    for (int i = 0; i < n; ++i) {");
        System.out.println(indend4 + "        int m = Integer.parseInt(reader.readLine().trim());");
        System.out.println(indend4 + "        int[][] solution = table[m];");
        System.out.println(indend4 + "        System.out.println(solution.length);");
        System.out.println(indend4 + "        for (int[] s : solution) {");
        System.out.println(indend4 + "          System.out.println(s[0] + \" \" + s[1] + \" \" + s[2]);");
        System.out.println(indend4 + "        }");
        System.out.println(indend4 + "    }");
        System.out.println(indend4 + "}");
        System.out.println("}");
        System.out.println();
    }

    public static void main(String[] args) throws Exception {
        String currentLine;
        Map<Integer, List<List<Integer>>> solutions = new HashMap<>();
        while ((currentLine = reader.readLine()) != null) {
            int n = Integer.parseInt(currentLine.trim());
            int s = Integer.parseInt(reader.readLine().trim());
            List<List<Integer>> solution = new ArrayList<>();
            for (int i = 0; i < s; ++i) {
                solution.add(stream(reader.readLine().trim().split(" "))
                        .filter(x -> !x.equals(""))
                        .map(Integer::parseInt)
                        .collect(toList()));
            }
            solutions.put(n, solution);
        }
        printProgram(solutions);
    }
}

@

\section{Graph Traversal}

\subsection{Bicoloring}

The problem is whether this graph is bipartite or not. It's easy to show if the
graph is bipartite or not by using the breadth-first search.  Each child of a
node is given an opposite color. If a node has been visited, we check if its
color is opposite to our current color, and if not, then this graph is not
bipartite. If we can complete the breadth-first search without encountering
that situation, then the graph is bipartite.

<<Bicoloring>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Bicoloring {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static void add(Map<Integer, Set<Integer>> graph, Integer nodeFrom,
            Integer nodeTo) {
        if (!graph.containsKey(nodeFrom)) {
            graph.put(nodeFrom, new HashSet<Integer>());
        }
        if (!graph.containsKey(nodeTo)) {
            graph.put(nodeTo, new HashSet<Integer>());
        }
        graph.get(nodeFrom).add(nodeTo);
        graph.get(nodeTo).add(nodeFrom);
    }

    private static boolean solve(
            Map<Integer, Set<Integer>> graph) {
        if (graph.size() == 0) {
            return true;
        }

        Deque<Integer> next = new ArrayDeque<>();
        Set<Integer> visited = new HashSet<>();
        Map<Integer, Boolean> colors = new HashMap<>();

        boolean color = true;
        Integer start = graph.keySet().iterator().next();
        next.push(start);
        colors.put(start, color);

        while (!next.isEmpty()) {
            Integer node = next.pop();
            color = colors.get(node);
            for (Integer adjNode : graph.get(node)) {
                if (!visited.contains(adjNode)) {
                    visited.add(adjNode);
                    next.addLast(adjNode);
                    colors.put(adjNode, !color);
                } else if (colors.get(adjNode) == color) {
                    return false;
                }
            }
        }

        return true;
    }

    public static void main(String[] args) throws IOException {
        while (true) {
            int n = Integer.parseInt(reader.readLine().trim());
            if (n == 0) {
                break;
            }
            n = Integer.parseInt(reader.readLine().trim());
            Map<Integer, Set<Integer>> graph = new HashMap<>();
            for (int j = 0; j < n; ++j) {
                List<Integer> toFrom = stream(
                        reader.readLine().trim().split(" "))
                                .filter(x -> !x.equals(""))
                                .map(Integer::parseInt)
                                .collect(toList());
                add(graph, toFrom.get(0), toFrom.get(1));
            }
            System.out
                    .println(
                            solve(graph) ? "BICOLORABLE." : "NOT BICOLORABLE.");
        }
    }
}

@

\subsection{Playing With Wheels}

A simple breadth-first search algorithm solves the task. However the judge has
a caveat. Even though the problem statement clearly says there will be a blank
line between two consecutive input cases, this is, apparently, not true. You
will get a "Runtime error" if you believe there is only one blank line or at
least one blank line. Assume there may be multiple blank lines or none at all!

<<Playing With Wheels>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class PlayingWithWheels {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    static class Node {
        int[] node;

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + Arrays.hashCode(node);
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            Node other = (Node) obj;
            if (!Arrays.equals(node, other.node))
                return false;
            return true;
        }

        public Node(List<Integer> s) {
            this.node = new int[s.size()];
            for (int i = 0; i < s.size(); ++i) {
                this.node[i] = s.get(i).intValue();
            }
        }

        public Node(Node node, int i, int p) {
            this.node = Arrays.copyOf(node.node, node.node.length);
            this.node[i] += p;
            if (this.node[i] < 0) {
                this.node[i] = 9;
            } else {
                this.node[i] %= 10;
            }
        }
    }

    private static Set<Node> adjacent(Node node) {
        Set<Node> adjacent = new HashSet<>();
        for (int i = 0; i < node.node.length; ++i) {
            adjacent.add(new Node(node, i, 1));
            adjacent.add(new Node(node, i, -1));
        }
        return adjacent;
    }

    private static int solve(Node start, Node end, Set<Node> forbidden) {
        if (start.equals(end)) {
            return 0;
        }

        Deque<Node> next = new ArrayDeque<>();
        Set<Node> visited = new HashSet<>();
        Map<Node, Integer> depths = new HashMap<>();

        int depth = 0;
        next.push(start);
        depths.put(start, depth);

        while (!next.isEmpty()) {
            Node node = next.pop();
            depth = depths.get(node);
            for (Node adjNode : adjacent(node)) {
                if (adjNode.equals(end)) {
                    return forbidden.contains(end) ? -1 : depth + 1;
                }
                if (!forbidden.contains(adjNode) &&
                        !visited.contains(adjNode)) {
                    visited.add(adjNode);
                    next.addLast(adjNode);
                    depths.put(adjNode, depth + 1);
                }
            }
        }

        return -1;
    }

    private static List<Integer> parseLine(String line) {
        return stream(line.trim().split(" "))
                .filter(x -> !x.equals(""))
                .map(Integer::parseInt)
                .collect(toList());
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            String currentLine = "";
            while ((currentLine = reader.readLine()).trim().equals(""))
                ;
            Node start = new Node(parseLine(currentLine));
            Node end = new Node(parseLine(reader.readLine()));
            int m = Integer.parseInt(reader.readLine().trim());
            Set<Node> forbidden = new HashSet<>();
            for (int j = 0; j < m; ++j) {
                forbidden.add(new Node(parseLine(reader.readLine())));
            }
            System.out.println(solve(start, end, forbidden));
        }
    }
}

@

\subsection{The Tourist Guide}

Direct application of maximin using the Floyd-Warshall algorithm (see
\cite{FW} and \cite{MAXIMIN}). Again and again the judge seems to disregard its
own format and inserts empty lines here and there, so watch out with your
input parsing!

<<The Tourist Guide>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;

public class TheTouristGuide {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static int solve(int[][] w, int size, int s, int e,
            int t) {
        int[][] d = new int[size][size];
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                d[i][j] = w[i][j];
            }
        }
        for (int i = 0; i < size; i++) {
            d[i][i] = 0;
        }
        for (int k = 0; k < size; k++) {
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    d[i][j] = Math.max(d[i][j], Math.min(d[i][k], d[k][j]));
                }
            }
        }
        return d[s][e];
    }

    private static List<Integer> parseLine(String line) {
        return stream(line.trim().split(" "))
                .filter(x -> !x.equals(""))
                .map(Integer::parseInt)
                .collect(toList());
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        int scenario = 1;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().isEmpty()) {
            List<Integer> nr = parseLine(currentLine);
            if (nr.get(0) == 0 && nr.get(1) == 0) {
                break;
            }
            int size = nr.get(0) + 1;
            int[][] w = new int[size][size];
            for (int i = 0; i < nr.get(1); ++i) {
                List<Integer> node = parseLine(reader.readLine());
                w[node.get(0)][node.get(1)] = node.get(2);
                w[node.get(1)][node.get(0)] = node.get(2);
            }
            List<Integer> sdt = parseLine(reader.readLine());
            int m = solve(w, size, sdt.get(0), sdt.get(1),
                    sdt.get(2));
            int c = (sdt.get(2)) / (m - 1);
            if (sdt.get(2) % (m - 1) != 0) {
                c++;
            }
            System.out.println("Scenario #" + scenario);
            System.out.println("Minimum Number of Trips = " + c);
            System.out.println();
            scenario++;
        }
    }
}

@

\subsection{Slash Maze}

We can easily use the depth-first search to find the cycles. The trick is 
how to read the maze and make it a graph. Well, that's not difficult either:
Imagine that each slash is in a two by two square, then imagine there are four
triangles in such a square. Each of these triangles is a node in a graph. There
will be two pairs of two triangles that will always be connected. Each of
the two by two squares will be connected to its neighbours from four sides
(provided there are such neighbours). So that's how we can construct a graph.
Once we've found a cycle, we need to divide its length by 2, because squares 
are made of two triangles.


<<Slash Maze>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class SlashMaze {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static int[] find(Map<Integer, List<Integer>> graph) {
        int count = 0;
        int max = 0;
        Set<Integer> visited = new HashSet<>();
        while (true) {
            int[] m = new int[] { 0, 0 };
            Integer src = graph.keySet().stream()
                    .filter(x -> !visited.contains(x))
                    .findFirst().orElse(Integer.MIN_VALUE);
            if (src == Integer.MIN_VALUE) {
                break;
            }
            find(graph, visited, src, m);
            count += m[0];
            max = Math.max(max, m[1]);
        }
        return new int[] { count, max / 2 };
    }

    private static void find(Map<Integer, List<Integer>> graph,
            Set<Integer> visited, int parent, int m[]) {
        Deque<Integer> stack = new ArrayDeque<>();
        Map<Integer, Integer> depths = new HashMap<>();
        int src = parent;
        stack.push(src);
        depths.put(src, 0);

        while (!stack.isEmpty()) {
            src = stack.pop();
            int depth = depths.get(src);
            if (!visited.contains(src)) {
                visited.add(src);
                for (int adj : graph.get(src)) {
                    if (adj == parent && depth > 2) {
                        m[0] += 1;
                        m[1] = Math.max(m[1], depth + 1);
                    }
                    stack.push(adj);
                    depths.put(adj, depth + 1);
                }
            }
        }
    }

    private static List<Integer> parseLine(String line) {
        return stream(line.trim().split(" "))
                .filter(x -> !x.equals(""))
                .map(Integer::parseInt)
                .collect(toList());
    }

    public static void add(Map<Integer, List<Integer>> graph, int src,
            int dst) {
        if (!graph.containsKey(src)) {
            graph.put(src, new ArrayList<>());
        }
        if (!graph.containsKey(dst)) {
            graph.put(dst, new ArrayList<>());
        }
        graph.get(src).add(dst);
        graph.get(dst).add(src);
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        int scenario = 1;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().isEmpty()) {
            List<Integer> wh = parseLine(currentLine);
            if (wh.get(0) == 0 && wh.get(1) == 0) {
                break;
            }
            int node = 0;
            Map<Integer, List<Integer>> graph = new HashMap<>();
            for (int i = 0; i < wh.get(1); ++i) {
                currentLine = reader.readLine().trim();
                for (char c : currentLine.toCharArray()) {
                    if (c == '/') {
                        add(graph, node, node + 1);
                        add(graph, node + 2, node + 3);
                    } else if (c == '\\') {
                        add(graph, node, node + 3);
                        add(graph, node + 1, node + 2);
                    }
                    add(graph, node, node - 2);
                    int nodeBelow = node + (wh.get(0) * 4) + 1;
                    add(graph, node + 3, nodeBelow);
                    node += 4;
                }
            }
            int[] result = find(graph);
            System.out.println("Maze #" + scenario + ":");
            if (result[0] > 0) {
                System.out.println(
                        result[0] + " Cycles; the longest has length " +
                                result[1] + ".");
            } else {
                System.out.println("There are no cycles.");
            }
            scenario++;
            System.out.println();
        }
    }
}

@

\subsection{Edit Step Ladders}

This problem can be solved in a few different ways. In this case I'm going to
solve it using an obvious way. This implementation isn't particularly fast, but
it solves the judge's input under 3 seconds.

OK, the way we solve it the following: We iterate on each input word. For each
word we find words that are one edit step away and that are lexicographically
preceding. Then we find edit step ladder lengths for each of those preceding
words, and choose the maximum. (But notice that we can build a table bottom up.
For this to work though words must be sorted in lexicographic order.) Current
word ladder length will be the maximum plus one. At the same time we keep track
of the maximum ladder length. Then we continue in this manner until we have
iterated on the whole list of words. Once finished, we will know the maximum.

<<Edit Step Ladders>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class EditStepLadders {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static void add(List<String> list, Set<String> dict, String word,
            String newWord) {
        if (newWord.compareTo(word) < 0 && dict.contains(newWord)) {
            list.add(newWord);
        }
    }

    private static List<String> adjacent(Set<String> dict, String word) {
        List<String> words = new ArrayList<>();
        char[] wordArr = word.toCharArray();
        for (int i = 0; i <= word.length(); ++i) {
            for (char c = 'a'; c <= 'z'; ++c) {
                add(words, dict, word, new StringBuilder().append(wordArr, 0, i)
                        .append(c)
                        .append(wordArr, i, wordArr.length - i).toString());
                if (i < word.length()) {
                    add(words, dict, word,
                            new StringBuilder().append(wordArr, 0, i)
                                    .append(c)
                                    .append(wordArr, i + 1,
                                            wordArr.length - i - 1)
                                    .toString());
                }
            }
            if (i < word.length()) {
                add(words, dict, word,
                        new StringBuilder().append(wordArr, 0, i)
                                .append(wordArr, i + 1, wordArr.length - i - 1)
                                .toString());
            }
        }
        return words;
    }

    private static int solve(Set<String> dict) {
        List<String> sorted = new ArrayList<>(dict);
        sorted.sort((x, y) -> x.compareTo(y));
        Map<String, Integer> lengths = new HashMap<>();
        Integer answer = 1;
        for (String word : sorted) {
            Integer max = 1;
            for (String source : adjacent(dict, word)) {
                Integer length = lengths.get(source);
                max = Math.max(max, length != null ? length + 1 : -1);
            }
            lengths.put(word, max);
            answer = Math.max(max, answer);
        }
        return answer;
    }

    public static void main(String[] args) throws IOException {
        Set<String> dict = new HashSet<>();
        String currentLine;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().isEmpty()) {
            dict.add(currentLine.trim());
        }
        System.out.println(solve(dict));
    }
}

@

\subsection{Tower of Cubes}

I'm not sure what would be the best way to solve this task using graph
algorithms, but this task can be easily solved using dynamic programming (just
like the previous task). We will keep a table to hold the intermediate
solutions (that is tower heights). We start with the heaviest cube and place it
in every possible way, that is just 6 ways. Then we take the next cube and try
to place it on every heavier cube provided the bottom color of this cube
matches the top color of the cube below. If we can place it it means we have
just improved the height of our tower, and we keep track of this in the table.
We keep placing cubes until we've exhausted all the cubes. To get the actual
tower we need to keep the references to the cubes below together with the index
of the top side.

The method [[buildUpTable]] builds up the [[table]] discussed above. And the
[[buildUpTower]] method traverses the stack via [[refs]] and builds up the
actual tower.

<<Tower of Cubes>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class TowerOfCubes {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    final static int[] map = new int[] { 1, 0, 3, 2, 5, 4 };
    final static String[] toString = new String[] { "front", "back",
            "left", "right", "top", "bottom" };
    final List<String> tower = new ArrayList<>();
    final int[][] table;
    final int[][][] refs;
    int height = 0;
    int colorIdx = 0;
    int head = 0;

    TowerOfCubes(List<List<Integer>> cubes) {
        table = new int[cubes.size()][6];
        refs = new int[cubes.size()][6][2];
        buildUpTable(cubes);
        buildUpTower();
    }

    private void buildUpTower() {
        int currentColorIdx = colorIdx;
        while (true) {
            tower.add((head + 1) + " " + toString[currentColorIdx]);
            int[] ref = refs[head][currentColorIdx];
            if (ref == null) {
                break;
            }
            head = ref[0];
            currentColorIdx = ref[1];
        }
    }

    private static int indexOf(int start, int value, List<Integer> array) {
        for (int i = start; i < array.size(); ++i) {
            if (array.get(i) == value) {
                return i;
            }
        }
        return -1;
    }

    private void buildUpTable(List<List<Integer>> cubes) {
        for (int current = cubes.size() - 1; current >= 0; --current) {
            List<Integer> cube = cubes.get(current);
            for (int j = 0; j < 6; ++j) {
                int color = cube.get(map[j]);
                int max = 1;
                refs[current][j] = null;
                for (int i = current + 1; i < cubes.size(); ++i) {
                    int topColorIndex = -1;
                    while ((topColorIndex = indexOf(topColorIndex + 1, color,
                            cubes.get(i))) != -1) {
                        if (max < table[i][topColorIndex] + 1) {
                            max = table[i][topColorIndex] + 1;
                            refs[current][j] = new int[] { i, topColorIndex };
                        }
                    }
                }
                table[current][j] = max;
                if (height < max) {
                    colorIdx = j;
                    height = max;
                    head = current;
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        int caseNo = 1;
        while ((currentLine = reader.readLine()) != null) {
            while (currentLine.trim().isEmpty()) {
                currentLine = reader.readLine();
            }
            int n = Integer.parseInt(currentLine.trim());
            if (n == 0) {
                break;
            }
            List<List<Integer>> cubes = new ArrayList<>();
            for (int i = 0; i < n; ++i) {
                cubes.add(stream(
                        reader.readLine().trim().split(" "))
                                .filter(x -> !x.equals(""))
                                .map(Integer::parseInt)
                                .collect(toList()));
            }
            System.out.println("Case #" + (caseNo++));
            TowerOfCubes toc = new TowerOfCubes(cubes);
            System.out.println(toc.height);
            toc.tower.stream().forEach(System.out::println);
            System.out.println();
        }
    }
}

@

\subsection{From Dusk Till Dawn}

First, we need to filter out all the trains that either depart after 6am or
arrive before 6pm or both. For the remaining trains we just do a classic
breadth-first search, considering routes $(SRC \rightarrow DST)_x$ as a node
and connecting them to other nodes $(SRC \rightarrow DST)_y$ if $SRC_y = DST_x$
and departure from $SRC_y$ is chronologically after $DST_x$ within the same
day. After we have discovered where we can arrive within one day, we check if
those destinations do not contain our required destination. If not, it means we
need to wait for another day and repeat the DFS again starting with these
nodes. We keep doing so until we either arrive at the required station or we
declare there's no such route.

<<From Dusk Till Dawn>>=
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class FromDuskTillDawn {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    static class Train {
        String src;
        int srcTime;
        String dst;
        int dstTime;

        public Train(String src, int srcTime, String dst, int dstTime) {
            this.src = src;
            this.srcTime = srcTime;
            this.dst = dst;
            this.dstTime = dstTime;
        }
    }

    private static List<Train> nextTrains(Train lastTrain,
            List<Train> trains) {
        List<Train> nextTrains = new ArrayList<>();
        for (Train next : trains) {
            if (next.src.equals(lastTrain.dst) &&
                    next.srcTime >= lastTrain.dstTime) {
                nextTrains.add(next);
            }
        }
        return nextTrains;
    }

    private static int solve(String src, String dst, List<Train> trains) {
        int count = 0;
        if (src.equals(dst)) {
            return count;
        }
        Set<String> reachable = new HashSet<>();
        Set<String> visited = new HashSet<>();
        reachable.add(src);
        visited.add(src);

        while (!reachable.isEmpty()) {
            Set<String> _reachable = new HashSet<>();
            for (String srcStation : reachable) {
                for (Train trn : trains) {
                    if (trn.src.equals(srcStation)) {
                        _reachable.addAll(getReachable(trn, trains));
                    }
                }
            }
            _reachable.removeAll(visited);
            visited.addAll(reachable);
            reachable = _reachable;
            if (reachable.contains(dst)) {
                return count;
            }
            count++;
        }

        return -1;
    }

    private static Set<String> getReachable(Train src,
            List<Train> trains) {
        Deque<Train> stack = new ArrayDeque<>();
        Set<Train> used = new HashSet<>();
        Set<String> reachable = new HashSet<>();
        stack.push(src);
        while (!stack.isEmpty()) {
            Train train = stack.pop();
            reachable.add(train.dst);
            List<Train> nextTrn = nextTrains(train, trains);
            for (Train nextTrain : nextTrn) {
                if (!used.contains(nextTrain)) {
                    stack.push(nextTrain);
                }
            }
            used.add(train);
        }
        return reachable;
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            List<Train> trains = new ArrayList<>();
            int m = Integer.parseInt(reader.readLine().trim());
            for (int j = 0; j < m; ++j) {
                List<String> input = Arrays
                        .stream(reader.readLine().trim().split(" "))
                        .filter(x -> !x.equals(""))
                        .collect(toList());
                int srcTime = Integer.parseInt(input.get(2));
                srcTime = srcTime <= 6 ? srcTime + 24 : srcTime;
                int dstTime = (srcTime + Integer.parseInt(input.get(3)));
                String src = input.get(0);
                String dst = input.get(1);
                if (!(srcTime >= 18 && srcTime <= 29 &&
                        dstTime >= 19 && dstTime <= 30)) {
                    continue;
                }
                trains.add(new Train(src.toLowerCase(), srcTime,
                        dst.toLowerCase(), dstTime));
            }
            List<String> input = Arrays
                    .stream(reader.readLine().trim().split(" "))
                    .filter(x -> !x.equals(""))
                    .collect(toList());
            int count = solve(input.get(0).toLowerCase(),
                    input.get(1).toLowerCase(), trains);
            System.out.println("Test Case " + (i + 1) + ".");
            if (count == -1) {
                System.out.println("There is no route Vladimir can take.");
            } else {
                System.out.println(
                        "Vladimir needs " + count + " litre(s) of blood.");
            }
        }
    }

}

@

\subsection{Hanoi Tower Troubles Again!}

This task must be a joke because it's trivial. (To much surprise, it's
designated as ``Level 3'' task.)

<<Hanoi Tower Troubles Again>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class HanoiTowerTroublesAgain {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static boolean isSquare(int v) {
        int i = (int) Math.sqrt(v);
        return i * i == v;
    }

    public static int solve(int m) {
        int j = 0;
        int i = 0;
        int[] v = new int[m];
        while (i < m) {
            j++;
            for (i = 0; i < m; ++i) {
                if (v[i] == 0 || isSquare(v[i] + j)) {
                    v[i] = j;
                    break;
                }
            }
        }
        return j - 1;
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            int m = Integer.parseInt(reader.readLine().trim());
            System.out.println(solve(m));
        }
    }

}

@


\section{Graph Algorithms}

\subsection{Freckles}

This task asks for a direct application of any suitable minimum spanning tree
algorithm. I've chosen to use Prim's algorithm as the input of this task
doesn't require any sophisticated data structures usage (like Fibonacci heaps
etc) and can be implemented in a naive way.

<<Freckles>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.List;

public class Freckles {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    static class Edge {
        final double[] src;
        final double[] dst;
        final double distance;

        public Edge(double[] src, double[] dst) {
            super();
            this.src = src;
            this.dst = dst;
            double xx = Math.abs(src[0] - dst[0]);
            double yy = Math.abs(src[1] - dst[1]);
            this.distance = Math.sqrt(xx * xx + yy * yy);
        }
    }

    private static Edge min(List<double[]> tree, List<double[]> nodes) {
        Edge min = null;
        for (double[] n : nodes) {
            for (double[] t : tree) {
                Edge edge = new Edge(t, n);
                if (min != null && edge.distance < min.distance ||
                        min == null) {
                    min = edge;
                }
            }
        }
        return min;
    }

    private static double mst(List<double[]> nodes) {
        double total = 0;
        List<double[]> tree = new ArrayList<>();
        tree.add(nodes.remove(0));
        while (!nodes.isEmpty()) {
            Edge edge = min(tree, nodes);
            total += edge.distance;
            tree.add(edge.dst);
            nodes.remove(edge.dst);
        }
        return total;
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        DecimalFormat format = new DecimalFormat("#0.00");
        reader.readLine();
        for (int i = 0; i < n; ++i) {
            int m = Integer.parseInt(reader.readLine().trim());
            List<double[]> nodes = new ArrayList<>();
            for (int j = 0; j < m; ++j) {
                List<Double> tuple = stream(reader.readLine().trim().split(" "))
                        .filter(x -> !x.equals(""))
                        .map(Double::parseDouble)
                        .collect(toList());
                nodes.add(new double[] { tuple.get(0), tuple.get(1) });
            }
            System.out.println(format.format(mst(nodes)));
            if (i < n - 1) {
                System.out.println();
            }
            reader.readLine();
        }
    }

}

@

\subsection{The Necklace}

It's a bit tricky problem. At first sight this looks like a Hamiltonian path
problem, but having 1000 nodes in a graph makes this impossible to solve this
way.  The problem, as the hint in the book suggests, can be solved if modeled
as an Eulerian cycle problem. Each color becomes a node in the graph. Next we
find all the simple cycles in the graph using the DFS, and then merge them into
an Eulerian cycle. Before doing so we check if all of this graph's nodes have
even degrees (as per Euler's theorem), and if they do, we search for the
Eulerian cycle; otherwise, we conclude this graph can't have an Eulerian cycle.

<<The Necklace>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class TheNecklace {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static final int MAX_COL = 51;
    private final List<List<Integer>> nodes;
    private final List<List<Boolean>> traversed = new ArrayList<>();
    private final List<int[]> path = new ArrayList<>();

    private TheNecklace(List<List<Integer>> nodes) {
        this.nodes = nodes;
        for (int i = 0; i < MAX_COL; ++i) {
            traversed.add(new ArrayList<>());
        }

        boolean eulerian = true;
        int src = -1;
        for (int i = 0; i < nodes.size(); ++i) {
            List<Integer> node = nodes.get(i);
            if (node.size() % 2 != 0) {
                eulerian = false;
                break;
            }
            for (int j = 0; j < node.size(); ++j) {
                traversed.get(i).add(false);
            }
            if (src == -1 && node.size() > 0) {
                src = i;
            }
        }

        if (eulerian) {
            traverse(src, 0);
        }
    }

    private void traverse(int src, int pos) {
        for (int i = 0; i < nodes.get(src).size(); ++i) {
            if (traversed.get(src).get(i)) {
                continue;
            }
            traversed.get(src).set(i, true);
            int dst = nodes.get(src).get(i);
            for (int j = 0; j < nodes.get(dst).size(); ++j) {
                if (nodes.get(dst).get(j) == src &&
                        !traversed.get(dst).get(j)) {
                    traversed.get(dst).set(j, true);
                    break;
                }
            }
            path.add(pos, new int[] { src, dst });
            traverse(dst, pos + 1);
        }
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            int m = Integer.parseInt(reader.readLine().trim());
            List<List<Integer>> nodes = new ArrayList<>();
            for (int j = 0; j < MAX_COL; ++j) {
                nodes.add(new ArrayList<>());
            }
            for (int j = 0; j < m; ++j) {
                List<Integer> node = stream(
                        reader.readLine().trim().split(" "))
                                .filter(x -> !x.equals(""))
                                .map(Integer::parseInt)
                                .collect(toList());
                nodes.get(node.get(0)).add(node.get(1));
                nodes.get(node.get(1)).add(node.get(0));
            }
            TheNecklace necklace = new TheNecklace(nodes);
            System.out.println("Case #" + (i + 1));
            if (necklace.path.size() != 0) {
                necklace.path
                        .forEach(x -> System.out.println(x[0] + " " + x[1]));
            } else {
                System.out.println("some beads may be lost");
            }
            if (i < n - 1) {
                System.out.println();
            }
        }
    }

}

@

\subsection{Fire Stations}

Each intersection is a node in the graph. We are asked to minimize the maximum
distance to the other nodes in the graph by placing a fire station at one of
the nodes in the graph provided we already have a set of fire stations at some
of the nodes (or not at all).

OK, because we may have fire stations at some of the intersections, we need to
calculate the distances from those fire stations to the other nodes. We keep
track of the maximum distances and keep track of the minimum of these maximum
distances. Next, at every intersection we calculate the distances to the other
intersections using the Dijkstra's algorithm. We keep track of the minimum of
the maximum distances for each intersection and select the one that minimizes
it, as required by the problem.

Our Dijkstra's algorithm implementation is not efficient as it doesn't use a
priority queue. Standard Java doesn't have any proper priority queue. (Well, it
does, but it's not a proper priority queue as it doesn't have ``decrease
priority'' semantics to it.) But because the problem has a generous time out of
more than 6 seconds, a naive implementation is sufficient.

Let's break it down. First, I/O. We are going to represent the graph as a map,
where key is the intersection index (node index) and the value is a list of
[[AdjNode]] edges which are simply tuples with indexes of adjacent nodes and
the weights (distances) of the corresponding edges. The [[solve]] method is the
main method that will determine the index of an intersection where a new fire
station needs to be built. It takes as input a set of indexes of the existing
fire stations and the graph itself.

<<Fire Stations>>=
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toList;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class FireStations {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    static class AdjNode {
        final int index;
        final long dist;

        public AdjNode(int index, long dist) {
            this.index = index;
            this.dist = dist;
        }
    }

    <<10.3 Methods>>
    <<10.3 Solver>>

    private static List<Integer> parseLine(String line) {
        return stream(line.trim().split(" "))
                .filter(x -> !x.equals(""))
                .map(Integer::parseInt)
                .collect(toList());
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        reader.readLine();
        for (int i = 0; i < n; ++i) {
            List<Integer> fi = parseLine(reader.readLine());
            Set<Integer> stations = new HashSet<>();
            for (int j = 0; j < fi.get(0); ++j) {
                stations.add(Integer.parseInt(reader.readLine().trim()));
            }
            Map<Integer, List<AdjNode>> graph = new HashMap<>();
            String currentLine = "";
            while ((currentLine = reader.readLine()) != null &&
                    !currentLine.trim().isEmpty()) {
                List<Integer> node = parseLine(currentLine);
                graph.putIfAbsent(node.get(0), new ArrayList<>());
                graph.putIfAbsent(node.get(1), new ArrayList<>());
                graph.get(node.get(0))
                        .add(new AdjNode(node.get(1), node.get(2)));
                graph.get(node.get(1))
                        .add(new AdjNode(node.get(0), node.get(2)));
            }

            System.out.println(solve(stations, graph));

            if (i < n - 1) {
                System.out.println();
            }
        }
    }

}

@

Now let's implement the Dijkstra's algorithm. It'll be a naive implementation,
but this is sufficient to solve this task in an acceptable time.

The method takes the [[graph]] and the source [[src]] node index. It returns an
array where each item represents the shortest path cost (in terms of distances)
from the [[src]] to the corresponding item. Array's index corresponds to
the intersection number.

<<10.3 Methods>>=
private static long[] dijkstra(
        Map<Integer, List<AdjNode>> graph, int src) {
    long[] distances = new long[501];
    Arrays.fill(distances, Long.MAX_VALUE);
    Set<Integer> next = new HashSet<>();
    for (Entry<Integer, List<AdjNode>> e : graph.entrySet()) {
        next.add(e.getKey());
    }
    distances[src] = 0L;

    while (!next.isEmpty()) {
        long min = -1;
        int node = -1;
        for (Integer nextNode : next) {
            if (distances[nextNode] < min || min == -1) {
                min = distances[nextNode];
                node = nextNode;
            }
        }
        next.remove(node);
        for (AdjNode adj : graph.get(node)) {
            long newMin = min + adj.dist;
            if (newMin < distances[adj.index]) {
                distances[adj.index] = newMin;
            }
        }
    }

    return distances;
}

@

OK, once we've got the array of distances for specific source, we will need to
somehow merge it with an array of distances of a different source. For that we
are going to use the following method. It'll take the nodes collection and two
distance arrays, and produce a new one by retaining the minimal distances.

<<10.3 Methods>>=
private static long[] merge(Collection<Integer> nodes,
        long[] prevDistances,
        long[] distancesFromStation) {
    long[] merged = Arrays.copyOf(prevDistances,
            prevDistances.length);
    for (Integer j : nodes) {
        merged[j] = Math.min(merged[j],
                distancesFromStation[j]);
    }
    return merged;
}

@

Finally, we can now implement the main [[solve]] method.

<<10.3 Solver>>=
private static int solve(Set<Integer> stations,
     Map<Integer, List<AdjNode>> graph) {
    long[] distances = null;
    for (Integer station : stations) {
        long[] distancesFromStation = dijkstra(graph, station);
        distances = distances != null ? merge(graph.keySet(), distances,
                distancesFromStation) : distancesFromStation;
    }

    long minMax = Long.MAX_VALUE;
    int newStationNumber = 1;
    for (Integer src : graph.keySet()) {
        if (stations.contains(src)) {
            continue;
        }
        long[] distancesFromStation = dijkstra(graph, src);
        long[] newDistances = merge(graph.keySet(), distances,
                distancesFromStation);
        long max = 0;
        for (Integer i : graph.keySet()) {
            max = Math.max(newDistances[i], max);
        }
        if (max < minMax) {
            minMax = max;
            newStationNumber = src;
        }
    }

    return newStationNumber;
}
@

\subsection{Railroads}

Well, I failed to solve this task with the BFS. I thought it would perfectly
work, but the judge repeatedly declined my solution with the ``Time Limit
Exceeded'' verdict despide of a number of attempts with various optimizations.
It was clear: A different approach was required here. In the end, I have
purloined the idea for this task solution from \cite{AlexLange}.

<<Railroads>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class Railroads {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static final int MAX_TIME = 2360;
    private static final int DEP_TIME = 0;
    private static final int DEP_STATION = 1;
    private static final int ARR_TIME = 2;
    private static final int ARR_STATION = 3;

    private static int[] solve(int m, List<int[]> trains, int source,
            int startTime, int destination) {
        Map<Integer, int[]> times = new HashMap<>();

        for (int j = 0; j < m; ++j) {
            int[] tab = new int[MAX_TIME];
            Arrays.fill(tab, -1);
            times.put(j, tab);
        }

        Collections.sort(trains,
                (x, y) -> x[DEP_TIME] != y[DEP_TIME] ? x[DEP_TIME] - y[DEP_TIME]
                        : x[ARR_TIME] - x[ARR_TIME]);

        for (int[] t : trains) {
            int[] tab = times.get(t[ARR_STATION]);
            if (t[DEP_STATION] == source && t[DEP_TIME] >= startTime) {
                for (int j = t[ARR_TIME]; j < tab.length; ++j) {
                    tab[j] = Math.max(tab[j], t[DEP_TIME]);
                }
            } else if (times.get(t[DEP_STATION])[t[DEP_TIME]] >= 0) {
                for (int j = t[ARR_TIME]; j < tab.length; ++j) {
                    tab[j] = Math.max(tab[j],
                            times.get(t[DEP_STATION])[t[DEP_TIME]]);
                }
            }
        }

        for (int j = 0; j < MAX_TIME; ++j) {
            if (times.get(destination)[j] > 0) {
                return new int[] { times.get(destination)[j], j };
            }
        }

        return null;
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            int m = Integer.parseInt(reader.readLine().trim());
            Map<String, Integer> names = new HashMap<>();
            for (int j = 0; j < m; ++j) {
                names.put(reader.readLine().trim(), j);
            }

            List<int[]> trains = new ArrayList<>();
            int trainsCount = Integer.parseInt(reader.readLine().trim());
            for (int j = 0; j < trainsCount; ++j) {
                int stops = Integer.parseInt(reader.readLine().trim());
                int[] prev = null;
                for (int k = 0; k < stops; ++k) {
                    List<String> stop = Arrays
                            .stream(reader.readLine().trim().split(" "))
                            .filter(x -> !x.isEmpty())
                            .collect(Collectors.toList());
                    if (prev != null) {
                        trains.add(new int[] {
                                prev[0], prev[1],
                                Integer.parseInt(stop.get(0)),
                                names.get(stop.get(1)) });
                    }
                    prev = new int[] { Integer.parseInt(stop.get(0)),
                            names.get(stop.get(1)) };
                }
            }

            int startTime = Integer.parseInt(reader.readLine().trim());
            String sourceStr = reader.readLine().trim();
            int source = names.get(sourceStr);
            String destinationStr = reader.readLine().trim();
            int destination = names.get(destinationStr);

            int[] result = solve(m, trains, source, startTime, destination);

            System.out.println("Scenario " + (i + 1));
            if (result != null) {
                System.out.printf("Departure %04d %s\n", result[0], sourceStr);
                System.out.printf("Arrival   %04d %s\n", result[1],
                        destinationStr);
            } else {
                System.out.println("No connection");
            }
            System.out.println();
        }
    }

}

@

\subsection{War}

I failed to solve this task without help, so the solution below is based on the
solution from \cite{TOW}.

The idea is to use a data structure called Disjoin-set\cite{DS}. For that we
will maintain an array of $2n$ size, first half of which will be maintained
for friends and the other half of it will be maintained for enemies; a trick
purloined from \cite{TOW}. And that is key.

Now what we need to do is carefully maintain friends and enemies sets. If $i$
and $j$ are both in the same set, it means they are friends. To check this we
check if they are either both in the friends sets, or both are in the enemies
sets.  Similarly, to test if $i$ and $j$ are enemies, we check if one of them
is in friends sets, and the other is in the enemies sets, or vice versa.

Now when we execute [[setFriends(i, j)]] we first check if $i$ and $j$ aren't
enemies. If not, we join $i$ and $j$, because friends of our friends are our
friends too. We also join enemies, because enemies of our friends are our
enemies. When we execute [[setEnemies(i, j)]], we join $i$ and enemies of $j$.
Similarly we join $j$ and enemies of $i$ together. This is because enemies of
our enemies are our friends. 

<<War>>=
import java.util.*;

public class War {
    private final int[] friends;
    private final int n;

    public War(int n) {
        this.n = n;
        friends = new int[2 * (n + 1)];
        for (int i = 0; i < 2 * (n + 1); ++i) {
            friends[i] = i;
        }
    }

    public int enemy(int i) {
        return i + n;
    }

    public int find(int i) {
        if (friends[i] != i) {
            friends[i] = find(friends[i]);
        }
        return friends[i];
    }

    public void union(int i, int j) {
        if (find(i) != find(j)) {
            friends[find(j)] = find(i);
        }
    }

    private boolean setFriends(int i, int j) {
        if (areEnemies(i, j)) {
            return false;
        }
        union(i, j);
        union(enemy(i), enemy(j));
        return true;
    }

    private boolean setEnemies(int i, int j) {
        if (areFriends(i, j)) {
            return false;
        }
        union(i, enemy(j));
        union(j, enemy(i));
        return true;
    }

    private boolean areFriends(int i, int j) {
        return find(i) == find(j) ||
                find(enemy(i)) == find(enemy(j));
    }

    private boolean areEnemies(int i, int j) {
        return find(i) == find(enemy(j)) ||
                find(j) == find(enemy(i));
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        War war = new War(s.nextInt());
        while (s.hasNextInt()) {
            switch (s.nextInt()) {
                case 0:
                    return;
                case 1:
                    if (!war.setFriends(s.nextInt(), s.nextInt())) {
                        System.out.println(-1);
                    }
                    break;
                case 2:
                    if (!war.setEnemies(s.nextInt(), s.nextInt())) {
                        System.out.println(-1);
                    }
                    break;
                case 3:
                    System.out.println(war.areFriends(s.nextInt(), s.nextInt()) ? 1 : 0);
                    break;
                case 4:
                    System.out.println(war.areEnemies(s.nextInt(), s.nextInt()) ? 1 : 0);
                    break;
                default:
                    throw new IllegalArgumentException();
            }
        }
    }
}

@

\subsection{Tourist Guide}

This task is about finding articulation points in a graph. There are known
algorithms to do this in linear time\cite{ARP}. The only ``catch'' in this task
is that you need to run articulation points search for each connected
component, which there may be more than one, although the problem's description
may suggest that town road map is a connected component. Apparently, that's not
true for this task.

The [[findCutPoints]] is a direct translaction of the pseudo-code from \cite{ARP}.

<<Tourist Guide>>=
import java.util.*;

public class TouristGuide {
    private final Set<String> cutVertices = new HashSet<>();
    private final Set<String> visited = new HashSet<>();
    private final Map<String, String> parent = new HashMap<>();
    private final Map<String, Integer> depths = new HashMap<>();
    private final Map<String, Integer> low = new HashMap<>();
    private final Map<String, Set<String>> graph;

    public TouristGuide(Map<String, Set<String>> graph) {
        this.graph = graph;
        Set<String> processed = new HashSet<>();
        Set<String> roots = new HashSet<>(graph.keySet());
        while (processed.size() != graph.keySet().size()) {
            findCutVertices(roots.iterator().next(), 0);
            processed.addAll(visited);
            roots.removeAll(visited);
        }
    }

    public Set<String> getCutVertices() {
        return cutVertices;
    }

    private void findCutVertices(String v, int d) {
        visited.add(v);
        depths.put(v, d);
        low.put(v, d);
        int childCount = 0;
        boolean isCutVertix = false;
        for (String n : graph.get(v)) {
            if (!visited.contains(n)) {
                parent.put(n, v);
                findCutVertices(n, d + 1);
                childCount++;
                if (low.get(n) >= depths.get(v)) {
                    isCutVertix = true;
                }
                low.put(v, Math.min(low.get(v), low.get(n)));
            } else if (!n.equals(parent.get(v))) {
                low.put(v, Math.min(low.get(v), depths.get(n)));
            }
        }
        if ((parent.containsKey(v) && isCutVertix) ||
                (!parent.containsKey(v) && childCount > 1)) {
            cutVertices.add(v);
        }
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = 0;
        int c = 0;
        while ((n = s.nextInt()) != 0) {
            c++;
            if (c > 1) {
                System.out.println();
            }
            s.nextLine();
            for (int i = 0; i < n; ++i) {
                s.nextLine();
            }
            Map<String, Set<String>> graph = new HashMap<>();
            int edgesCount = s.nextInt();
            s.nextLine();
            for (int i = 0; i < edgesCount; ++i) {
                String[] edge = s.nextLine().replaceAll("\\s+", " ").split(" ");
                assert (edge.length == 2);
                graph.putIfAbsent(edge[0], new HashSet<>());
                graph.putIfAbsent(edge[1], new HashSet<>());
                graph.get(edge[0]).add(edge[1]);
                graph.get(edge[1]).add(edge[0]);
            }
            TouristGuide t = new TouristGuide(graph);
            List<String> cutPoints = new ArrayList<>(t.getCutVertices());
            cutPoints.sort(String::compareTo);
            System.out.println(String.format("City map #%d: %d camera(s) found", c, cutPoints.size()));
            cutPoints.forEach(System.out::println);
        }
    }
}

@

\subsection{The Grand Dinner}

This task can be modeled as a flow problem. Team sizes would become capacities of
the edges coming from the source node. There would be $M$ nodes connecting to the
source node, where $M$ is the number of teams. Then there would be another set of
nodes corresponding to the tables; there would be $N$ such nodes. Each edge 
leaving a ``table'' node and ending in the sink node would have a capacity of the
corresponding table. Then each ``team'' node would be connected to each
``table'' node with an edge of capacity 1. Then we find a maximum flow in
this network. If we can't saturate each edge leaving the source node to their
maximum capacity, it means there's no solution to the problem. Otherwise a 
solution exists and the solution corresponds to the edges between ``team'' and
``table'' nodes that have flows through the edges.

I have tried submitting a solution based on Edmonds-Karp algorithm (as it is
easy to implement), but the tests have large cases which make this algorithm
impractical due to its running time complexity $O(VE^2)$. I got ``Time Limit
Exceeded'' verdicts. (And what I was hoping for?)  A solution using push
relabel algorithm may pass the tests as it has much better running time
complexity of $O(V^2E)$.

However, as the book suggests, there is a greedy algorithm. The strategy is
to try to seat the largest team to the tables with the largest capacities
first. Keep doing until you either succeed or fail.

<<The Grand Dinner>>=
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

public class TheGrandDinner {
    static class Tuple {
        final int v1;
        int v2;

        public Tuple(int v1, int v2) {
            this.v1 = v1;
            this.v2 = v2;
        }
    }

    public static List<List<Integer>> solve(List<Tuple> teams, List<Tuple> tables) {
        List<List<Integer>> solution = new ArrayList<>();
        teams.forEach(x -> solution.add(new ArrayList<>()));
        teams.sort((x, y) -> Integer.compare(y.v2, x.v2));
        for (int i = 0; i < teams.size(); ++i) {
            tables.sort((x, y) -> Integer.compare(y.v2, x.v2));
            for (int j = 0; j < tables.size() && teams.get(i).v2 > 0; ++j) {
                solution.get(teams.get(i).v1 - 1).add(tables.get(j).v1);
                tables.get(j).v2--;
                teams.get(i).v2--;
                if (tables.get(j).v2 < 0) {
                    return null;
                }
            }
            if (teams.get(i).v2 > 0) {
                return null;
            }
        }
        return solution;
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = 0;
        int m = 0;

        while (true) {
            m = s.nextInt();
            n = s.nextInt();
            if (m == 0 && n == 0) {
                break;
            }
            List<Tuple> teams = new ArrayList<>();
            List<Tuple> tables = new ArrayList<>();
            for (int i = 0; i < m; ++i) {
                teams.add(new Tuple(i + 1, s.nextInt()));
            }
            for (int i = 0; i < n; ++i) {
                tables.add(new Tuple(i + 1, s.nextInt()));
            }

            List<List<Integer>> solution = solve(teams, tables);
            if (solution != null) {
                System.out.println(1);
                for (int i = 0; i < m; i++) {
                    System.out.println(solution.get(i)
                            .stream().map(String::valueOf)
                            .collect(Collectors.joining(" ")));
                }
            } else {
                System.out.println(0);
            }
        }
    }

}

@

\subsection{The Problem with the Problem Setter}

Imagine a graph with four types of nodes: the source, the sink, problem nodes,
category nodes. Now, from the source to each problem node there are edges, each
with capacity of 1. Then, corresponding to the test case, there are edges from
problems to category nodes, again each with capacity of 1. From category nodes
there are edges to the sink. These nodes will have capacities corresponding to
the number of problems we want to have in this category, as per test case. Now
we just need to find a maximum flow through this network. Then, if the nodes
coming to the sink nodes are all saturated, we found a solution, otherwise
there's no a solution.

Let's first define [[Edge]] and [[Node]] classes and define a method to add
edges to the graph. When adding an edge, we will add its reversed version to
the graph too. This will be needed when calculating a maximum flow.

<<The Problem with the Problem Setter>>=
import java.util.*;

public class TheProblemWithTheProblemSetter {
    private final Map<Node, List<Edge>> graph = new HashMap<>();

    static class Node {
        public static final Node SINK = new Node(0, Type.SINK);
        public static final Node SOURCE = new Node(0, Type.SOURCE);
        final int value;
        final Type type;

        enum Type {
            SINK,
            SOURCE,
            PROBLEM,
            CATEGORY
        }

        public Node(int v, Type type) {
            this.value = v;
            this.type = type;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Node node = (Node) o;
            return value == node.value &&
                    type == node.type;
        }

        @Override
        public int hashCode() {
            return Objects.hash(value, type);
        }
    }

    static class Edge {
        final Node start;
        final Node end;
        final int capacity;
        int flow;
        int residual;
        Edge reversed;

        public Edge(Node start, Node end, int capacity, int flow, int residual) {
            this.start = start;
            this.end = end;
            this.capacity = capacity;
            this.flow = flow;
            this.residual = residual;
        }
    }

    private void add(Node from, Node to, int capacity) {
        graph.putIfAbsent(from, new ArrayList<>());
        graph.putIfAbsent(to, new ArrayList<>());
        Edge toEdge = new Edge(from, to, capacity, 0, capacity);
        Edge fromEdge = new Edge(to, from, capacity, 0, 0);
        toEdge.reversed = fromEdge;
        fromEdge.reversed = toEdge;
        graph.get(from).add(toEdge);
        graph.get(to).add(fromEdge);
    }

    <<10.8 Solver>>

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = 0;
        int m = 0;
        while (true) {
            TheProblemWithTheProblemSetter solver = new TheProblemWithTheProblemSetter();
            m = s.nextInt();
            n = s.nextInt();
            if (m == 0 && n == 0) {
                break;
            }
            int targetFlow = 0;
            <<10.8 Input>>
            <<10.8 Output>>
        }
    }
}

@

Now let's add code to read the input. We will all also calculate a target
[[maximumFlow]]. If our maximum flow is less than this value, then it means
there's no solution.

<<10.8 Input>>=
for (int i = 1; i <= m; ++i) {
    int capacity = s.nextInt();
    targetFlow += capacity;
    solver.add(new Node(i, Node.Type.CATEGORY), Node.SINK, capacity);
}
for (int i = 1; i <= n; ++i) {
    Node node = new Node(i, Node.Type.PROBLEM);
    solver.add(Node.SOURCE, node, 1);
    int neighbors = s.nextInt();
    solver.add(node, Node.SOURCE, 1);
    while (neighbors > 0) {
        Node toNode = new Node(s.nextInt(), Node.Type.CATEGORY);
        solver.add(node, toNode, 1);
        neighbors--;
    }
}
@

Output code is trivial. To read off the solution, we access [[graph]] of the
solver. It will have flow information in it for each edge.

<<10.8 Output>>=
if (solver.solve() == targetFlow) {
    System.out.println(1);
    for (int i = 1; i <= m; ++i) {
        Node category = new Node(i, Node.Type.CATEGORY);
        List<Edge> edges = solver.graph.get(category);
        boolean first = true;
        for (Edge p : edges) {
            Edge edge = p.reversed;
            if (edge.end.equals(category) && edge.flow == edge.capacity) {
                System.out.print((first ? "" : " ") + edge.start.value);
                first = false;
            }
        }
        System.out.println();
    }
} else {
    System.out.println(0);
}
@

Now the solver part. To find a maximum flow I'm going to use Edmonds-Karp 
algorithm. The idea is that we keep finding augmenting paths and increase the
flow by 1 in the path. We don't need to find the bottlenecks in the augmenting
paths because due to how we construct the graph it is always going to be 1. We
keep doing it until there are augmenting paths. Once we can't find an
augmenting path, we are done.

<<10.8 Solver>>=
private int solve() {
    int flow = 0;
    while (true) {
        Deque<Node> q = new ArrayDeque<>();
        q.push(Node.SOURCE);
        Set<Node> visited = new HashSet<>();
        Map<Node, Edge> path = new HashMap<>();
        while (!q.isEmpty() && !path.containsKey(Node.SINK)) {
            Node n = q.pollFirst();
            visited.add(n);
            for (Edge e : graph.get(n)) {
                if (!visited.contains(e.end) && e.residual > 0 && 
                        !e.end.equals(Node.SOURCE)) {
                    q.addLast(e.end);
                    path.put(e.end, e);
                }
            }
        }
        if (!path.containsKey(Node.SINK)) {
            return flow;
        }
        Edge edge = path.get(Node.SINK);
        while (edge != null) {
            edge.flow++;
            edge.residual--;
            edge.reversed.flow--;
            edge.reversed.residual++;
            edge = path.get(edge.start);
        }
        flow++;
    }
}
@

\section{Dynamic Programming}

\subsection{Is Bigger Smarter?}

The task is pretty simple: We iterate on the sorted input data and try
to extend the sequence. We keep two arrays, [[res]], to keep the lengths of the
sequences, and [[ref]], to keep the references to the previous elements.

<<Is Bigger Smarter>>=
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class IsBiggerSmarter {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static int[] solve(List<int[]> input) {
        if (input.size() == 1) {
            return new int[] { 0 };
        }
        List<int[]> sorted = new ArrayList<>(input);
        Collections.sort(sorted, (x, y) -> Integer.compare(x[0], y[0]));
        int[] res = new int[sorted.size()];
        int[] ref = new int[sorted.size()];
        int index = 0;

        for (int i = 0; i < sorted.size(); ++i) {
            res[i] = 1;
            ref[0] = -1;
            for (int j = 0; j < i; ++j) {
                if (sorted.get(j)[0] < sorted.get(i)[0] &&
                        sorted.get(j)[1] > sorted.get(i)[1]) {
                    if (res[i] < res[j] + 1) {
                        res[i] = res[j] + 1;
                        ref[i] = j;
                        if (index == -1 || res[i] > res[index]) {
                            index = i;
                        }
                    }
                }
            }
        }

        int[] solution = new int[res[index]];
        int i = solution.length - 1;
        do {
            solution[i] = sorted.get(index)[2];
            index = ref[index];
            i--;
        } while (index != -1 && i >= 0);

        return solution;
    }

    public static void main(String[] args) throws Exception {
        String currentLine;
        List<int[]> input = new ArrayList<>();
        int i = 0;
        while ((currentLine = reader.readLine()) != null) {
            Scanner s = new Scanner(currentLine);
            input.add(new int[] { s.nextInt(), s.nextInt(), i });
            s.close();
            i++;
        }
        int[] solution = solve(input);
        System.out.println(solution.length);
        for (int idx : solution) {
            System.out.println(idx + 1);
        }
    }
}

@

\subsection{Distinct Subsequences}

Because the input is very simple, let me do that first.

<<Distinct Subsequences>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;

public class Main {
    <<11.2 Slow Recursive>>
    <<11.2 Fast Tabular>>
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(reader.readLine().trim());
        for (int i = 0; i < n; ++i) {
            String line = reader.readLine().trim();
            String subs = reader.readLine().trim();
            Main solver = new Main();
            //System.out.println(solver.slowRecursive(line, subs));
            System.out.println(solver.fastTabular(line, subs));
        }
    }
}

@

Now, a recursive solution: Sequentially scan for the last character of Z in
X. Suppose its index is $i$. Now recursively call the function with a substring
of $X[1, i-1]$ and $Z'$, which is the same as $Z$ except its last character
removed. The answer is the sum of the returned values from the recursive calls
for each such index $i$. This solution is slow (even with memoization) and the
online judge will not accept it, because of the time limit. But the solution is
correct and instructive.

<<11.2 Slow Recursive>>=
private BigInteger slowRecursive(String line, String subs) {
    BigInteger[][] memo = new BigInteger[line.length()+1][subs.length()+1];
    return slowRecursive(line, subs, memo);
}

private BigInteger slowRecursive(String line, String subs, BigInteger[][] memo) {
    BigInteger count = BigInteger.ZERO;

    if (memo[line.length()][subs.length()] != null) {
        return memo[line.length()][subs.length()];
    }

    for (int i = line.length() - 1; i >= 0; --i) {
        if (line.charAt(i) == subs.charAt(subs.length() - 1)) {
            if (subs.length() == 1) {
                count = count.add(BigInteger.ONE);
            } else {
                count = count.add(slowRecursive(line.substring(0, i),
                        subs.substring(0, subs.length() - 1), memo));
            }
        }
    }

    memo[line.length()][subs.length()] = count;
    return count;
}

@

A tabular solution. Let's create a table [[memo]] of $|X|$ by $|Z|$ size. We
will fill out the first row and the first column with zeroes and we will assume
our indexing starts from 1 because it is easier to maintain the table that
way.  Then, we start going through $Z$ character by character and fill out the
table row by row. If it's the second row, then we just put 1 on the first
occurrence of the matching characters and keep increasing it on subsequent
matches. The second row answers the question of what if our $Z$ had only the
first character. So we just count how many times it occurs in $X$. The third 
row (and all subsequent rows) of the table, which corresponds to the case when
$Z$ has more than one character, will be constructed in a different way. First, if
characters don't match for the given cell, we simply take the previous value to
this cell. It basically says that the number of subsequences hasn't changed for
this longer $X$. But if the characters match, we calculate the value by taking
$memo[i-1][j-1] + memo[j-1][i]$. Essentially we are saying that the number of
subsequences of $Z[1,i]$ in $X[1,j]$ is the same as the number of subsequences
of $Z[1,i-1]$ in $X[1,j-1]$ plus the number of subsequences of $Z[1,i]$ in
$X[1,j-1]$. Once we have completed filling out the table, it will contain the
answers for all pairs of lengths of $X$ and $Z$.

\begin{table}[]
\begin{center}
\begin{tabular}{@{}lllllllll@{}}
\toprule
\textbf{}  & \textbf{} & \textbf{b} & \textbf{a} & \textbf{b} & \textbf{g} & \textbf{b} & \textbf{a} & \textbf{g} \\ \midrule
           & 0         & 0          & 0          & 0          & 0          & 0          & 0          & 0          \\
\textbf{b} & 0         & 1          & 1          & 2          & 2          & 3          & 3          & 3          \\
\textbf{a} & 0         & 0          & 1          & 1          & 1          & 1          & 4          & 4          \\
\textbf{g} & 0         & 0          & 0          & 0          & 1          & 1          & 1          & 5          \\ \bottomrule
\end{tabular}
\end{center}
\end{table}

<<11.2 Fast Tabular>>=
private BigInteger fastTabular(String line, String subs) {
    BigInteger[][] memo = new BigInteger[line.length() + 1][subs.length() + 1];
    for (int i = 0; i <= subs.length(); ++i) {
        memo[0][i] = BigInteger.ZERO;
    }
    for (int i = 0; i <= line.length(); ++i) {
        memo[i][0] = BigInteger.ZERO;
    }
    for (int i = 1; i <= subs.length(); ++i) {
        for (int j = 1; j <= line.length(); ++j) {
            if (line.charAt(j - 1) == subs.charAt(i - 1)) {
                if (i == 1) {
                    memo[j][i] = memo[j - 1][i].add(BigInteger.ONE);
                } else {
                    memo[j][i] = memo[j - 1][i].add(memo[j - 1][i - 1]);
                }
            } else {
                memo[j][i] = memo[j - 1][i];
            }
        }
    }
    return memo[line.length()][subs.length()];
}

@

\subsection{Weights and Measures}

Let's say we are given $T_1, \ldots, T_n$ turtles, and two functions
$weight(T_i)$ and $strength(T_i)$. We are asked to find a largest stack of
turtles such that for each turtle in this stack its capacity (i.e. strength
minus its own weight) is larger or equal to the weights of all turtles above
it.

Let us take a random proper stack of turtles $T_{t_1}, \ldots, T_{t_m}$. Since
this is a proper stack, it means that for all $i \leq m$ the following
inequality holds:

$$\sum_{j=1}^{i-1}weight(T_{t_j}) \leq strength(T_{t_i}) - weight(T_{t_i})$$

In order to allow for recursive construction we need to define an ordering of
turtles in our stacks. Let's assume we have a proper stack of turtles $T_{t_1},
\ldots, T_{t_i}, T_{t_{i+1}}, \ldots, T_{t_{m}}$, and let's also assume that
$strength(T_{t_{i+1}}) < strength(T_{t_{i}})$. (Remember: $strength(T_i)$
returns turtle's strength which is how much this turtle can carry including its
own weight.) But note that $T_{t_{i+1}}$ and $T_{t_{i}}$ can be swapped and a
new stack of turtles would still be a proper stack. That is $T_{t_1}, \ldots,
T_{t_{i+1}}, T_{t_{i}}, \ldots, T_{t_{m}}$ would be a proper stack. This
observation means that we can take any proper stack and change it to a
non-decreasing stack with respect to the strengths, which will also be a proper
stack. (For a formal proof of this claim see \cite{TURTLE}.)

This also means that once we have sorted our input by strengths, we can proceed
along the sorted list of turtles and obtain proper ordered stacks. 

The sub-problem $S_j$, $j \leq n$ is the following: Among all the stacks of
height $k \leq j$ built from turtles $T_1, \ldots, T_j$ find the lightest one.
Let's assume we have solved $S_{j-1}$. If we want to build the lightest stack
from $T_1, \ldots, T_j$ of length $k$, let's call it $W_k^j$, we look at the
lightest stack of lengths $k$ and $k-1$ build from $T_1, \ldots, T_{j-1}$.
Let's call them $W_k^{j-1}$ and $W_{k-1}^{j-1}$ correspondingly. If we can
extend the stack $W_{k-1}^{j-1}$ with $T_j$ and it is lighter than $W_k^{j-1}$,
then that's our lightest stack built from $T_1, \ldots, T_j$, otherwise we let
$W_k^j=W_k^{j-1}$ (see \cite{TURTLE}).

<<Weights and Measures>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;

public class WeightsAndMeasures {
    private static class Turtle {
        int weight;
        int strength;

        public Turtle(int weight, int strength) {
            this.weight = weight;
            this.strength = strength;
        }
    }

    public static int solve(List<Turtle> input) {
        input.sort(Comparator.comparingInt(x -> x.strength));
        int[][] W = new int[2][input.size() + 1];
        W[0][0] = 0;
        for (int i = 1; i <= input.size(); ++i) {
            W[0][i] = Integer.MAX_VALUE;
            W[1][i] = Integer.MAX_VALUE;
        }

        for (int i = 1; i <= input.size(); ++i) {
            Turtle t = input.get(i - 1);
            for (int k = i; k >= 1; --k) {
                if (W[0][k - 1] <= (t.strength - t.weight)) {
                    W[1][k] = Math.min(W[0][k], W[0][k - 1] + t.weight);
                } else {
                    W[1][k] = W[0][k];
                }
            }
            System.arraycopy(W[1], 0, W[0], 0, W[1].length);
            for (int k = 1; k <= input.size(); ++k) {
                W[1][k] = Integer.MAX_VALUE;
            }
        }
        for (int i = input.size(); i >= 0; --i) {
            if (W[0][i] < Integer.MAX_VALUE) {
                return i;
            }
        }
        return 1;
    }


    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String line;
        List<Turtle> input = new ArrayList<>();
        while ((line = reader.readLine()) != null) {
            Scanner scanner = new Scanner(line);
            input.add(new Turtle(scanner.nextInt(), scanner.nextInt()));
        }
        System.out.println(solve(input));
    }
}

@

\subsection{Unidirectional TSP}

The difficulty with this task is how to reconstruct the path in lexicographic
order. That tricky thing to realize is that we should start from the end rather
than start. For each cell we inspect the next cells with the minimum path and
choose the minimum. If there are multiple choices, we prefer the one that has
the smaller row number. For each current cell we also store the references to
the cell with the minimum path.  Keep doing it column by column. Once we at the
first column, we identify the cell with the minimum path and start following the
[[next]] references.  That resulting path is the answer.

<<Unidirectional TSP>>=
import java.io.IOException;
import java.util.Scanner;

import static java.util.Arrays.stream;
import static java.util.stream.Collectors.joining;

public class UnidirectionalTSP {
    private static class Cell {
        Cell next;
        int row;
        int value;
        int minPath;

        public Cell(int value, int row) {
            this.value = value;
            this.minPath = Integer.MAX_VALUE;
            this.row = row;
        }
    }

    final Cell[][] table;
    final int m;
    final int n;
    int minPath;
    int[] path;

    public UnidirectionalTSP(Cell[][] table, int m, int n) {
        this.table = table;
        this.m = m;
        this.n = n;
        this.path = new int[n];
        this.minPath = Integer.MAX_VALUE;
        solve();
    }

    private Cell get(int row, int col) {
        if (row > m - 1) {
            return table[0][col];
        } else if (row < 0) {
            return table[m - 1][col];
        }
        return table[row][col];
    }

    private void solve() {
        for (int row = 0; row < m; ++row) {
            Cell cell = get(row, n - 1);
            cell.minPath = cell.value;
            cell.next = null;
        }
        for (int col = n - 2; col >= 0; --col) {
            for (int row = 0; row < m; ++row) {
                Cell cell = get(row, col);
                int min = Integer.MAX_VALUE;
                for (int i = -1; i <= 1; ++i) {
                    Cell next = get(row + i, col + 1);
                    if (min > next.minPath) {
                        min = next.minPath;
                        cell.next = next;
                    } else if (min == next.minPath) {
                        if (cell.next == null || (cell.next != null && cell.next.row > next.row)) {
                            cell.next = next;
                        }
                    }
                }
                cell.minPath = min + cell.value;
            }
        }
        Cell cell = null;
        for (int row = 0; row < m; ++row) {
            Cell curr = get(row, 0);
            if (cell == null || (cell != null && curr.minPath < cell.minPath)) {
                cell = curr;
            }
        }

        this.minPath = cell.minPath;
        for (int col = 0; col < n; ++col) {
            path[col] = cell.row + 1;
            cell = cell.next;
        }
    }

    public static void main(String[] args) throws IOException {
        Scanner s = new Scanner(System.in);
        while (s.hasNextInt()) {
            int m = s.nextInt(); // rows
            int n = s.nextInt(); // cols
            Cell[][] table = new Cell[m][n];
            for (int i = 0; i < m * n; ++i) {
                table[i / n][i % n] = new Cell(s.nextInt(), i / n);
            }
            UnidirectionalTSP main = new UnidirectionalTSP(table, m, n);
            System.out.println(stream(main.path).mapToObj(String::valueOf).collect(joining(" ")));
            System.out.println(main.minPath);
        }
    }

}

@

\subsection{Cutting Sticks}

It's an easy task: At every cut point we recursively calculate the minimum cost
for the two remaining sticks, so their sum plus length of the current stick
gives us the total cost. Once we have tried every cut point in this way we
select the one with the minimum cost. With a simple memoization the program
runs within allowed time limit.

<<Cutting Sticks>>=
import java.util.Scanner;

public class CuttingSticks {
    private final int[] cuts;
    private final int length;
    private final Integer[][] memo = new Integer[1000][1000];

    public CuttingSticks(int[] cuts, int length) {
        this.cuts = cuts;
        this.length = length;
    }

    public int solve() {
        return solve(0, length);
    }

    private int solve(int start, int end) {
        if (memo[start][end] != null) {
            return memo[start][end];
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < cuts.length; ++i) {
            if (cuts[i] > start && cuts[i] < end) {
                min = Math.min(min, solve(start, cuts[i]) + solve(cuts[i], end));
            }
        }
        memo[start][end] = min < Integer.MAX_VALUE ? (end - start) + min : 0;
        return memo[start][end];
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        while (true) {
            int length = s.nextInt();
            if (length == 0) {
                break;
            }
            int n = s.nextInt();
            int[] cuts = new int[n];
            for (int i = 0; i < n; ++i) {
                cuts[i] = s.nextInt();
            }
            CuttingSticks solver = new CuttingSticks(cuts, length);
            System.out.println(String.format("The minimum cutting is %d.", solver.solve()));
        }
    }
}

@

\subsection{Ferry Loading}

A naive recursive implementation with memoization solves this task. We put the
first car in the queue on the left side of the ferry and try recursively to
obtain a maximum loading solution using the remaining queue and spaces. We put
the same car on the right side of the ferry and try recursively again to obtain
a maximum loading solution. Then out of these two solutions we get the maximum
one and return it. Note that the total lengths of the cars on both sides of the
ferry and the total number of cars on the ferry can be used as a key to the table to
lookup the solutions for the remaining spaces and the remaining cars in the
queue. And because both sides are equal in sizes, the solutions are symmetric.
This means we can order lengths in increasing order while looking up the table
or putting a value into it.

<<Ferry Loading>>=
import java.util.*;

public class FerryLoading {
    private final List<Integer> queue;
    private final int ferryLength;
    private final Map<Integer, Map<Integer, Map<Integer, Deque<Boolean>>>> memo = new HashMap<>();

    public FerryLoading(int ferryLength, List<Integer> queue) {
        this.ferryLength = ferryLength * 100;
        this.queue = queue;
    }

    private Deque<Boolean> solve() {
        return solve(0, new ArrayDeque<>(), 0, 0);
    }

    private Deque<Boolean> solve(int i, Deque<Boolean> solution, int leftLength, int rightLength) {
        if (i > queue.size() - 1) {
            return new ArrayDeque<>(solution);
        }
        Integer next = queue.get(i);
        int min = Math.min(leftLength, rightLength);
        int max = Math.max(leftLength, rightLength);

        if (memo.get(min) != null) {
            Map<Integer, Deque<Boolean>> m = memo.get(min).get(max);
            if (m != null && m.containsKey(i)) {
                return m.get(i);
            }
        }

        Deque<Boolean> leftSolution = null;
        if (next + leftLength <= ferryLength) {
            solution.addLast(true);
            leftSolution = solve(i + 1, solution, next + leftLength, rightLength);
            solution.removeLast();
        }

        Deque<Boolean> rightSolution = null;
        if (next + rightLength <= ferryLength) {
            solution.addLast(false);
            rightSolution = solve(i + 1, solution, leftLength, next + rightLength);
            solution.removeLast();
        }

        Deque<Boolean> finalSolution = null;
        if (leftSolution == null && rightSolution == null) {
            finalSolution = new ArrayDeque<>(solution);
        } else if (leftSolution == null || rightSolution == null) {
            finalSolution = leftSolution == null ? rightSolution : leftSolution;
        } else {
            finalSolution = leftSolution.size() > rightSolution.size() ? leftSolution : rightSolution;
        }

        memo.putIfAbsent(min, new HashMap<>());
        memo.get(min).putIfAbsent(max, new HashMap<>());
        memo.get(min).get(max).putIfAbsent(i, finalSolution);
        return finalSolution;
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        for (int i = 0; i < n; i++) {
            List<Integer> queue = new ArrayList<>();
            int ferry = s.nextInt();
            int k;
            while ((k = s.nextInt()) != 0) {
                queue.add(k);
            }
            FerryLoading solver = new FerryLoading(ferry, queue);
            Deque<Boolean> solution = solver.solve();
            System.out.println(solution.size());
            solution.stream().map(x -> x ? "starboard" : "port").forEach(System.out::println);
            if (i < n - 1) {
                System.out.println();
            }
        }
    }
}

@

\section{Grids}

\subsection{Ant on a Chessboard}

It's easy to note that each stripe $k$ starts with $k^2$. This means that we
can obtain stripes' number by taking the ceiling of the value of the square
root of the input value, that is for any value $v$ we have $k=\lceil \sqrt{v} \rceil$.
This tells us one of the coordinates, but whether that's $x$ or $y$ depends on
whether $k$ is odd or even.

\begin{table}[h]
\begin{center}
\begin{tabular}{llllll}
\textbf{5} & \textit{25} & 24         & 23         & 22          & {\ul 21}   \\ 
\textbf{4} & 10          & 11         & 12         & {\ul 13}    & 20         \\
\textbf{3} & \textit{9}  & 8          & {\ul 7}    & 14          & 19         \\
\textbf{2} & 2           & {\ul 3}    & 6          & 15          & 18         \\
\textbf{1} & {\ul 1}     & \textit{4} & 5          & \textit{16} & 17         \\
           & \textbf{1}  & \textbf{2} & \textbf{3} & \textbf{4}  & \textbf{5} \\ 
\end{tabular}
\end{center}
\end{table}

The values in italics in the table are equal to $m = k^2-k+1$. Now once we know
$k$ and $m$ we can work out the coordiantes. If $v$ equals $m$ it's the
``corner'' and so both $x$ and $y$ are the same, that is equal to $k$.
Otherwise, depending on whether $k$ is odd or even, we can work out the
coordinates for each case. For example, if $k$ is odd and $v \ge m$, then
$x=k^2-v+1$. (You can convince yourself by looking at the table.) Similarly we
can work out for the rest of the cases, that is when $v < m$ and when $k$ is
either odd or even.

<<Ant On a Chessboard>>=
import java.util.Scanner;

public class AntOnAChessboard {
    private static long[] get(long v) {
        long k = (long) Math.ceil(Math.sqrt(v));
        long m = k * k - k + 1;
        boolean isOdd = k % 2 == 1;
        if (v == m) {
            return new long[]{k, k};
        } else if (v >= m) {
            if (isOdd) {
                return new long[]{k * k - v + 1, k};
            }
            return new long[]{k, k * k - v + 1};
        } else {
            if (isOdd) {
                return new long[]{k, k - (m - v)};
            }
            return new long[]{k - (m - v), k};
        }
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        while (true) {
            long v = s.nextLong();
            if (v == 0) {
                break;
            }
            long[] ans = get(v);
            System.out.println(String.format("%d %d", ans[0], ans[1]));
        }
    }
}

@

\subsection{The Monocycle}

The requirement to find the minimum time needed to reach the destination or
conclude the destination is not reachable hints at finding a path in a graph.
Each cell of the grid is effectively being a node with edges connected to its
neighbours, and having no edge the cell when it's a hash sign in it. One thing
that tripped me a bit with this problem was that the monocyclist can only turn
left or right. It can not turn 180 degrees with the cost of 2 seconds. So we
parse the input, prepare a lookup table that we use to determine if we can go
to a cell or not, and then run breadth-first search. Once we reach the target
cell, we check what color our wheel's segment is touching the cell at the
moment, and if that's green, we stop, otherwise continue searching. Eventually
we either find it, or conclude there is no path. 

<<The Monocycle>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Objects;
import java.util.Queue;
import java.util.Set;

public class TheMonocycle {
    private static int UP = 0;
    private static int RIGHT = 1;
    private static int DOWN = 2;
    private static int LEFT = 3;

    private static int[][] DIRECTION = {
            {0, -1}, {1, 0}, {0, 1}, {-1, 0}
    };

    private static int[][] TURNS = {
            {RIGHT, LEFT}, {UP, DOWN}, {RIGHT, LEFT}, {UP, DOWN}
    };

    private static class Cell {
        int x, y;
        public Cell(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    private static class VisitedCell {
        int x, y;
        int d;
        int cost;
        int color;

        @Override
        public boolean equals(Object o) {
            if (o == null || getClass() != o.getClass()) return false;
            VisitedCell that = (VisitedCell) o;
            return x == that.x && y == that.y && color == that.color && d == that.d;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y, d, color);
        }

        public VisitedCell(int x, int y, int d, int cost, int color) {
            this.x = x;
            this.y = y;
            this.d = d;
            this.cost = cost;
            this.color = color;
        }
    }

    private static void visit(int x, int y, int d, int cost, int color, Queue<VisitedCell> queue, Set<VisitedCell> visited) {
        VisitedCell vn = new VisitedCell(x, y, d, cost, color);
        if (!visited.contains(vn)) {
            queue.add(vn);
            visited.add(vn);
        }
    }

    public static int search(Cell[][] grid, Cell source, Cell target) {
        Queue<VisitedCell> queue = new LinkedList<>();
        VisitedCell sourceCell = new VisitedCell(source.x, source.y, UP, 0, 0);
        queue.add(sourceCell);
        Set<VisitedCell> visited = new HashSet<>();
        visited.add(sourceCell);

        while (!queue.isEmpty()) {
            VisitedCell current = queue.poll();
            if (current.x == target.x && current.y == target.y && current.color == 0) {
                return current.cost;
            }
            Cell next = grid[current.y + DIRECTION[current.d][1]][current.x + DIRECTION[current.d][0]];
            if (next != null) {
                visit(next.x, next.y, current.d, current.cost + 1, (current.color + 1) % 5, queue, visited);
            }
            for (int direction: TURNS[current.d]) {
                visit(current.x, current.y, direction, current.cost + 1, current.color, queue, visited);
            }
        }
        return -1;
    }

    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static void main(String[] args) throws IOException {
        String currentLine;
        int caseNum = 0;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().isEmpty()) {
            String[] dimensions = currentLine.split(" ");
            int h = Integer.parseInt(dimensions[0]);
            int w = Integer.parseInt(dimensions[1]);
            if (h == 0 && w == 0) {
                break;
            }
            if (caseNum > 0) {
                System.out.println();
            }
            System.out.println("Case #" + (++caseNum));
            Cell start = null;
            Cell end = null;
            Cell[][] grid = new Cell[h + 2][w + 2];
            for (int i = 0; i < h; i++) {
                currentLine = "#" + reader.readLine() + "#";
                for (int j = 0; j < currentLine.length(); ++j) {
                    if (currentLine.charAt(j) == '#') {
                        grid[i + 1][j] = null;
                    } else {
                        Cell cell = new Cell(j, i + 1);
                        grid[i + 1][j] = cell;
                        if (currentLine.charAt(j) == 'S') {
                            start = cell;
                        } else if (currentLine.charAt(j) == 'T') {
                            end = cell;
                        }
                    }
                }
            }

            int cost = search(grid, start, end);
            if (cost > -1) {
                System.out.println("minimum time = " + cost + " sec");
            } else {
                System.out.println("destination not reachable");
            }
        }
    }
}

@

\subsection{Star}

Notice that this star can easily be represented as two dimensional array. Each
cell has a neighbour to the sides, and also up and down. Once the star is just
a two dimensional array, you can define the starting points for each of the
lines. Each of the lines traversal is either going right one cell, or going up
and right, or going right and up, or going left and up etc. Once you know
these, you can define traversal rule for each line. Next, start with the
maximum number for each line, and put that number in each cell of the line, you
can do that as long as the cell doesn't already have a value. If the cell
already has a value, you can't overwrite it if it's smaller than the value you
trying to put in there. Once you've done this for each line, you will have the
maximum possible sum in the star. However, it may happen that placing values
for subsequent lines may invalidate maximum values placed in the previous
lines. If you detect this situation, then it's not possible to have the star in
the first place, so you conclude ``NO SOLUTION''. 

To get the minimum you need to remember that some cells lie on the
intersections of up to two other lines. This means that it may happen that if
those lines have the same maximum value, then it would only be needed to be
counted once, since all of these can be placed in the same cell, and the rest
of the cells can be assumed zero. So, get the largest value with the largest
overlap of the lines from the star we just filled. Add that value to the
accumulator, and note the lines, so that on subsequent retrieval of the next
largest value you ignore these lines. Keep doing the same until you exhausted
all the lines. The resulting value is the minimum.

<<Star>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

public class Main {
    private static int E = -2;
    private static int X = -1;
    private static int[][] STAR = {
            {X, X, X, X, X, E, X, X, X, X, X, },
            {X, X, X, X, E, E, E, X, X, X, X, },
            {E, E, E, E, E, E, E, E, E, E, E, },
            {X, E, E, E, E, E, E, E, E, E, X, },
            {X, E, E, E, E, E, E, E, E, E, X, },
            {E, E, E, E, E, E, E, E, E, E, E, },
            {X, X, X, X, E, E, E, X, X, X, X, },
            {X, X, X, X, X, E, X, X, X, X, X, },
    };

    private static int[][] START = {
            {2, 0}, {3, 1}, {4, 1}, {5, 0}, {5, 0},
            {5, 2}, {6, 4}, {7, 5}, {7, 5}, {6, 6},
            {5, 8}, {5, 10}
    };

    private static int[][][] TRAVERSE = {
            {{0, 1}}, {{0, 1}}, {{0, 1}}, {{0, 1}}, {{0, 1}, {-1, 0}},
            {{0, 1}, {-1, 0}}, {{-1, 0}, {0, 1}},
            {{-1, 0}, {0, 1}}, {{-1, 0}, {0, -1}},
            {{-1, 0}, {0, -1}}, {{0, -1}, {-1, 0}},
            {{0, -1}, {-1, 0}},
    };

    private static int sum(int[][] star) {
        int sum = 0;
        for (int i = 0; i < star.length; i++) {
            for (int j = 0; j < star[i].length; ++j) {
                sum += star[i][j] > X ? star[i][j] : 0;
            }
        }
        return sum;
    }

    private interface LineCellVisitor {
        void visit(int i, int j, int line);
    }

    private static void traverseLines(int[][] star, int[] maxs, LineCellVisitor v) {
        for (int start = 0; start < maxs.length; ++start) {
            int d = 0;
            int i = START[start][0]; // row
            int j = START[start][1]; // col
            while (i >= 0 && j >= 0 && i < star.length && j < star[0].length && star[i][j] != X) {
                v.visit(i, j, start);
                i = i + TRAVERSE[start][d][0];
                j = j + TRAVERSE[start][d][1];
                d = (d + 1) % TRAVERSE[start].length;
            }
        }
    }

    private static boolean isValid(int[][] star, int[] maxs) {
        boolean[] valid = new boolean[12];
        traverseLines(star, maxs, (i, j, line) -> {
            if (star[i][j] == maxs[line]) {
                valid[line] = true;
            }
        });
        for (int i = 0; i < valid.length; i++) {
            if (!valid[i]) return false;
        }
        return true;
    }

    private static void fill(int[][] star, int[] maxs, Set[][] overlap) {
        traverseLines(star, maxs, (i, j, line) -> {
            star[i][j] = star[i][j] == E ? maxs[line] : Math.min(star[i][j], maxs[line]);
            if (overlap[i][j] == null) {
                overlap[i][j] = new HashSet();
            }
            overlap[i][j].add(line);
        });
    }

    private static Set<Integer> findNextLines(int[][] star,
                                              Set<Integer>[][] overlap,
                                              int[] maxs, int curr,
                                              Set<Integer> ignore) {
        Set<Integer> nextLines = new HashSet<>();
        for (int i = 0; i < star.length; i++) {
            for (int j = 0; j < star[i].length; j++) {
                if (star[i][j] != maxs[curr]) continue;
                Set<Integer> count = overlap[i][j].stream()
                        .filter(l -> maxs[l] == maxs[curr]).collect(Collectors.toSet());
                count.removeAll(ignore);
                if (count.size() > nextLines.size() && count.contains(curr)) {
                    nextLines = count;
                }
            }
        }
        return nextLines;
    }

    private static Set<Integer> nextLines(int[][] star,
                                          Set<Integer>[][] overlap,
                                          int[] maxs,
                                          Set<Integer> ignore) {
        int max = -1;
        Set<Integer> nextLines = new HashSet<>();
        for (int i = 0; i < maxs.length; i++) {
            Set<Integer> nl = findNextLines(star, overlap, maxs, i, ignore);
            if (maxs[i] > max && nl.size() > 0) {
                max = maxs[i];
                nextLines = nl;
            } else if (maxs[i] == max && nl.size() > nextLines.size()) {
                nextLines = nl;
            }
        }
        return nextLines;
    }

    private static int min(int[][] star, Set<Integer>[][] overlap, int[] maxs) {
        int min = 0;
        Set<Integer> lines;
        Set<Integer> ignore = new HashSet<>();
        while ((lines = nextLines(star, overlap, maxs, ignore)).size() > 0) {
            min += maxs[lines.iterator().next()];
            ignore.addAll(lines);
        }
        return min;
    }

    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static void main(String[] args) throws IOException {
        String currentLine;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().isEmpty()) {
            String[] input = currentLine.split(" ");
            int[] maxs = new int[12];
            for (int i = 0; i < 12; i++) {
                maxs[i] = Integer.parseInt(input[i]);
            }
            int[][] star = Arrays.stream(STAR).map(int[]::clone).toArray(int[][]::new);
            Set<Integer>[][] overlap = new HashSet[8][11];
            fill(star, maxs, overlap);
            if (isValid(star, maxs)) {
                int max = sum(star);
                int min = min(star, overlap, maxs);
                System.out.println(min + " " + max);
            } else {
                System.out.println("NO SOLUTION");
            }
        }
    }
}

@


\subsection{Bee Maja}

To solve this problem you just need to notice the pattern occurring when
traversing cells. Let's say d means down, dl means down and left, lu means left
and up, u means up, ru means right and up, rd means right and down. On the
first circle it goes like this: 1 d, 0 dl, 1 lu, 1 u, 1 ru, 1 rd, 1 d. On the
second circle it goes 1 d, 1 dl, 2 lu, 2 u, 2 ru, 2 rd, 2 d. On the third it
goes 1 d, 2 dl, 3 lu, 3 u, 3 ru, 3 rd, 3 d. Now you can spot the pattern and
simply implement a lookup table for all 100000 values.

<<Bee Maja>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class BeeMaja {
    private static int[][] PATTERN = {
            {0, 1}, {-1, 1}, {-1, 0}, {0, -1}, {1, -1}, {1, 0}, {0, 1}
    };

    private static int[][] getLookup() {
        int[][] lookup = new int[100000][2];
        int x = 0;
        int y = 0;
        int l = 0;
        int c = 0;
        int i = 0;
        lookup[0] = new int[]{0, 0};
        while (c < 100000) {
            int m = i % 7;
            if (m == 0) ++l;
            int r;
            if (m == 0) {
                r = 1;
            } else if (m == 1) {
                r = l - 1;
            } else {
                r = l;
            }
            for (int j = 0; j < r; j++) {
                x += PATTERN[m][0];
                y += PATTERN[m][1];
                c++;
                if (c == 100000) return lookup;
                lookup[c] = new int[]{x, y};
            }
            i++;
        }
        return lookup;
    }

    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static void main(String[] args) throws IOException {
        int[][] lookup = getLookup();
        String currentLine;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().isEmpty()) {
            int n = Integer.parseInt(currentLine) - 1;
            System.out.println(lookup[n][0] + " " + lookup[n][1]);
        }
    }
}

@

\subsection{Robbery}

From each cell we try to see if it could have ever been a cell where the robber
could end up at time $t$. The robber could end up in this cell if the robber
has already been there, or if they came from one of the adjacent cells. The
robber cannot be in the cells that are being observed. If there's at least one
adjacent cell that is not observed at $t - 1$, then the robber came to the
current cell from there. Thus we recursively keep tracing such cells until we
reach $t = 1$. If after we haver tried every cell we see there are no cells
where the robber could have ended up at time $t$, we conclude the robber has
escaped. Otherwise for each $t_i \leq t$ we check if there's only one cell where
the robber could have been hiding, we output that. If, however, there are
multiple such cells, then we can't conclude unambiguously where the robber was
and we skip such $t_i$. If every singe $t_i$ was ambiguous, we conclude that
nothing is known. Thanks \cite{Faximan} for a nice and concise solution.

<<Robbery>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Robbery {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));
    private static final Boolean HIDDEN = Boolean.FALSE;
    private static final Boolean VISIBLE = Boolean.TRUE;
    private static int[][] DIRECTION = {{0, 0}, {-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    private static boolean inCity(int x, int y, Boolean[][][] city) {
        return x >= 1 && x < city[0].length && y >= 1 && y < city.length;
    }

    private static Boolean visibility(Boolean[][][] city, int x, int y, int time) {
        if (!inCity(x, y, city)) {
            return VISIBLE;
        }
        if (city[y][x][time] != null) {
            return city[y][x][time];
        }
        if (time == 1) {
            city[y][x][time] = HIDDEN;
            return city[y][x][time];
        }

        boolean hidden = false;
        for (int i = 0; i < DIRECTION.length; i++) {
            boolean isHidden = visibility(
			city, 
			x + DIRECTION[i][0], 
			y + DIRECTION[i][1], 
			time - 1) == HIDDEN;
            hidden |= isHidden;
        }

        city[y][x][time] = hidden ? HIDDEN : VISIBLE;
        return city[y][x][time];
    }

    private static int[] findUniqueLocation(Boolean[][][] city, int time) {
        List<int[]> locations = new ArrayList<>();
        for (int y = 1; y < city.length; y++) {
            for (int x = 1; x < city[0].length; x++) {
                if (city[y][x][time] == HIDDEN) {
                    locations.add(new int[]{x, y});
                }
            }
        }
        return locations.size() == 1 ? locations.get(0) : null;
    }

    public static void main(String[] args) throws IOException {
        String currentLine;
        int count = 0;
        while ((currentLine = reader.readLine()) != null) {
            if (currentLine.isEmpty()) {
                continue;
            }
            Integer[] input = Arrays.stream(
                currentLine.trim().split(" ")).map(Integer::parseInt).toArray(l -> new Integer[l]);
            int w = input[0];
            int h = input[1];
            int t = input[2];
            if (w == 0 && h == 0 && t == 0) break;
            System.out.println("Robbery #" + (++count) + ":");
            Boolean[][][] city = new Boolean[h + 1][w + 1][t + 1]; // h x w x t
            int n = Integer.parseInt(reader.readLine());
            for (int i = 0; i < n; i++) {
                Integer[] m = Arrays.stream(
                    reader.readLine().trim().split(" "))
                        .map(Integer::parseInt).toArray(l -> new Integer[l]);
                // 0 time 1 left 2 top 3 right 4 bottom
                for (int x = m[1]; x <= m[3]; x++) {
                    for (int y = m[2]; y <= m[4]; y++) {
                        city[y][x][m[0]] = VISIBLE;
                    }
                }
            }

            boolean escaped = true;
            for (int y = 1; y <= h; y++) {
                for (int x = 1; x <= w; x++) {
                    if (visibility(city, x, y, t) == HIDDEN) {
                        escaped = false;
                    }
                }
            }

            if (escaped) {
                System.out.println("The robber has escaped.");
            } else {
                List<String> output = new ArrayList<>();
                for (int time = 1; time <= t; time++) {
                    int[] loc = findUniqueLocation(city, time);
                    if (loc != null) {
                        output.add("Time step " + time + 
                            ": The robber has been at " + loc[0] + "," + loc[1] + ".");
                    }
                }
                if (output.isEmpty()) {
                    System.out.println("Nothing known.");
                } else {
                    output.forEach(System.out::println);
                }
            }
            System.out.println();
        }
    }
}

@

\subsection{(2/3/4)-D Sqr/Rects/Cubes/Boxes?}

To count squares you simply fix a square of a certain size and imagine it
sliding from left to right while counting how many of those fit, then shift it
down by one unit, and repeat, until you've exhausted all the positions. You can
also think of it this way: Take a square of size $4$. Obviously only one square
of size $4$ fits in it. Now take a square of size $3$, you see that $4$ of
these fit. Take $2$, and $9$ of those fit. Finally, take $1$, and $16$ fit.
It's not hard to spot a pattern here. With $1 \le i \le n$, you get
$(n-i+1)^2$, so the number of all squares will be equal to
$\sum_{i=n}^{1}(n-i+1)^2 = \sum_{i=1}^{n}i^2$.

What about rectangles? It's the same idea, really. Just need two variables for
the sides of rectangles: $\sum_{i=1}^{n}\sum_{j=1}^{n}ij$. This will count
in squares though, but we can simply check if $i = j$ and count those as
squares separately. 

What about three dimensions? Same situation, but with three variables. Four
dimensions? Four variables.

So it will be for loops nested? Yes, but it will be fast enough, because we
only need monotonically non-decreasing set of values. We multiply them all, and
then also multiple by a another factor which is calculated using permutations
with repetition. Since we only have up to four elements, all in sorted order,
we can easily have a few cases to account for each of them in each of
the dimensions.

The resulting loop looks hairy, but in practice it's quick enough and can be used to
calculate the whole lookup table for all possible inputs within a fraction of
allowed time.

<<SqrRectsCubesBoxes>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class SqrRectsCubesBoxes {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static long[] calculate(int n) {
        long[] res = new long[]{0, 0, 0, 0, 0, 0};
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j++) {
                int ij = i * j;
                if (i <= n && j <= n) {
                    if (i == j) {
                        res[0] += ij;
                    } else {
                        res[1] += ij * 2;
                    }
                }
                for (int k = j; k <= n; k++) {
                    int ijk = ij * k;
                    if (i <= n && j <= n && k <= n) {
                        boolean a = i == j;
                        boolean b = j == k;
                        if (a && b) {
                            res[2] += ijk;
                        } else if (a && !b || !a && b ) {
                            res[3] += ijk * 3;
                        } else {
                            res[3] += ijk * 6;
                        }
                    }
                    for (int l = k; l <= n; l++) {
                        boolean a = i == j;
                        boolean b = j == k;
                        boolean c = k == l;
                        if (i == j && j == k && k == l) {
                            res[4] += ijk * l;
                        } else {
                            long f = 0;
                            if (a && !b && !c || !a && b && !c || !a && !b && c) {
                                f = 12;
                            } else if (a && b && !c || !a && b && c) {
                                f = 4;
                            } else if (!a && !b && !c) {
                                f = 24;
                            } else {
                                f = 6;
                            }
                            res[5] += ijk * l * f;
                        }
                    }
                }
            }
        }
        return res;
    }

    public static void main(String[] args) throws IOException {
        long[][] lookup = new long[101][6];
        for (int i = 0; i <= 100; i++) {
            lookup[i] = calculate(i);
        }
        String currentLine;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().isEmpty()) {
            int n = Integer.parseInt(currentLine);
            long[] res = lookup[n];
            System.out.println(String.format(
                "%d %d %d %d %d %d", res[0], res[1], res[2], res[3], res[4], res[5]));
        }
    }
}

@

\subsection{Dermuba Triangle}

First, something to notice about the structure of the triangle. Each row begins
with the square of the row number. So given a number, $n$, we can determine its
row as $s_n=\lfloor{\sqrt{n}}\rfloor$. Now we can calculate the relative
distance from the first cell to the target cell on this row. For example, if
$n=8$, then the row $s_n=\lfloor{\sqrt{8}}\rfloor=2$. Also this determines the
number in the first cell of this row, which is $2^2=4$. We know that the edge
size is $1$, so we can count in halves, $1/2$. Between $8$ and $4$ there are 4
halves, therefore the distance is $(8-4)/2=2$. This calculation works on any
row with any cell. In general, it is $l_1=(n-s_n^2)/2$.

Let's keep this distance relative to the target cell, so it will be some
negative value (or $0$). Let's now determine the other row. Given $m$ we do the
same calculation and determine its row, i.e. $s_m=\lfloor{\sqrt{m}}\rfloor$. Now
we would like to extend this $l_1$ distance so that it aligns with the first
cell of the $s_m$ row. Notice that with each subsequent row it extends by a half
again, so we can calculate this extension as $d=(s_m-s_n)/2$. 

Now on row $s_m$ we calculate the distance to the target cell using the same
calculation principle, i.e. $l_2=(m-s_m^2)/2$. Now if we add $x=l_2-l_1-d$
we get the distance between $n$ and $m$ on horizontal axis.

Let's determine the distance on vertical axis now. The height of the triangle
is obviously $\sqrt{3}/2$. Thus the distance between rows is $y=(s_m-
s_n)\sqrt{3}/2$. But we have been told the houses are located in the
circumcenters of the triangles, so we need to make a little adjustment to this
value $y$. Looking at the picture it's not difficult to notice that on the rows
whose numbers are even and if the target's cell value is even, then the house
location is elevated from the baseline by $\sqrt{3}/6$; and for the odd numbers
it will be elevated by $\sqrt{3}/2-\sqrt{3}/6$. So for number $n$ we add this
value, and for number $m$ we subtract it.

We have effectively determined the sides of a right triangle. The distance 
is simply $\sqrt{x^2+y^2}$. 

<<Dermuba Triangle>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.util.Scanner;

public class DermubaTriangle {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    public static final double SQRT3 = Math.sqrt(3);
    private static double D2 = SQRT3 / 6.0;
    private static double D1 = SQRT3 / 2.0 - D2;

    private static double adjust(int sn, int n) {
        if (sn % 2 == 0) {
            return n % 2 == 0 ? D2 : D1;
        } else {
            return n % 2 == 0 ? D1 : D2;
        }
    }

    private static double calculate(int n, int m) {
        int sn = (int) Math.floor(Math.sqrt((double) n));
        int sm = (int) Math.floor(Math.sqrt((double) m));
        double d = (sm - sn) / 2.0;

        double l1 = -(n - sn * sn) / 2.0;
        double ll = l1 - d;
        double l2 = +(m - sm * sm) / 2.0;
        double x = l2 + ll;

        double y = (sm - sn) * SQRT3 / 2.0;
        y += adjust(sn, n);
        y -= adjust(sm, m);
        return Math.sqrt(y * y + x * x);
    }

    public static void main(String[] args) throws IOException {
        DecimalFormat df = new DecimalFormat("0.000");
        df.setRoundingMode(RoundingMode.HALF_EVEN);
        String currentLine;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().isEmpty()) {
            Scanner s = new Scanner(currentLine);
            int n = s.nextInt();
            int m = s.nextInt();
            double distance = calculate(n, m);
            System.out.println(df.format(distance));
        }
    }
}

@

\subsection{Airlines}

It's a straightforward task. For the geodesic distance calculation I looked up
the formula in the wikipedia. I guess in the competition setting people would
need to come up with their own calculations which would be the main challenge
with this task, because once you've figured this out, the rest is a direct
application of Dijkstra's algorithm.

<<Airlines>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;

import static java.lang.Math.asin;
import static java.lang.Math.cos;
import static java.lang.Math.sqrt;

public class Airlines {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static final double R = 6378.0;
    private static final double PI = 3.141592653589793;
    private static final double K = PI / 180.0;

    private static long distance(double phi1, double lam1, double phi2, double lam2) {
        double phi1r = phi1 * K;
        double phi2r = phi2 * K;
        double phid = phi2r - phi1r;
        double lamd = (lam2 - lam1) * K;
        double d = 2.0 * R * asin(sqrt((1 - cos(phid) + cos(phi1r) * cos(phi2r) * (1 - cos(lamd))) / 2));
        return Math.round(d);
    }

    private static class City {
        String city;
        long total;

        public City(String city, long total) {
            this.city = city;
            this.total = total;
        }
    }

    private static long shortest(String from, String to, Map<String, Map<String, Long>> graph) {
        if (!graph.containsKey(from)) {
            return -1;
        }
        PriorityQueue<City> queue = new PriorityQueue<>(Comparator.comparingLong(a -> a.total));
        City start = new City(from, 0);
        queue.add(start);
        Set<String> visited = new HashSet<>();
        Map<String, City> min = new HashMap<>();
        min.put(start.city, start);

        while (!queue.isEmpty()) {
            City v = queue.poll();
            visited.add(v.city);

            if (v.city.equalsIgnoreCase(to)) {
                return v.total;
            }

            if (!graph.containsKey(v.city)) continue;
            Set<String> neighbours = graph.get(v.city).keySet();

            for (String connected : neighbours) {
                if (visited.contains(connected)) continue;
                long distance = graph.get(v.city).get(connected);
                long totalDistance = v.total + distance;
                if (min.containsKey(connected)) {
                    City connectedCity = min.get(connected);
                    if (connectedCity.total > totalDistance) {
                        connectedCity.total = totalDistance;
                        queue.remove(connected);
                        queue.add(connectedCity);
                    }
                } else {
                    City value = new City(connected, totalDistance);
                    min.put(connected, value);
                    queue.add(value);
                }
            }
        }

        if (!min.containsKey(to)) {
            return -1;
        }
        return min.get(to).total;
    }

    public static void main(String[] args) throws IOException {
        int k = 0;
        String currentLine;
        while ((currentLine = reader.readLine()) != null &&
                !currentLine.trim().isEmpty()) {
            Map<String, double[]> cities = new HashMap<>();
            Map<String, Map<String, Long>> graph = new HashMap<>();
            String[] nmq = currentLine.split(" ");
            int n = Integer.parseInt(nmq[0]);
            int m = Integer.parseInt(nmq[1]);
            int q = Integer.parseInt(nmq[2]);
            if (n == 0) break;
            if (k > 0) System.out.println();
            System.out.println("Case #" + (++k));
            for (int i = 0; i < n; i++) {
                String[] cityLtLn = reader.readLine().split(" ");
                String city = cityLtLn[0];
                double lt = Double.parseDouble(cityLtLn[1]);
                double ln = Double.parseDouble(cityLtLn[2]);
                cities.put(city, new double[]{lt, ln});
            }
            for (int i = 0; i < m; i++) {
                String[] fromTo = reader.readLine().split(" ");
                String from = fromTo[0];
                String to = fromTo[1];
                graph.putIfAbsent(from, new HashMap<>());
                graph.get(from).putIfAbsent(to,
                        distance(
                                cities.get(from)[0],
                                cities.get(from)[1],
                                cities.get(to)[0],
                                cities.get(to)[1]
                        ));
            }
            for (int i = 0; i < q; i++) {
                String[] fromTo = reader.readLine().split(" ");
                String from = fromTo[0];
                String to = fromTo[1];
                long shortest = shortest(from, to, graph);
                if (shortest == -1) {
                    System.out.println("no route exists");
                } else {
                    System.out.println(shortest + " km");
                }
            }
        }
    }
}

@

\section{Geometry}

\subsection{Dog and Gopher}

This is a very straightforward problem. Simply calculate the distance from the
dog and the gopher to each hole as you read the input. The moment you found a
hole to which either the distance is zero or twice the distance from the
gopher to the hole is smaller than the distance from the dog and the hole, you
found the answer. If you've tried every input and found nothing, the gopher
cannot escape.

<<Dog and Gopher>>=
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.RoundingMode;
import java.text.DecimalFormat;

public class DogAndGopher {
    private static final BufferedReader reader = new BufferedReader(
            new InputStreamReader(System.in));

    private static long len(double x, double y, double gx, double gy) {
        double lx = (gx - x) * (gx - x);
        double ly = (gy - y) * (gy - y);
        return Math.round(Math.sqrt(lx + ly) * 1000.0);
    }

    public static void main(String[] args) throws IOException {
        DecimalFormat df = new DecimalFormat("0.000");
        df.setRoundingMode(RoundingMode.HALF_EVEN);

        String currentLine;
        while ((currentLine = reader.readLine()) != null) {
            if (currentLine.trim().isEmpty()) continue;
            String[] l = currentLine.split(" ");
            int n = Integer.parseInt(l[0]);
            double gx = Double.parseDouble(l[1]);
            double gy = Double.parseDouble(l[2]);
            double dx = Double.parseDouble(l[3]);
            double dy = Double.parseDouble(l[4]);
            boolean found = false;
            for (int i = 0; i < n; i++) {
                String[] hole =  reader.readLine().split(" ");
                double x = Double.parseDouble(hole[0]);
                double y = Double.parseDouble(hole[1]);
                long len1 = len(x, y, gx, gy);
                long len2 = len(x, y, dx, dy);
                if ((len1 == 0 || len1*2 <= len2) && !found) {
                    System.out.println("The gopher can escape through the hole at (" 
                        + df.format(x) + "," + df.format(y) + ").");
                    found = true;
                }
            }
            if (!found) {
                System.out.println("The gopher cannot escape.");
            }
        }
    }
}

@

\section{Computational Geometry}

\section{License}

Copyright\textcopyright 2017 Roman Valiu\v{s}enko
\vskip 0.1in
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
\vskip 0.1in
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
\vskip 0.1in
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


\newpage

\begin{thebibliography}{99}

\bibitem{Knuth1984} Donald E. Knuth, Literate Programming, The Computer
Journal, 1984

\bibitem{PC} Skiena, Steven S., Revilla, Miguel A., Programming Challenges, 2003

\bibitem{SE} \url{https://en.wikipedia.org/wiki/Sieve\_of\_Eratosthenes}

\bibitem{EEA} \url{https://en.wikipedia.org/wiki/Extended\_Euclidean\_algorithm}

\bibitem{ME} \url{https://en.wikipedia.org/wiki/Modular\_exponentiation}

\bibitem{ENT} Gareth A. Jones, Josephine M. Jones, Elementary Number Theory, 1998 

\bibitem{15PZL} Slocum, Jerry and Weisstein, Eric W. "15 Puzzle." From MathWorld--A Wolfram Web Resource. http://mathworld.wolfram.com/15Puzzle.html

\bibitem{IDA*} \url{https://en.wikipedia.org/wiki/Iterative\_deepening\_A*}

\bibitem{FW} \url{https://en.wikipedia.org/wiki/Floyd-Warshall\_algorithm}

\bibitem{MAXIMIN} \url{http://masc.cs.gmu.edu/wiki/floydwarshall/}

\bibitem{AlexLange} \url{https://github.com/alex-lange/contest-programming/blob/master/uva/10039/Main.java}

\bibitem{DP3} \url{http://www.cs.cornell.edu/~wdtseng/icpc/notes/dp3.pdf}

\bibitem{TOW} \url{https://github.com/morris821028}

\bibitem{OEIS} \url{https://oeis.org/A018835}

\bibitem{DS} \url{https://en.wikipedia.org/wiki/Disjoint-set_data_structure}

\bibitem{ARP} \url{https://en.wikipedia.org/wiki/Biconnected_component}

\bibitem{TURTLE} \url{https://cgi.cse.unsw.edu.au/~cs3121/Lectures/COMP3121_Lecture_Notes_DP.pdf}

\bibitem{Faximan} \url{https://github.com/faximan/uva/blob/master/707-Robbery.cpp}

\end{thebibliography}

\vskip 16pt
\hrule
\vskip 6pt

\paragraph{Definitions}\par\noindent

\nowebchunks

\paragraph{Index}\par\noindent

\nowebindex
@

\end{document}

